

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/weiblog/img/fluid.png">
  <link rel="icon" href="/weiblog/img/bg/%E5%A4%B4%E5%83%8F.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wei Shao">
  <meta name="keywords" content="">
  
    <meta name="description" content="基础说下计算机网络体系结构计算机网络体系结构，一般有三种：OSI 七层模型、TCP&#x2F;IP 四层模型、五层结构。  简单说，OSI是一个理论上的网络通信模型，TCP&#x2F;IP是实际上的网络通信模型，五层结构就是为了介绍网络原理而折中的网络通信模型。 OSI 七层模型OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用">
<meta property="og:type" content="article">
<meta property="og:title" content="面试-计算机网络">
<meta property="og:url" content="https://weishao996.gitee.io/weiblog/2022/09/14/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="WeiBlog">
<meta property="og:description" content="基础说下计算机网络体系结构计算机网络体系结构，一般有三种：OSI 七层模型、TCP&#x2F;IP 四层模型、五层结构。  简单说，OSI是一个理论上的网络通信模型，TCP&#x2F;IP是实际上的网络通信模型，五层结构就是为了介绍网络原理而折中的网络通信模型。 OSI 七层模型OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914105946014.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914110343078.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914110821509.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914111009624.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914111154827.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914111304899.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914112040289.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914112622852.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914113033757.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914114104380.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914114203771.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914115326440.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914115634809.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914130151408.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914134739072.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914140946859.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914141753002.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914141816333.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914141955788.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914145805140.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914150505696.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914151332272.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914154622322.png">
<meta property="article:published_time" content="2022-09-14T02:54:41.000Z">
<meta property="article:modified_time" content="2022-09-14T08:45:49.509Z">
<meta property="article:author" content="Wei Shao">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914105946014.png">
  
  
  
  <title>面试-计算机网络 - WeiBlog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/weiblog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/weiblog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/weiblog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"weishao996.gitee.io","root":"/weiblog/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"Java"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/weiblog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/weiblog/js/utils.js" ></script>
  <script  src="/weiblog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/weiblog/">
      <strong>威少のBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/weiblog/img/bg/iTab-6ozkzl.jfif') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试-计算机网络"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-14 10:54" pubdate>
          2022年9月14日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试-计算机网络</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="说下计算机网络体系结构"><a href="#说下计算机网络体系结构" class="headerlink" title="说下计算机网络体系结构"></a>说下计算机网络体系结构</h2><p>计算机网络体系结构，一般有三种：OSI 七层模型、TCP/IP 四层模型、五层结构。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914105946014.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914105946014"></p>
<p>简单说，OSI是一个理论上的网络通信模型，TCP/IP是实际上的网络通信模型，五层结构就是为了介绍网络原理而折中的网络通信模型。</p>
<h3 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h3><p>OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。</p>
<ul>
<li>应用层：通过应用进程之间的交互来完成特定网络应用，应用层协议定义的是应用进程间通信和交互的规则，常见的协议有：HTTP FTP SMTP SNMP DNS.</li>
<li>表示层：数据的表示、安全、压缩。确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。</li>
<li>会话层：建立、管理、终止会话，是用户应用程序和网络之间的接又。</li>
<li>运输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。</li>
<li>网络层：将网络地址翻译成对应的物理地址，实现不同网络之间的路径选择, 协议有ICMP IGMP IP 等.</li>
<li>数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。</li>
<li>物理层：建立、维护、断开物理连接。</li>
</ul>
<h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><ul>
<li>应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。</li>
<li>传输层: 对应 OSI 的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。</li>
<li>网际层：对应于 OSI 参考模型的网络层，主要解决主机到主机的通信问题。</li>
<li>网络接口层：与 OSI 参考模型的数据链路层、物理层对应。</li>
</ul>
<h3 id="五层体系结构"><a href="#五层体系结构" class="headerlink" title="五层体系结构"></a>五层体系结构</h3><ul>
<li>应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。</li>
<li>传输层：对应 OSI 参考模型的的传输层</li>
<li>网络层：对应 OSI 参考模型的的网络层</li>
<li>数据链路层：对应 OSI 参考模型的的数据链路层</li>
<li>物理层：对应 OSI 参考模型的的物理层。</li>
</ul>
<h2 id="说一下每一层对应的网络协议有哪些？"><a href="#说一下每一层对应的网络协议有哪些？" class="headerlink" title="说一下每一层对应的网络协议有哪些？"></a>说一下每一层对应的网络协议有哪些？</h2><p>一张表格总结常见网络协议：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914110343078.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914110343078"></p>
<h2 id="那么数据在各层之间是怎么传输的呢？"><a href="#那么数据在各层之间是怎么传输的呢？" class="headerlink" title="那么数据在各层之间是怎么传输的呢？"></a>那么数据在各层之间是怎么传输的呢？</h2><p>对于发送方而言，从上层到下层层层包装，对于接收方而言，从下层到上层，层层解开包装。</p>
<ul>
<li>发送方的应用进程向接收方的应用进程传送数据</li>
<li>AP先将数据交给本主机的应用层，应用层加上本层的控制信息H5就变成了下一层的数据单元</li>
<li>传输层收到这个数据单元后，加上本层的控制信息H4，再交给网络层，成为网络层的数据单元</li>
<li>到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）</li>
<li>最后的物理层，进行比特流的传输</li>
</ul>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914110821509.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914110821509"></p>
<p>这个过程类似写信，写一封信，每到一层，就加一个信封，写一些地址的信息。到了目的地之后，又一层层解封，传向下一个目的地。</p>
<h1 id="网络综合"><a href="#网络综合" class="headerlink" title="网络综合"></a>网络综合</h1><h2 id="从浏览器地址栏输入-url-到显示主页的过程？"><a href="#从浏览器地址栏输入-url-到显示主页的过程？" class="headerlink" title="从浏览器地址栏输入 url 到显示主页的过程？"></a>从浏览器地址栏输入 url 到显示主页的过程？</h2><p>这道题，大概的过程比较简单，但是有很多点可以细挖：DNS解析、TCP三次握手、HTTP报文格式、TCP四次挥手等等。</p>
<ol>
<li>DNS 解析：将域名解析成对应的 IP 地址。</li>
<li>TCP连接：与服务器通过三次握手，建立 TCP 连接</li>
<li>向服务器发送 HTTP 请求</li>
<li>服务器处理请求，返回HTTp响应</li>
<li>浏览器解析并渲染页面</li>
<li>断开连接：TCP 四次挥手，连接结束<br>我们以输入<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 为例：</li>
</ol>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914111009624.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914111009624"></p>
<p>各个过程都使用了哪些协议？</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914111154827.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914111154827"></p>
<h2 id="说说-DNS-的解析过程？"><a href="#说说-DNS-的解析过程？" class="headerlink" title="说说 DNS 的解析过程？"></a>说说 DNS 的解析过程？</h2><p>DNS，英文全称是 domain name system ，域名解析系统，它的作用也很明确，就是域名和 IP<br>相互映射。<br>DNS 的解析过程如下图：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914111304899.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914111304899">假设你要查询 <a target="_blank" rel="noopener" href="http://www.baidu.com/">http://www.baidu.com</a> 的 IP 地址:</p>
<ul>
<li>首先会查找浏览器的缓存,看看是否能找到<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 对应的IP地址，找到就直接返回；否则进行下一步。</li>
<li>将请求发往给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步；</li>
</ul>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914112040289.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914112040289"></p>
<ul>
<li>本地DNS服务器向根域名服务器发送请求，<strong>根域名服务器</strong>返回负责com 的顶级域名服务器的IP地址的列表。</li>
<li>本地DNS服务器再向其中一个负责<strong>com 的顶级域名服务器</strong>发送一个请求，返回负责baidu.com 的权限域名服务器的IP地址列表。</li>
<li>本地DNS服务器再向其中一个<strong>权限域名服务器</strong>发送一个请求，返回<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 所对应的IP地址。</li>
</ul>
<h2 id="说说-WebSocket-与-Socket-的区别？"><a href="#说说-WebSocket-与-Socket-的区别？" class="headerlink" title="说说 WebSocket 与 Socket 的区别？"></a>说说 WebSocket 与 Socket 的区别？</h2><ul>
<li>Socket 其实就是等于 <strong>IP 地址 + 端又 + 协议</strong>。</li>
</ul>
<blockquote>
<p>具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便<br>开发者更好地进行网络编程。</p>
</blockquote>
<ul>
<li>WebSocket 是一个<strong>持久化</strong>的协议，它是伴随 H5 而出的协议，用来解决 http 不支持持久化连接的问题。</li>
<li>Socket 一个是网编编程的标准接口，而 WebSocket 则是应用层通信协议。</li>
</ul>
<h2 id="说一下你了解的端口及对应的服务？"><a href="#说一下你了解的端口及对应的服务？" class="headerlink" title="说一下你了解的端口及对应的服务？"></a>说一下你了解的端口及对应的服务？</h2><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914112622852.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914112622852"></p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="说说-HTTP-常用的状态码及其含义？"><a href="#说说-HTTP-常用的状态码及其含义？" class="headerlink" title="说说 HTTP 常用的状态码及其含义？"></a>说说 HTTP 常用的状态码及其含义？</h2><ul>
<li><strong>1XX：信息性状态码</strong></li>
<li><strong>2XX：成功状态码</strong></li>
<li><strong>3XX：重定向状态码</strong></li>
<li><strong>4XX：客户端错误状态码</strong></li>
<li><strong>5XX：服务端错误状态码</strong></li>
</ul>
<p>几个常用的，面试之外，也应该记住：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914113033757.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914113033757"></p>
<h3 id="说一下-301-和-302-的区别？"><a href="#说一下-301-和-302-的区别？" class="headerlink" title="说一下 301 和 302 的区别？"></a>说一下 301 和 302 的区别？</h3><ul>
<li>301 ：永久性移动，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址。</li>
<li>302 ：临时性性移动，服务器从另外的地址响应资源，但是客户端还应该使用这个地址。</li>
</ul>
<h2 id="HTTP-有哪些请求方式？"><a href="#HTTP-有哪些请求方式？" class="headerlink" title="HTTP 有哪些请求方式？"></a>HTTP 有哪些请求方式？</h2><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914114104380.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914114104380"></p>
<p>其中，<strong>POST、DELETE、PUT、GET</strong>的含义分别对应我们最熟悉的<strong>增、删、改、查</strong>。</p>
<h2 id="说一下-GET-和-POST-的区别？"><a href="#说一下-GET-和-POST-的区别？" class="headerlink" title="说一下 GET 和 POST 的区别？"></a>说一下 GET 和 POST 的区别？</h2><p>可以从以下几个方面来说明GET和POST的区别：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914114203771.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914114203771"></p>
<ol>
<li>从 HTTP 报文层面来看，GET 请求将信息放在 URL，POST 将请求信息放在请求体中。这一点使得 GET 请求携带的数据量有限，因为 URL 本身是有长度限制的，而 POST 请求的数据存放在报文体中，因此对大小没有限制。而且从形式上看，GET 请求把数据放URL 上不太安全，而 POST 请求把数据放在请求体里想比较而言安全些。</li>
<li>从数据库层面来看，GET 符合幂等性和安全性，而 POST 请求不符合。这个其实和GET/POST 请求的作用有关。按照 HTTP 的约定，GET 请求用于查看信息，不会改变服务器上的信息；而 POST 请求用来改变服务器上的信息。正因为 GET 请求只查看信息，不改变信息，对数据库的一次或多次操作获得的结果是一致的，认为它符合幂等性。安全性是指对数据库操作没有改变数据库中的数据。</li>
<li>从其他层面来看，GET 请求能够被缓存，GET 请求能够保存在浏览器的浏览记录里，GET 请求的 URL 能够保存为浏览器书签。这些都是 POST 请求所不具备的。缓存是 GET请求被广泛应用的根本，他能够被缓存也是因为它的幂等性和安全性，除了返回结果没有其他多余的动作，因此绝大部分的 GET 请求都被 CDN 缓存起来了，大大减少了 Web 服务器的负担。</li>
</ol>
<h2 id="GET-的长度限制是多少？"><a href="#GET-的长度限制是多少？" class="headerlink" title="GET 的长度限制是多少？"></a>GET 的长度限制是多少？</h2><p>HTTP中的GET方法是通过URL传递数据的，但是URL本身其实并没有对数据的长度进行限制，真正限制GET长度的是浏览器。<br>例如IE浏览器对URL的最大限制是 2000 多个字符，大概2kb左右，像Chrome、Firefox等浏览器支持的URL字符数更多，其中FireFox中URL的最大长度限制是 65536 个字符，Chrome则是8182 个字符。<br>这个长度限制也不是针对数据部分，而是针对整个URL。</p>
<h2 id="HTTP-请求的过程与原理？"><a href="#HTTP-请求的过程与原理？" class="headerlink" title="HTTP 请求的过程与原理？"></a>HTTP 请求的过程与原理？</h2><p>HTTP协议定义了浏览器怎么向服务器请求文档，以及服务器怎么把文档传给浏览器。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914115326440.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914115326440"></p>
<ul>
<li>每个服务器都有一个进程，它不断监听TCP的端口 80 ，以便发现是否有浏览器向它发出连接建立请求</li>
<li>监听到连接请求，就会建立TCP连接</li>
<li>浏览器向服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应</li>
<li>最后，释放TCP连接</li>
</ul>
<p>在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则，这些格式和规则就是超文本传输协议HTTP。<br>PS:这道题和上面浏览器输入网址发生了什么那道题大差不差。</p>
<h2 id="说一下HTTP的报文结构？"><a href="#说一下HTTP的报文结构？" class="headerlink" title="说一下HTTP的报文结构？"></a>说一下HTTP的报文结构？</h2><p>HTTP报文有两种，HTTP请求报文和HTTP响应报文：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914115634809.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914115634809"></p>
<p><strong>HTTP请求报文</strong><br>HTTP 请求报文的格式如下：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token constant">GET</span> <span class="token operator">/</span> <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span>
<span class="token class-name">User</span><span class="token operator">-</span><span class="token class-name">Agent</span><span class="token operator">:</span> <span class="token class-name">Mozilla</span><span class="token operator">/</span><span class="token number">5.0</span> <span class="token punctuation">(</span><span class="token class-name">Macintosh</span><span class="token punctuation">;</span> <span class="token class-name">Intel</span> <span class="token class-name">Mac</span> <span class="token constant">OS</span> <span class="token class-name">X</span> <span class="token number">10_10_5</span><span class="token punctuation">)</span>
<span class="token class-name">Accept</span><span class="token operator">:</span> <span class="token operator">*</span><span class="token comment">/*</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<p>HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。<br>请求行包含三个字段：</p>
<ul>
<li>方法字段：包括POST、GET等请方法。</li>
<li>URL 字段</li>
<li>HTTP 版本字段。</li>
</ul>
<p><strong>HTTP 响应报文</strong><br>HTTP 响应报文的格式如下：</p>
<figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>Hello World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div></figure>

<p>HTTP 响应报文的第一行叫做 <strong>状态行</strong> ，后面的行是 <strong>首部行</strong> ，最后是 <strong>实体主体</strong> 。</p>
<ul>
<li><p><strong>状态行</strong> 包含了三个字段：协议版本字段、状态码和相应的状态信息。</p>
</li>
<li><p><strong>实体部分</strong> 是报文的主要部分，它包含了所请求的对象。</p>
</li>
<li><p><strong>首部行</strong> 首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。</p>
<ul>
<li><p>常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。</p>
</li>
<li><p>常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。</p>
</li>
<li><p>常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。</p>
</li>
<li><p>常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。</p>
</li>
</ul>
</li>
</ul>
<h2 id="URI-和-URL-有什么区别"><a href="#URI-和-URL-有什么区别" class="headerlink" title="URI 和 URL 有什么区别?"></a>URI 和 URL 有什么区别?</h2><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914130151408.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914130151408"></p>
<ul>
<li>URI，统一资源标识符(Uniform Resource Identifier， URI)，标识的是We b上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都是由一个URI进行标识的。</li>
<li>URL，统一资源定位符（Uniform Resource Location)，它是URI的一种子集，主要作用是提供资源的路径。</li>
</ul>
<p>它们的主要区别在于，URL除了提供了资源的标识，还提供了资源访问的方式。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人——人类住址协议://地球/中国/北京市/海淀区/xx职业技术学院/14号宿舍楼/525号寝/张三.男。</p>
<h2 id="说下-HTTP-1-0，1-1，2-0-的区别？"><a href="#说下-HTTP-1-0，1-1，2-0-的区别？" class="headerlink" title="说下 HTTP/1.0，1.1，2.0 的区别？"></a>说下 HTTP/1.0，1.1，2.0 的区别？</h2><p>关键需要记住 <strong>HTTP/1.0</strong> 默认是<strong>短连接</strong>，可以强制开启，<strong>HTTP/1.1</strong> 默认<strong>长连接</strong>，<strong>HTTP/2.0</strong> 采用<strong>多路复用</strong> 。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><ul>
<li>默认使用短连接，每次请求都需要建立一个 TCP 连接。它可以设置Connection:keep-alive 这个字段，强制开启长连接。</li>
</ul>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><ul>
<li>引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用。</li>
<li>分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。</li>
<li>管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。</li>
</ul>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><ul>
<li>二进制协议，1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制。</li>
<li>完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。</li>
<li>报头压缩，HTTP 协议不带有状态，每次请求都必须附上所有信息。Http/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送。</li>
<li>服务端推送，允许服务器未经请求，主动向客户端发送资源。</li>
</ul>
<h2 id="HTTP-3了解吗？"><a href="#HTTP-3了解吗？" class="headerlink" title="HTTP/3了解吗？"></a>HTTP/3了解吗？</h2><p>HTTP/3主要有两大变化， <strong>传输层基于UDP</strong> 、使用 <strong>QUIC保证UDP可靠性</strong> 。<br>HTTP/2存在的一些问题，比如重传等等，都是由于TCP本身的特性导致的，所以HTTP/3在QUIC的基础上进行发展而来，QUIC（Quick UDP Connections）直译为<strong>快速UDP网络连接</strong>，底层使用UDP进行数据传输。<br>HTTP/3主要有这些特点：</p>
<ul>
<li>使用UDP作为传输层进行通信</li>
<li>在UDP的基础上QUIC协议保证了HTTP/3的安全性，在传输的过程中就完成了TLS加密握手</li>
<li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。</li>
<li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。</li>
</ul>
<p>我们拿一张图看一下HTTP协议的变迁：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914134739072.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914134739072"></p>
<h2 id="HTTP-如何实现长连接？在什么时候会超时？"><a href="#HTTP-如何实现长连接？在什么时候会超时？" class="headerlink" title="HTTP 如何实现长连接？在什么时候会超时？"></a>HTTP 如何实现长连接？在什么时候会超时？</h2><h3 id="什么是-HTTP-的长连接？"><a href="#什么是-HTTP-的长连接？" class="headerlink" title="什么是 HTTP 的长连接？"></a>什么是 HTTP 的长连接？</h3><ol>
<li><p>HTTP 分为长连接和短连接，本质上说的是 TCP 的长短连接。TCP 连接是一个双向的通<br> 道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说<br> 法。</p>
</li>
<li><p>TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消<br> 耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的 JS/CSS。</p>
</li>
</ol>
<h3 id="如何设置长连接？"><a href="#如何设置长连接？" class="headerlink" title="如何设置长连接？"></a>如何设置长连接？</h3><p>  通过在头部（请求和响应头）设置 <strong>Connection</strong> 字段指定为<strong>keep-alive</strong>，HTTP/1.0 协议支<br>  持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。</p>
<h3 id="在什么时候会超时呢？"><a href="#在什么时候会超时呢？" class="headerlink" title="在什么时候会超时呢？"></a>在什么时候会超时呢？</h3><ul>
<li>HTTP 一般会有 httpd 守护进程，里面可以设置 <strong>keep-alive timeout</strong>，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</li>
<li>TCP 的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 tcp_keepalive_time，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 <strong>tcp_keepalive_intvl</strong> 再发一次，直到发送了 <strong>tcp_keepalive_probes</strong>，就会丢弃该连接。</li>
</ul>
<figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">tcp_keepalive_intvl = 15
tcp_keepalive_probes = 5
tcp_keepalive_time = 1800<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></div></figure>

<h2 id="说说HTTP-与-HTTPS-有哪些区别？"><a href="#说说HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="说说HTTP 与 HTTPS 有哪些区别？"></a>说说HTTP 与 HTTPS 有哪些区别？</h2><ol>
<li>HTTP 是<strong>超文本传输协议</strong>，信息是<strong>明文传输</strong>，存在安全风险的问题。HTTPS 则解决 HTTP不安全的缺陷，在TCP 和 HTTP 网络层之间加入了 <strong>SSL/TLS</strong> 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 的端又号是 <strong>80</strong> ，HTTPS 的端又号是 <strong>443</strong> 。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请<strong>数字证书</strong>，来保证服务器的身份是可信的。</li>
</ol>
<h2 id="为什么要用HTTPS？解决了哪些问题？"><a href="#为什么要用HTTPS？解决了哪些问题？" class="headerlink" title="为什么要用HTTPS？解决了哪些问题？"></a>为什么要用HTTPS？解决了哪些问题？</h2><p>因为HTTP 是明文传输，存在安全上的风险：</p>
<ul>
<li><strong>窃听风险</strong> ，比如通信链路上可以获取通信内容，用户账号被盗。</li>
<li><strong>篡改风险</strong> ，比如强制植入垃圾广告，视觉污染。</li>
<li><strong>冒充风险</strong> ，比如冒充淘宝网站，用户金钱损失。</li>
</ul>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914140946859.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914140946859"></p>
<p>所以引入了HTTPS，HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了这些风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示。</li>
<li><strong>身份证书</strong>：能证明淘宝是真淘宝。</li>
</ul>
<p>所以SSL/TLS 协议是能保证通信是安全的。</p>
<h2 id="HTTPS工作流程是怎样的？"><a href="#HTTPS工作流程是怎样的？" class="headerlink" title="HTTPS工作流程是怎样的？"></a>HTTPS工作流程是怎样的？</h2><p>这道题有几个要点： <strong>公私钥、数字证书、加密、对称加密、非对称加密</strong> 。<br>HTTPS 主要工作流程：</p>
<ol>
<li><p>客户端发起 HTTPS 请求，连接到服务端的 443 端口。</p>
</li>
<li><p>服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。</p>
</li>
<li><p>服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。</p>
</li>
<li><p>客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。</p>
</li>
<li><p>客户端将公钥加密后的密钥发送到服务器。</p>
</li>
<li><p>服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。</p>
</li>
<li><p>服务器将加密后的密文返回到客户端。</p>
</li>
<li><p>客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。</p>
</li>
</ol>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914141753002.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914141753002"></p>
<p>这里还画了一张更详尽的图：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914141816333.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914141816333"></p>
<h2 id="客户端怎么去校验证书的合法性？"><a href="#客户端怎么去校验证书的合法性？" class="headerlink" title="客户端怎么去校验证书的合法性？"></a>客户端怎么去校验证书的合法性？</h2><p>首先，服务端的证书从哪来的呢？</p>
<p>为了让服务端的公钥被大家信任，服务端的证书都是由 <strong>CA （Certificate Authority，证书认证机构）</strong>签名的，CA就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914141955788.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914141955788"></p>
<p>CA 签发证书的过程，如上图左边部分：</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li>
<li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li>
</ul>
<p>客户端校验服务端的数字证书的过程，如上图右边部分：</p>
<ul>
<li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li>
<li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate</li>
<li>Signature 内容，得到一个 Hash 值 H2 ；</li>
<li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li>
</ul>
<p>假如在HTTPS的通信过程中，中间人篡改了证书原文，由于他没有CA机构的私钥，所以CA公钥解密的内容就不一致。</p>
<h2 id="如何理解-HTTP-协议是无状态的？"><a href="#如何理解-HTTP-协议是无状态的？" class="headerlink" title="如何理解 HTTP 协议是无状态的？"></a>如何理解 HTTP 协议是无状态的？</h2><p>这个无状态的的状态值的是什么？是客户端的状态，所以字面意思，就是HTTP协议中服务端不会保存客户端的任何信息。<br>比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。</p>
<p><strong>那有什么办法记录状态呢？</strong></p>
<p>主要有两个办法，Session和Cookie。</p>
<h2 id="说说Session-和-Cookie-有什么联系和区别"><a href="#说说Session-和-Cookie-有什么联系和区别" class="headerlink" title="说说Session 和 Cookie 有什么联系和区别?"></a>说说Session 和 Cookie 有什么联系和区别?</h2><p>先来看看什么是 Session 和 Cookie ：</p>
<ul>
<li><strong>Cookie</strong> <strong>是保存在客户端的一小块文本串的数据</strong>。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。<strong>服务端可以根据这个Cookie判断用户的身份和状态</strong>。</li>
<li><strong>Session</strong> <strong>指的就是服务器和客户端一次会话的过程</strong>。它是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找用户的状态。</li>
</ul>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914145805140.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914145805140"></p>
<h3 id="Session-和-Cookie-到底有什么不同呢？"><a href="#Session-和-Cookie-到底有什么不同呢？" class="headerlink" title="Session 和 Cookie 到底有什么不同呢？"></a>Session 和 Cookie 到底有什么不同呢？</h3><ul>
<li>存储位置不一样，Cookie 保存在客户端，Session 保存在服务器端。</li>
<li>存储数据类型不一样，Cookie 只能保存ASCII，Session可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session一般有效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个Cookie保存的数据不能超过4K，Session可存储数据远高于 Cookie。</li>
</ul>
<h3 id="Session-和-Cookie有什么关联呢？"><a href="#Session-和-Cookie有什么关联呢？" class="headerlink" title="Session 和 Cookie有什么关联呢？"></a>Session 和 Cookie有什么关联呢？</h3><p>可以使用Cookie记录Session的标识。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914150505696.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914150505696"></p>
<p>用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。<br>当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<h3 id="分布式环境下Session怎么处理呢？"><a href="#分布式环境下Session怎么处理呢？" class="headerlink" title="分布式环境下Session怎么处理呢？"></a>分布式环境下Session怎么处理呢？</h3><p>分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的Session。</p>
<p>这时候怎么办呢？</p>
<p>可以使用Redis等分布式缓存来存储Session，在多台服务器之间共享。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914151332272.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914151332272"></p>
<h3 id="客户端无法使用Cookie怎么办？"><a href="#客户端无法使用Cookie怎么办？" class="headerlink" title="客户端无法使用Cookie怎么办？"></a>客户端无法使用Cookie怎么办？</h3><p>有可能客户端无法使用Cookie，比如浏览器禁用Cookie，或者客户端是安卓、IOS等等。</p>
<p>这时候怎么办？SessionID怎么存？怎么传给服务端呢？</p>
<p>首先是SessionID的存储，可以使用客户端的本地存储，比如浏览器的sessionStorage。</p>
<p>接下来怎么传呢？</p>
<ul>
<li>拼接到URL里：直接把SessionID作为URL的请求参数</li>
<li>放到请求头里：把SessionID放到请求的Header里，比较常用。</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="详细说一下-TCP-的三次握手机制"><a href="#详细说一下-TCP-的三次握手机制" class="headerlink" title="详细说一下 TCP 的三次握手机制"></a>详细说一下 TCP 的三次握手机制</h2><p>TCP提供面向连接的服务，在传送数据前必须建立连接，TCP连接是通过三次握手建立的。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20220914154622322.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220914154622322"></p>
<p>三次握手的过程：</p>
<ul>
<li>最开始，客户端和服务端都处于CLOSE状态，服务端监听客户端的请求，进入<strong>LISTEN</strong>状态</li>
<li>客户端发送连接请求，第一次握手 (SYN=1, seq=x)，发送完毕后，客户端就进入<strong>SYN_SENT(同步已发送)</strong> 状态</li>
<li>服务端确认连接，第二次握手 (SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服<br>务器端就进入 <strong>SYN_RCV （同步已接受）</strong>状态。</li>
<li>客户端收到服务端的确认之后，再次向服务端确认，这就是第三次握手 (ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 <strong>ESTABLISHED （连接已建立）</strong>状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态。</li>
</ul>
<h2 id="TCP-握手为什么是三次，为什么不能是两次？不能是四次？"><a href="#TCP-握手为什么是三次，为什么不能是两次？不能是四次？" class="headerlink" title="TCP 握手为什么是三次，为什么不能是两次？不能是四次？"></a>TCP 握手为什么是三次，为什么不能是两次？不能是四次？</h2><ul>
<li>为什么不能是两次？</li>
<li>为了防止服务器端开启一些无用的连接增加服务器开销</li>
</ul>
<p>防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。<br>由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了 SYN=1 的第一次握手。<br>如果服务器端就直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试-计算机网络</div>
      <div>https://weishao996.gitee.io/weiblog/2022/09/14/面试-计算机网络/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wei Shao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月14日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/weiblog/2022/09/12/%E9%9D%A2%E8%AF%95-Java%E5%AE%B9%E5%99%A8/" title="面试-Java容器">
                        <span class="hidden-mobile">面试-Java容器</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/weiblog/js/events.js" ></script>
<script  src="/weiblog/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/weiblog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script  src="https://lib.baomitu.com/prism/1.27.0/plugins/line-numbers/prism-line-numbers.min.js" ></script>

  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/weiblog/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/weiblog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
