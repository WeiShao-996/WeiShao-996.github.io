

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/weiblog/img/fluid.png">
  <link rel="icon" href="/weiblog/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wei Shao">
  <meta name="keywords" content="">
  
    <meta name="description" content="基础为什么要使用多线程呢?先从总体上来说：  从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。  从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发">
<meta property="og:type" content="article">
<meta property="og:title" content="面试-Java并发编程">
<meta property="og:url" content="https://weishao996.gitee.io/weiblog/2022/09/02/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="WeiBlog">
<meta property="og:description" content="基础为什么要使用多线程呢?先从总体上来说：  从计算机底层来说： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。  从当代互联网发展趋势来说： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114109343.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114143558.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140118921.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140459345.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141434005.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141608203.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902145605462.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160048587.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160358011.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160517970.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160908374.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2019-4%E6%AD%BB%E9%94%811.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902163020732.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902170811800.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902173027266.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902193325147.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902194739313.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902212750305.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213343066.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213432939.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114356751.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114449779.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903115952545.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133213700.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133644636.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134841710.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134956909.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903135524735.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140353177.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140503354.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140518029.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903180902786.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903181654514.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190305715.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190457240.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903215849935.png">
<meta property="og:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903221140669.png">
<meta property="article:published_time" content="2022-09-02T03:30:31.000Z">
<meta property="article:modified_time" content="2022-09-03T14:18:20.539Z">
<meta property="article:author" content="Wei Shao">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="d:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114109343.png">
  
  
  
  <title>面试-Java并发编程 - WeiBlog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/weiblog/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/weiblog/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/weiblog/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"weishao996.gitee.io","root":"/weiblog/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"Java"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/weiblog/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/weiblog/js/utils.js" ></script>
  <script  src="/weiblog/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/weiblog/">
      <strong>威少のBlog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/weiblog/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/weiblog/img/bg/iTab-6ozkzl.jfif') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试-Java并发编程"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-09-02 11:30" pubdate>
          2022年9月2日 中午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">面试-Java并发编程</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h2><p>先从总体上来说：</p>
<ul>
<li><p><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p>
</li>
<li><p><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而<strong>多线程并发编程</strong>正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p>
</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><p><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</p>
</li>
<li><p><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</p>
</li>
</ul>
<h2 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。</p>
<h2 id="并行跟并发有什么区别？"><a href="#并行跟并发有什么区别？" class="headerlink" title="并行跟并发有什么区别？"></a>并行跟并发有什么区别？</h2><p>从操作系统的角度来看，线程是CPU分配的最小单位。</p>
<ul>
<li>并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。</li>
<li>并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。</li>
</ul>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114109343.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902114109343"></p>
<p>就好像我们去食堂打饭，并行就是我们在多个窗又排队，几个阿姨同时打菜；并发就是我们挤在一个窗又，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114143558.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902114143558"></p>
<h2 id="说说什么是进程和线程？"><a href="#说说什么是进程和线程？" class="headerlink" title="说说什么是进程和线程？"></a>说说什么是进程和线程？</h2><p>要说线程，必须得先说说进程。</p>
<ul>
<li>进程：进程是代码在数据集合上的一次运行活动，是<strong>系统进行资源分配和调度的基本单位</strong>。</li>
<li>线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</li>
</ul>
<p>操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。</p>
<p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p>
<p>一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140118921.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902140118921"></p>
<h2 id="说说线程有几种创建方式"><a href="#说说线程有几种创建方式" class="headerlink" title="说说线程有几种创建方式"></a>说说线程有几种创建方式</h2><p>Java中创建线程主要有三种方式，分别为继承<strong>Thread</strong>类、实现<strong>Runnable</strong>接口、实现<strong>Callable</strong>接口。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140459345.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902140459345"></p>
<ul>
<li><h3 id="继承Thread类，重写run-方法，调用start-方法启动线程"><a href="#继承Thread类，重写run-方法，调用start-方法启动线程" class="headerlink" title="继承Thread类，重写run()方法，调用start()方法启动线程"></a>继承Thread类，重写run()方法，调用start()方法启动线程</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    继承Thread类</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;This is child thread&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><h3 id="实现-Runnable-接口，重写run-方法"><a href="#实现-Runnable-接口，重写run-方法" class="headerlink" title="实现 Runnable 接口，重写run()方法"></a>实现 Runnable 接口，重写run()方法</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Runnable!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RunnableTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableTask</span>();<br>    	<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？</p>
<ul>
<li><h3 id="实现Callable接又，重写call-方法，这种方式可以通过FutureTask获取任务执行的返回值"><a href="#实现Callable接又，重写call-方法，这种方式可以通过FutureTask获取任务执行的返回值" class="headerlink" title="实现Callable接又，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值"></a>实现Callable接又，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值</h3></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    	<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,i am running!&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>                <span class="hljs-comment">//创建异步任务</span><br>                FutureTask&lt;String&gt; task=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallerTask</span>());<br>                <span class="hljs-comment">//启动线程</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//等待执行完成，并获取返回结果</span><br>                String result=task.get();<br>                System.out.println(result);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？"><a href="#为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？" class="headerlink" title="为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？"></a>为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？</h2><p>JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141434005.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902141434005"></p>
<p><strong>为什么我们不能直接调用run()方法？</strong> 也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。</p>
<h2 id="线程有哪些常用的调度方法？"><a href="#线程有哪些常用的调度方法？" class="headerlink" title="线程有哪些常用的调度方法？"></a>线程有哪些常用的调度方法？</h2><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141608203.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902141608203"></p>
<h3 id="线程等待与通知"><a href="#线程等待与通知" class="headerlink" title="线程等待与通知"></a>线程等待与通知</h3><p>在Object类中有一些函数可以用于线程的等待与通知。</p>
<ul>
<li><p>**wait()**：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：</p>
<ul>
<li><p>（ 1 ） 线程A调用了共享对象 notify()或者 notifyAll()方法；</p>
</li>
<li><p>（ 2 ）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</p>
</li>
</ul>
</li>
<li><p><strong>wait(long timeout)</strong> ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。</p>
</li>
<li><p>**wait(long timeout, int nanos)**，其内部调用的是 wait(long timout）函数。</p>
</li>
</ul>
<p>上面是线程等待的方法，而唤醒线程主要是下面两个方法：</p>
<ul>
<li><strong>notify()</strong> : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</li>
<li><strong>notifyAll()</strong> ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li>
</ul>
<p>Thread类也提供了一个方法用于等待的方法：</p>
<ul>
<li>**join()**：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。</li>
</ul>
<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul>
<li><strong>sleep(long millis)</strong> :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</li>
</ul>
<h3 id="让出优先权"><a href="#让出优先权" class="headerlink" title="让出优先权"></a>让出优先权</h3><ul>
<li><strong>yield()</strong> ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。</li>
</ul>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p>
<ul>
<li><strong>void interrupt()</strong> ：中断线程，例如，当线程A运行时，线程B可以调用钱程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。</li>
<li><strong>boolean isInterrupted() 方法</strong>： 检测当前线程是否被中断。</li>
<li><strong>boolean interrupted() 方法</strong>： 检测当前线程是否被中断，与 <strong>isInterrupted</strong> 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li>
</ul>
<h2 id="线程有几种状态？"><a href="#线程有几种状态？" class="headerlink" title="线程有几种状态？"></a>线程有几种状态？</h2><p>在Java中，线程共有六种状态：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902145605462.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902145605462"></p>
<p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160048587.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902160048587"></p>
<h2 id="什么是线程上下文切换？"><a href="#什么是线程上下文切换？" class="headerlink" title="什么是线程上下文切换？"></a>什么是线程上下文切换？</h2><p>使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。<img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160358011.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902160358011"></p>
<p>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160517970.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902160517970"></p>
<h2 id="守护线程了解吗？"><a href="#守护线程了解吗？" class="headerlink" title="守护线程了解吗？"></a>守护线程了解吗？</h2><ul>
<li>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。</li>
<li>在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。</li>
<li>那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。</li>
</ul>
<h2 id="线程间有哪些通信方式？"><a href="#线程间有哪些通信方式？" class="headerlink" title="线程间有哪些通信方式？"></a>线程间有哪些通信方式？</h2><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160908374.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902160908374"></p>
<h3 id="volatile和synchronized关键字"><a href="#volatile和synchronized关键字" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h3><ul>
<li><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p>
</li>
<li><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p>
</li>
</ul>
<h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a><strong>等待/通知机制</strong></h3><ul>
<li>可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</li>
</ul>
<h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a><strong>管道输入/输出流</strong></h3><ul>
<li><p><strong>管道输入/输出流</strong>和<strong>普通的文件输入/输出流</strong>或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p>
</li>
<li><p>管道输入/输出流主要包括了如下 4 种具体实现：<strong>PipedOutputStream、PipedInputStream、PipedReader和PipedWriter</strong>，前两种面向字节，而后两种面向字符。</p>
</li>
</ul>
<h3 id="使用Thread-join"><a href="#使用Thread-join" class="headerlink" title="使用Thread.join()"></a>使用Thread.join()</h3><ul>
<li>如果一个线程A执行了<strong>thread.join()**语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了</strong>join(long millis)<strong>和</strong>join(long millis,int nanos)**两个具备超时特性的方法。</li>
</ul>
<h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><ul>
<li><p><strong>ThreadLocal</strong>，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p>
</li>
<li><p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
</li>
</ul>
<h2 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul>
<li><p>两者最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</p>
</li>
<li><p>两者都可以<strong>暂停线程</strong>的执行。</p>
</li>
<li><p><strong>wait()</strong> 通常被用于线程间交互/通信，<strong>sleep()</strong> 通常被用于暂停执行。</p>
</li>
<li><p><strong>wait()</strong> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <strong>notify()</strong> 或者 <strong>notifyAll()</strong> 方法。<strong>sleep()</strong> 方法执行完成后，线程会自动苏醒。或者可以使用 <strong>wait(long timeout)</strong> 超时后线程会自动苏醒。</p>
</li>
</ul>
<h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用：</p>
<p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。<br>在多线程的情况下，<strong>程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>需要注意的是，如果执行的是 <strong>native</strong> 方法，那么程序计数器记录的是 <strong>undefined</strong> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，<strong>程序计数器私有主要是为了线程切换后能恢复到正确的执行位置</strong>。</p>
<h2 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h2><ul>
<li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个<strong>栈帧</strong>用于存储<strong>局部变量表、操作数栈、常量池</strong>引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是<strong>线程私有的</strong>。</p>
<h2 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2019-4%E6%AD%BB%E9%94%811.png" srcset="/weiblog/img/loading.gif" lazyload alt="线程死锁示意图 "></p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 2</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource1<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource2<br>Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource2<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource1<br></code></pre></td></tr></table></figure>

<p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p>
<p>上面的例子符合产生死锁的四个必要条件：</p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h3><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>如何避免死锁？</strong></p>
<p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p>
<blockquote>
<p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p>
</blockquote>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource1<br>Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource2<br>Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource2<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource1<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource2<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource2<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902163020732.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902163020732"></p>
<ul>
<li><p>创建</p>
<p>创建了一个<strong>ThreadLocal</strong>变量<strong>localVariable</strong>，任何一个线程都能并发访问<strong>localVariable</strong>。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个ThreadLocal变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure>

<ul>
<li><p>写入</p>
<p>线程可以在任何地方使用<strong>localVariable</strong>，写入变量。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">localVariable.set(<span class="hljs-string">&quot;鄙人三某”);</span><br></code></pre></td></tr></table></figure>

<ul>
<li>读取<br>线程在任何地方读取的都是它写入的变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">localVariable.get();<br></code></pre></td></tr></table></figure>

<h2 id="你在工作中用到过ThreadLocal吗？"><a href="#你在工作中用到过ThreadLocal吗？" class="headerlink" title="你在工作中用到过ThreadLocal吗？"></a>你在工作中用到过ThreadLocal吗？</h2><p>有用到过的，用来做用户信息上下文的存储。</p>
<p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接又，都会在请求头中携带</p>
<p>一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p>
<p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p>
<p>这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取ThreadLocal中存的用户数据。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902170811800.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902170811800"></p>
<p>很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。</p>
<p>我们常用的数据库连接池也用到了ThreadLocal：</p>
<ul>
<li>数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。</li>
</ul>
<h2 id="ThreadLocal怎么实现的呢？"><a href="#ThreadLocal怎么实现的呢？" class="headerlink" title="ThreadLocal怎么实现的呢？"></a>ThreadLocal怎么实现的呢？</h2><p>我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取ThreadLocalMap，然后把元素存到这个map中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//获取ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//讲当前元素存入map</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>    	map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    	createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ThreadLocal</strong>实现的秘密都在这个<strong>ThreadLocalMap</strong>了，Thread类中定义了一个类型为<strong>ThreadLocal.ThreadLocalMap</strong>的成员变量<strong>threadLocals</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">//ThreadLocal.ThreadLocalMap是Thread的属性</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ThreadLocalMap既然被称为Map，那么毫无疑问它是&lt;key,value&gt;型的数据结构。我们都知道map的本质是一个个&lt;key,value&gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br>    <span class="hljs-comment">//节点类</span><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-comment">//key赋值</span><br>        <span class="hljs-built_in">super</span>(k);<br>        <span class="hljs-comment">//value赋值</span><br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个 <strong>弱引用</strong> ，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">WeakReference</span><span class="hljs-params">(T referent)</span> &#123;<br>	<span class="hljs-built_in">super</span>(referent);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>key的赋值，使用的是WeakReference的赋值。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902173027266.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902173027266"></p>
<p>所以，怎么回答ThreadLocal原理？要答出这几个点：</p>
<ul>
<li>Thread类有一个类型为<strong>ThreadLocal.ThreadLocalMap</strong>的实例变量<strong>threadLocals</strong>，每个线程都有一个属于自己的<strong>ThreadLocalMap</strong>。</li>
<li><strong>ThreadLocalMap</strong>内部维护着Entry数组，每个Entry代表一个完整的对象，key是<strong>ThreadLocal的弱引用</strong>，value是<strong>ThreadLocal的泛型值</strong>。</li>
<li>每个线程在往<strong>ThreadLocal</strong>里设置值的时候，都是往自己的<strong>ThreadLocalMap</strong>里存，读也是以某个<strong>ThreadLocal</strong>作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li>
<li>ThreadLocal本身不存储值，它只是作为一个<strong>key</strong>来让线程往<strong>ThreadLocalMap</strong>里存取值。</li>
</ul>
<h2 id="ThreadLocal-内存泄露是怎么回事？"><a href="#ThreadLocal-内存泄露是怎么回事？" class="headerlink" title="ThreadLocal 内存泄露是怎么回事？"></a>ThreadLocal 内存泄露是怎么回事？</h2><p>我们先来分析一下使用<strong>ThreadLocal</strong>时的内存，我们都知道，在<strong>JVM</strong>中，<strong>栈内存线程私有</strong>，存储了对象的引用，<strong>堆内存线程共享</strong>，存储了对象实例。</p>
<p>所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902193325147.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902193325147"></p>
<p><strong>ThreadLocalMap</strong>中使用的 key 为 <strong>ThreadLocal</strong> 的弱引用。</p>
<p><em>“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”</em></p>
<p>那么现在问题就来了，弱引用很容易被回收，如果<strong>ThreadLocal（ThreadLocalMap的Key）</strong>被垃圾回收器回收了，但是<strong>ThreadLocalMap</strong>生命周期和<strong>Thread</strong>是一样的，它这时候如果不被回收，就会出现这种情况：<strong>ThreadLocalMap</strong>的<strong>key</strong>没了，<strong>value</strong>还在，这就会 <strong>造成了内存泄漏问题</strong> 。</p>
<h2 id="那怎么解决内存泄漏问题呢？"><a href="#那怎么解决内存泄漏问题呢？" class="headerlink" title="那怎么解决内存泄漏问题呢？"></a>那怎么解决内存泄漏问题呢？</h2><p>很简单，使用完<strong>ThreadLocal</strong>后，及时调用<strong>remove</strong>()方法释放内存空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>    	localVariable.set(<span class="hljs-string">&quot;鄙人三某”);</span><br><span class="hljs-string">    	......</span><br><span class="hljs-string">    &#125; finally &#123;</span><br><span class="hljs-string">    	localVariable.remove();</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>那为什么key还要设计成弱引用？</p>
<p>key设计成弱引用同样是为了防止内存泄漏。</p>
<p>假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。</p>
<h2 id="ThreadLocalMap的结构了解吗？"><a href="#ThreadLocalMap的结构了解吗？" class="headerlink" title="ThreadLocalMap的结构了解吗？"></a>ThreadLocalMap的结构了解吗？</h2><p>ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接又的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：<strong>元素数组和散列方法。</strong></p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902194739313.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902194739313"></p>
<p><strong>元素数组</strong></p>
<p>一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry[] table;<br></code></pre></td></tr></table></figure>

<p><strong>散列方法</strong></p>
<p>散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;运算（相当于取余）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span> );<br></code></pre></td></tr></table></figure>

<p>这里的<strong>threadLocalHashCode</strong>计算有点东西，每创建一个<strong>ThreadLocal</strong>对象，它就会新增<strong>0x61c88647</strong>，这个值很特殊，它是 <strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong> 。hash增量为 这个数字，带来的好处就是 hash <strong>分布非常均匀</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ThreadLocalMap怎么解决Hash冲突的？"><a href="#ThreadLocalMap怎么解决Hash冲突的？" class="headerlink" title="ThreadLocalMap怎么解决Hash冲突的？"></a>ThreadLocalMap怎么解决Hash冲突的？</h2><p>我们可能都知道<strong>HashMap</strong>使用了链表来解决冲突，也就是所谓的链地址法。</p>
<p><strong>ThreadLocalMap</strong>没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式—— <strong>开放定址法</strong> 。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902212750305.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902212750305"></p>
<p>如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。</p>
<p>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</p>
<h2 id="ThreadLocalMap扩容机制了解吗？"><a href="#ThreadLocalMap扩容机制了解吗？" class="headerlink" title="ThreadLocalMap扩容机制了解吗？"></a>ThreadLocalMap扩容机制了解吗？</h2><p>在<strong>ThreadLocalMap.set()**方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中</strong>Entry<strong>的数量已经达到了列表的扩容阈值</strong>(len*2/3)<strong>，就开始执行</strong>rehash()**逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>rehash();<br></code></pre></td></tr></table></figure>

<p>再着看<strong>rehash</strong>()具体实现：这里会先去清理过期的<strong>Entry</strong>，然后还要根据条件判断<strong>size &gt;=threshold - threshold / 4</strong> 也就是*<em>size &gt;= threshold</em> 3/4**来决定是否需要扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//清理过期Entry</span><br>        expungeStaleEntries();<br>        <span class="hljs-comment">//扩容</span><br>        <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span> )<br>        resize();<br>    &#125;<br>    <span class="hljs-comment">//清理过期Entry</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>        Entry[] tab = table;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)<br>        expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着看看具体的<strong>resize</strong>()方法，扩容后的<strong>newTab</strong>的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的newTab，遍历完成之后，<strong>oldTab</strong>中所有的<strong>entry</strong>数据都已经放入到<strong>newTab</strong>中了，然后table引用指向<strong>newTab</strong></p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213343066.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902213343066"></p>
<p>具体代码：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213432939.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220902213432939"></p>
<h2 id="父子线程怎么共享数据"><a href="#父子线程怎么共享数据" class="headerlink" title="父子线程怎么共享数据"></a>父子线程怎么共享数据</h2><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p>
<p>这时候可以用到另外一个类——<strong>InheritableThreadLocal</strong>。</p>
<p>使用起来很简单，在主线程的<strong>InheritableThreadLocal</strong>实例设置值，在子线程中就可以拿到了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">threadLocal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>();<br>            <span class="hljs-comment">// 主线程</span><br>            threadLocal.set(<span class="hljs-string">&quot;不擅技术&quot;</span>);<br>            <span class="hljs-comment">//子线程</span><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.run();<br>            System.out.println(<span class="hljs-string">&quot;鄙人三某 ，&quot;</span> + threadLocal.get());<br>            &#125;<br>        &#125;;<br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="那原理是什么呢？"><a href="#那原理是什么呢？" class="headerlink" title="那原理是什么呢？"></a>那原理是什么呢？</h4><p>原理很简单，在Thread类里还有另外一个变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>

<p>在<strong>Thread.init</strong>的时候，如果父线程的<strong>inheritableThreadLocals</strong>不为空，就把它赋给当前线程（子线程）的<strong>inheritableThreadLocals</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>)<br><span class="hljs-built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br></code></pre></td></tr></table></figure>

<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="说一下你对Java内存模型（JMM）的理解？"><a href="#说一下你对Java内存模型（JMM）的理解？" class="headerlink" title="说一下你对Java内存模型（JMM）的理解？"></a>说一下你对Java内存模型（JMM）的理解？</h2><p>Java内存模型（<strong>Java Memory Model</strong>，JMM），是一种<strong>抽象的模型</strong>，被定义出来屏蔽各种硬件和操作系统的<strong>内存访问差异</strong>。</p>
<p>JMM定义了<strong>线程和主内存</strong>之间的抽象关系：线程之间的<strong>共享变量</strong>存储在主内存（<strong>Main Memory</strong>）中，每个线程都有一个私有的本地内存（<strong>Local Memory</strong>），本地内存中存储了该线程<strong>以读/写共享变量的副本</strong>。</p>
<p>Java内存模型的抽象图：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114356751.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903114356751"></p>
<p>本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114449779.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903114449779"></p>
<p>图里面的是一个<strong>双核 CPU 系统架构</strong> ，每个核有自己的<strong>控制器和运算器</strong>，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的<strong>一级缓存</strong>，在有些架构里面还有一个<strong>所有 CPU 共享的二级缓存</strong>。 那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。</p>
<h2 id="说说你对原子性、可见性、有序性的理解"><a href="#说说你对原子性、可见性、有序性的理解" class="headerlink" title="说说你对原子性、可见性、有序性的理解"></a>说说你对原子性、可见性、有序性的理解</h2><p>原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。</p>
<ul>
<li><strong>原子性</strong>：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。</li>
<li><strong>可见性</strong>：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。</li>
<li><strong>有序性</strong>：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。</li>
</ul>
<h3 id="分析下面几行代码的原子性？"><a href="#分析下面几行代码的原子性？" class="headerlink" title="分析下面几行代码的原子性？"></a>分析下面几行代码的原子性？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>i++;<br>i = i + <span class="hljs-number">1</span> ;<br></code></pre></td></tr></table></figure>

<ul>
<li>第 1 句是基本类型赋值，是原子性操作。</li>
<li>第 2 句先读i的值，再赋值到j，两步操作，不能保证原子性。</li>
<li>第 3 和第 4 句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</li>
</ul>
<h3 id="原子性、可见性、有序性都应该怎么保证呢？"><a href="#原子性、可见性、有序性都应该怎么保证呢？" class="headerlink" title="原子性、可见性、有序性都应该怎么保证呢？"></a>原子性、可见性、有序性都应该怎么保证呢？</h3><ul>
<li><strong>原子性</strong>：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<strong>synchronized</strong> 。</li>
<li><strong>可见性</strong>：Java是利用<strong>volatile</strong> 关键字来保证可见性的，除此之外，<strong>final</strong> 和<strong>synchronized</strong> 也能保证可见性。</li>
<li><strong>有序性</strong>：<strong>synchronized</strong> 或者<strong>volatile</strong> 都可以保证多线程之间操作的有序性。</li>
</ul>
<h2 id="那说说什么是指令重排？"><a href="#那说说什么是指令重排？" class="headerlink" title="那说说什么是指令重排？"></a>那说说什么是指令重排？</h2><p>在执行程序时，为了提高性能，<strong>编译器和处理器</strong>常常会对指令做重排序。重排序分 3 种类型。</p>
<ol>
<li><p><strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li><p><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</p>
</li>
<li><p><strong>内存系统的重排序</strong>。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p>
</li>
</ol>
<p>从Java源代码到最终实际执行的指令序列，会分别经历下面 3 种重排序，如图：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903115952545.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903115952545"></p>
<p>我们比较熟悉的<strong>双重校验单例模式</strong>就是一个经典的指令重排的例子，<strong>Singleton instance=new Singleton()；</strong>对应的JVM指令分为三步：<strong>分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间</strong>，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133213700.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903133213700"></p>
<p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p>
<h2 id="指令重排有限制吗？happens-before了解吗？"><a href="#指令重排有限制吗？happens-before了解吗？" class="headerlink" title="指令重排有限制吗？happens-before了解吗？"></a>指令重排有限制吗？happens-before了解吗？</h2><p>指令重排也是有一些限制的，有两个规则<strong>happens-before和as-if-serial</strong>来约束。</p>
<p><strong>happens-before</strong>的定义：</p>
<ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ul>
<p>happens-before和我们息息相关的有<strong>六大规则</strong>：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133644636.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903133644636"></p>
<ul>
<li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ul>
<h2 id="as-if-serial又是什么？单线程的程序一定是顺序的吗"><a href="#as-if-serial又是什么？单线程的程序一定是顺序的吗" class="headerlink" title="as-if-serial又是什么？单线程的程序一定是顺序的吗"></a>as-if-serial又是什么？单线程的程序一定是顺序的吗</h2><p>as-if-serial语义的意思是：<strong>不管怎么重排序（编译器和处理器为了提高并行度）</strong>， <strong>单线程程序的执行结果不能被改变</strong> 。编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>; <span class="hljs-comment">// A</span><br><span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>; <span class="hljs-comment">// B</span><br><span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> pi * r * r; <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure>

<p>上面 3 个操作的数据依赖关系：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134841710.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903134841710"></p>
<p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。所以最终，程序可能会有两种执行顺序：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134956909.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903134956909"></p>
<p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。</p>
<h2 id="volatile实现原理了解吗？"><a href="#volatile实现原理了解吗？" class="headerlink" title="volatile实现原理了解吗？"></a>volatile实现原理了解吗？</h2><p>volatile有两个作用，保证 <strong>可见性</strong> 和 <strong>有序性</strong> 。</p>
<h3 id="volatile怎么保证可见性的呢？"><a href="#volatile怎么保证可见性的呢？" class="headerlink" title="volatile怎么保证可见性的呢？"></a>volatile怎么保证可见性的呢？</h3><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p>
<p>volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p>
<p>例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903135524735.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903135524735"></p>
<h3 id="volatile怎么保证有序性的呢？"><a href="#volatile怎么保证有序性的呢？" class="headerlink" title="volatile怎么保证有序性的呢？"></a>volatile怎么保证有序性的呢？</h3><p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140353177.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903140353177"></p>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p><strong>1.</strong> 在每个volatile写操作的前面插入一个StoreStore 屏障<br><strong>2.</strong> 在每个volatile写操作的后面插入一个StoreLoad 屏障<br><strong>3.</strong> 在每个volatile读操作的后面插入一个LoadLoad 屏障<br><strong>4.</strong> 在每个volatile读操作的后面插入一个LoadStore 屏障</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140503354.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903140503354"></p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140518029.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903140518029"></p>
<h3 id="双重校验锁实现对象单例（线程安全）"><a href="#双重校验锁实现对象单例（线程安全）" class="headerlink" title="双重校验锁实现对象单例（线程安全）"></a>双重校验锁实现对象单例（线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="synchronized用过吗？怎么使用？"><a href="#synchronized用过吗？怎么使用？" class="headerlink" title="synchronized用过吗？怎么使用？"></a>synchronized用过吗？怎么使用？</h2><p>synchronized经常用的，用来保证代码的原子性。</p>
<p>synchronized主要有三种用法：</p>
<ul>
<li><strong>修饰实例方法</strong>: 作用于当前<strong>对象实例</strong>加锁，进入同步代码前要获得 当前对象实例的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>修饰静态方法</strong> ：也就是给<strong>当前类加锁</strong>，会作用于类的所有对象实例 ，进入同步代码前要获得当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> staic <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>修饰代码块</strong> ：<strong>指定加锁对象，对给定对象/类加锁</strong>。 <strong>synchronized(this|object)</strong> 表示进入同步代码库前要获得给定对象的锁。 <strong>synchronized(类.class)</strong> 表示进入同步代码前要获得 当前<strong>class</strong> 的锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="synchronized的实现原理？"><a href="#synchronized的实现原理？" class="headerlink" title="synchronized的实现原理？"></a>synchronized的实现原理？</h2><h3 id="synchronized是怎么加锁的呢？"><a href="#synchronized是怎么加锁的呢？" class="headerlink" title="synchronized是怎么加锁的呢？"></a>synchronized是怎么加锁的呢？</h3><p>我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。</p>
<p><strong>1.</strong> <strong>synchronized修饰代码块时</strong>，JVM采用<strong>monitorenter、monitorexit</strong>两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。反编译一段synchronized修饰代码块代码，<strong>javap -c -s -v -l</strong><br><strong>SynchronizedDemo.class</strong>，可以看到相应的字节码指令。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903180902786.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903180902786"></p>
<p><strong>2.</strong> <strong>synchronized修饰同步方法时</strong>，JVM采用ACC_SYNCHRONIZED标记符来实现同步，这个标识指明了该方法是一个同步方法。<br>同样可以写段代码反编译看一下。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903181654514.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903181654514"></p>
<h3 id="synchronized锁住的是什么呢？"><a href="#synchronized锁住的是什么呢？" class="headerlink" title="synchronized锁住的是什么呢？"></a>synchronized锁住的是什么呢？</h3><p>monitorenter、monitorexit或者ACC_SYNCHRONIZED都是 <strong>基于Monitor实现</strong> 的。</p>
<p>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了<strong>monitor</strong> 。</p>
<p>所谓的Monitor其实是一种 <strong>同步工具</strong> ，也可以说是一种 <strong>同步机制</strong> 。在Java虚拟机（HotSpot）中，Monitor是由 <strong>ObjectMonitor实现</strong> 的，可以叫做内部锁，或者Monitor锁。</p>
<p>ObjectMonitor的工作原理：</p>
<ul>
<li>ObjectMonitor有两个队列：WaitSet、EntryList，用来保存ObjectWaiter 对象列表。</li>
<li>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait()方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入WaitSet 中，等待被唤醒。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMonitor() &#123;<br>_header = NULL;<br>_count = <span class="hljs-number">0</span> ; <span class="hljs-comment">// 记录线程获取锁的次数</span><br>_waiters = <span class="hljs-number">0</span> ,<br>_recursions = <span class="hljs-number">0</span> ; <span class="hljs-comment">//锁的重入次数</span><br>_object = NULL;<br>_owner = NULL; <span class="hljs-comment">// 指向持有ObjectMonitor对象的线程</span><br>_WaitSet = NULL; <span class="hljs-comment">// 处于wait状态的线程，会被加入到_WaitSet</span><br>_WaitSetLock = <span class="hljs-number">0</span> ;<br>_Responsible = NULL ;<br>_succ = NULL ;<br>_cxq = NULL ;<br>FreeNext = NULL ;<br>_EntryList = NULL ; <span class="hljs-comment">// 处于等待锁block状态的线程，会被加入到该列表</span><br>_SpinFreq = <span class="hljs-number">0</span> ;<br>_SpinClock = <span class="hljs-number">0</span> ;<br>OwnerIsThread = <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure>

<p>可以类比一个去医院就诊的例子[18]：</p>
<ul>
<li><p>首先，患者在 门诊大厅 前台或自助挂号机 进行挂号 ；</p>
</li>
<li><p>随后，挂号结束后患者找到对应的 诊室就诊 ：</p>
<ul>
<li>诊室每次只能有一个患者就诊；</li>
<li>如果此时诊室空闲，直接进入就诊；</li>
<li>如果此时诊室内有其它患者就诊，那么当前患者进入候诊室，等待叫号；</li>
</ul>
</li>
<li><p>就诊结束后， 走出就诊室 ，候诊室的 下一位候诊患者 进入就诊室。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190305715.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903190305715"></p>
</li>
</ul>
<p>这个过程就和<strong>Monitor机制</strong>比较相似：</p>
<ul>
<li>门诊大厅：所有待进入的线程都必须先在入口Entry Set挂号才有资格；</li>
<li>就诊室：就诊室_Owner里里只能有一个线程就诊，就诊完线程就自行离开</li>
<li>候诊室：就诊室繁忙时，进入等待区（Wait Set），就诊室空闲的时候就从等待区（Wait Set）叫新的线程</li>
</ul>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190457240.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903190457240"></p>
<p>所以我们就知道了，同步是锁住的什么东西：</p>
<ul>
<li><strong>monitorenter</strong>，在判断拥有同步标识 <strong>ACC_SYNCHRONIZED</strong> 抢先进入此方法的线程会优先拥有 <strong>Monitor</strong> 的 <strong>owner</strong> ，此时计数器 +1。</li>
<li><strong>monitorexit</strong>，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</li>
</ul>
<h2 id="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"><a href="#除了原子性，synchronized可见性，有序性，可重入性怎么实现？" class="headerlink" title="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"></a>除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h2><h4 id="synchronized怎么保证可见性？"><a href="#synchronized怎么保证可见性？" class="headerlink" title="synchronized怎么保证可见性？"></a>synchronized怎么保证可见性？</h4><ul>
<li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li>
<li>线程加锁后，其它线程无法获取主内存中的共享变量。</li>
<li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li>
</ul>
<h4 id="synchronized怎么保证有序性？"><a href="#synchronized怎么保证有序性？" class="headerlink" title="synchronized怎么保证有序性？"></a>synchronized怎么保证有序性？</h4><ul>
<li>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。</li>
<li>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</li>
<li>所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。</li>
</ul>
<h4 id="synchronized怎么实现可重入的呢？"><a href="#synchronized怎么实现可重入的呢？" class="headerlink" title="synchronized怎么实现可重入的呢？"></a>synchronized怎么实现可重入的呢？</h4><ul>
<li>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。</li>
<li>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码、块之后，计数器就会-1，直到计数器清零，就释放锁了。</li>
<li>之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</li>
</ul>
<h2 id="锁升级？synchronized优化了解吗？"><a href="#锁升级？synchronized优化了解吗？" class="headerlink" title="锁升级？synchronized优化了解吗？"></a>锁升级？synchronized优化了解吗？</h2><p>了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？</p>
<p>Java对象头里，有一块结构，叫<strong>Mark Word</strong>标记字段，这块结构会随着锁的状态变化而变化。64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903215849935.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903215849935"></p>
<p>Mark Word存储对象自身的运行数据，如<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）</strong> 等。</p>
<h4 id="synchronized做了哪些优化？"><a href="#synchronized做了哪些优化？" class="headerlink" title="synchronized做了哪些优化？"></a>synchronized做了哪些优化？</h4><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong> 。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。</p>
<ul>
<li><strong>偏向锁</strong>：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</li>
<li><strong>轻量级锁</strong>：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。</li>
<li><strong>自旋锁</strong>：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</li>
<li><strong>锁粗化</strong>：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li>
<li><strong>锁消除</strong>：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</li>
</ul>
<h4 id="锁升级的过程是什么样的？"><a href="#锁升级的过程是什么样的？" class="headerlink" title="锁升级的过程是什么样的？"></a>锁升级的过程是什么样的？</h4><p>锁升级方向：无锁–&gt;偏向锁—&gt; 轻量级锁—-&gt;重量级锁，这个方向基本上是不可逆的。</p>
<p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903221140669.png" srcset="/weiblog/img/loading.gif" lazyload alt="image-20220903221140669"></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试-Java并发编程</div>
      <div>https://weishao996.gitee.io/weiblog/2022/09/02/面试-Java并发编程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Wei Shao</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年9月2日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/weiblog/2022/08/31/%E9%9D%A2%E8%AF%95-Mybatis/" title="面试-Mybatis">
                        <span class="hidden-mobile">面试-Mybatis</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/weiblog/js/events.js" ></script>
<script  src="/weiblog/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/weiblog/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/weiblog/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/weiblog/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
