<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试-Mysql</title>
    <link href="/weiblog/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL/"/>
    <url>/weiblog/2022/09/08/%E9%9D%A2%E8%AF%95-MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a><strong>基础</strong></h1><h2 id="什么是内连接、外连接、交叉连接、笛卡尔积呢"><a href="#什么是内连接、外连接、交叉连接、笛卡尔积呢" class="headerlink" title="什么是内连接、外连接、交叉连接、笛卡尔积呢"></a>什么是内连接、外连接、交叉连接、笛卡尔积呢</h2><ul><li><strong>内连接（inner join）</strong>：取得两张表中满足存在连接匹配关系的记录。</li><li><strong>外连接（outer join）</strong>：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。</li><li><strong>交叉连接（cross join）</strong>：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么A和B交叉连接的结果就有m*n行。</li><li><strong>笛卡尔积</strong>：是数学中的一个概念，例如集合A={a,b}，集合B={1,2,3}，那么A✖B={&lt;a,o&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;,}。</li></ul><h2 id="那MySQL-的内连接、左连接、右连接有有什么区别？"><a href="#那MySQL-的内连接、左连接、右连接有有什么区别？" class="headerlink" title="那MySQL 的内连接、左连接、右连接有有什么区别？"></a>那MySQL 的内连接、左连接、右连接有有什么区别？</h2><p>MySQL的连接主要分为内连接和外连接，外连接常用的有左连接、右连接。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908105510788.png" alt="image-20220908105510788"></p><ul><li><strong>inner join</strong> 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li><li><strong>left join</strong> 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li><li><strong>right join</strong> 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li></ul><h2 id="说一下数据库的三大范式？"><a href="#说一下数据库的三大范式？" class="headerlink" title="说一下数据库的三大范式？"></a>说一下数据库的三大范式？</h2><ul><li><strong>第一范式</strong>：数据表中的每一列（每个字段）都不可以再拆分。例如用户表，用户地址还可以拆分成国家、省份、市，这样才是符合第一范式的。</li><li><strong>第二范式</strong>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品ID和订单ID作为联合主键，才满足第二范式。</li><li><strong>第三范式</strong>：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。例如订单表，就不能存储用户信息（姓名、地址）。</li></ul><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908110113813.png" alt="image-20220908110113813"></p><p>三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。</p><h2 id="varchar与char的区别？"><a href="#varchar与char的区别？" class="headerlink" title="varchar与char的区别？"></a>varchar与char的区别？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908110707043.png" alt="image-20220908110707043"></p><p><strong>char</strong> ：</p><ul><li>char表示定长字符串，长度是固定的；</li><li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li><li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，</li><li>所以会占据多余的空间，是空间换时间的做法；</li><li>对于char来说，最多能存放的字符个数为 255 ，和编码无关</li></ul><p><strong>varchar</strong> ：</p><ul><li>varchar表示可变长字符串，长度是可变的；</li><li>插入的数据是多长，就按照多长来存储；</li><li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li><li>对于varchar来说，最多能存放的字符个数为 65532</li></ul><p>日常的设计，对于长度相对固定的字符串，可以使用char，对于长度不确定的，使用varchar更合适一些。</p><h2 id="blob和text有什么区别？"><a href="#blob和text有什么区别？" class="headerlink" title="blob和text有什么区别？"></a>blob和text有什么区别？</h2><ul><li>blob用于存储二进制数据，而text用于存储大字符串。</li><li>blob没有字符集，text有一个字符集，并且根据字符集的校对规则对值进行排序和比较</li></ul><h2 id="DATETIME和TIMESTAMP的异同？"><a href="#DATETIME和TIMESTAMP的异同？" class="headerlink" title="DATETIME和TIMESTAMP的异同？"></a>DATETIME和TIMESTAMP的异同？</h2><p>相同点 ：</p><ul><li><ol><li>两个数据类型存储时间的表现格式一致。均为 YYYY-MM-DD HH:MM:SS</li></ol></li><li><ol start="2"><li>两个数据类型都包含「日期」和「时间」部分。</li></ol></li><li><ol start="3"><li>两个数据类型都可以存储微秒的小数秒（秒后 6 位小数秒）</li></ol></li></ul><p>区别 ：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908111247064.png" alt="image-20220908111247064"></p><ul><li><ol><li>日期范围：DATETIME 的日期范围是 1000-01-01 00:00:00.000000 到 9999-12-31 23:59:59.999999 ；TIMESTAMP 的时间范围是1970-01-01 00:00:01.000000 UTC到 ``2038-01-09 03:14:07.999999 UTC</li></ol></li><li><ol start="2"><li>存储空间：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节</li></ol></li><li><ol start="3"><li>时区相关：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区</li></ol></li><li><ol start="4"><li>默认值：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)</li></ol></li></ul><h2 id="MySQL中-in-和-exists-的区别？"><a href="#MySQL中-in-和-exists-的区别？" class="headerlink" title="MySQL中 in 和 exists 的区别？"></a>MySQL中 in 和 exists 的区别？</h2><p>MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。我们可能认为exists比in语句的效率要高，这种说法其实是不准确的，要区分情景：</p><ul><li><strong>1.</strong> 如果查询的两个表大小相当，那么用in和exists差别不大。</li><li><strong>2.</strong> 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li><li><strong>3.</strong> not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li></ul><h2 id="MySQL里记录货币用什么字段类型比较好？"><a href="#MySQL里记录货币用什么字段类型比较好？" class="headerlink" title="MySQL里记录货币用什么字段类型比较好？"></a>MySQL里记录货币用什么字段类型比较好？</h2><p>货币在数据库中MySQL常用<strong>Decimal</strong>和<strong>Numric</strong>类型表示，这两种类型被MySQL实现为同样的类型。他们被用于保存与货币有关的数据。</p><p>例如salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在salary列中的值的范围是从-9999999.99到9999999.99。</p><p><strong>DECIMAL</strong>和<strong>NUMERIC</strong>值作为<strong>字符串存储</strong>，而不是作为二进制浮点数，以便保存那些值的小数精度。</p><p>之所以不使用float或者double的原因：因为float和double是以二进制存储的，所以<strong>有一定的误差</strong>。</p><h2 id="MySQL怎么存储emoji"><a href="#MySQL怎么存储emoji" class="headerlink" title="MySQL怎么存储emoji $?"></a>MySQL怎么存储emoji $?</h2><p>MySQL可以直接使用字符串存储emoji。</p><p>但是需要注意的，utf8 编码是不行的，MySQL中的utf8是阉割版的 utf8，它最多只用 3 个字节存储字符，所以存储不了表情。那该怎么办？</p><p>需要使用utf8mb4编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">alter table blogs modify content text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci not <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><h2 id="drop、delete与truncate的区别？"><a href="#drop、delete与truncate的区别？" class="headerlink" title="drop、delete与truncate的区别？"></a>drop、delete与truncate的区别？</h2><p>三者都表示删除，但是三者有一些差别：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908112356710.png" alt="image-20220908112356710"></p><p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p><h2 id="UNION与UNION-ALL的区别？"><a href="#UNION与UNION-ALL的区别？" class="headerlink" title="UNION与UNION ALL的区别？"></a>UNION与UNION ALL的区别？</h2><ul><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 高于 UNION ALL</li></ul><h2 id="count-1-、count-与-count-列名-的区别？"><a href="#count-1-、count-与-count-列名-的区别？" class="headerlink" title="count(1)、count(*) 与 count(列名) 的区别？"></a>count(1)、count(*) 与 count(列名) 的区别？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908113932735.png" alt="image-20220908113932735"></p><p><strong>执行效果 ：</strong></p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li><li>count(1)包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略列值为NULL</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者 0 ，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><p><strong>执行速度</strong> ：</p><ul><li>列名为主键，count(列名)会比count(1)快</li><li>列名不为主键，count(1)会比count(列名)快</li><li>如果表多个列并且没有主键，则 count（ 1 ） 的执行效率优于 count（*）</li><li>如果有主键，则 select count（主键）的执行效率是最优的</li><li>如果表只有一个字段，则 select count（*）最优。</li></ul><h2 id="一条SQL查询语句的执行顺序？"><a href="#一条SQL查询语句的执行顺序？" class="headerlink" title="一条SQL查询语句的执行顺序？"></a>一条SQL查询语句的执行顺序？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908114246845.png" alt="image-20220908114246845"></p><p><strong>1.</strong> <strong>FROM</strong>：对FROM子句中的左表<left_table>和右表<right_table>执行笛卡儿积（Cartesianproduct），产生虚拟表VT1</p><p><strong>2.</strong> <strong>ON</strong>：对虚拟表VT1应用ON筛选，只有那些符合<join_condition>的行才被插入虚拟表VT2中</p><p><strong>3.</strong> <strong>JOIN</strong>：如果指定了OUTER JOIN（如LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤 1 ）～步骤3 ），直到处理完所有的表为止</p><p><strong>4.</strong> <strong>WHERE</strong>：对虚拟表VT3应用WHERE过滤条件，只有符合<where_condition>的记录才被插入虚拟表VT4中</p><p><strong>5.</strong> <strong>GROUP BY</strong>：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5</p><p><strong>6.</strong> <strong>CUBE|ROLLUP</strong>：对表VT5进行CUBE或ROLLUP操作，产生表VT6</p><p><strong>7.</strong> <strong>HAVING</strong>：对虚拟表VT6应用HAVING过滤器，只有符合<having_condition>的记录才被插入虚拟表VT7中。</p><p><strong>8.</strong> <strong>SELECT</strong>：第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中</p><p><strong>9. DISTINCT</strong>：去除重复数据，产生虚拟表VT9</p><p><strong>10.</strong> <strong>ORDER BY</strong>：将虚拟表VT9中的记录按照<order_by_list>进行排序操作，产生虚拟表VT10。 11 ）</p><p><strong>11.</strong> <strong>LIMIT</strong>：取出指定行的记录，产生虚拟表VT11，并返回给查询用户</p><h1 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a><strong>基础架构</strong></h1><h2 id="MySQL-基本架构概览"><a href="#MySQL-基本架构概览" class="headerlink" title="MySQL 基本架构概览"></a>MySQL 基本架构概览</h2><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908160140480.png" alt="image-20220908160140480"></p><p>从上图可以看出， <strong>MySQL 主要由下面几部分构成</strong>：</p><ul><li><p><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</p></li><li><p><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</p></li><li><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p></li><li><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p></li><li><p><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p></li><li><p><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</p></li></ul><p>简单来说 MySQL 主要分为 <strong>Server 层</strong>和<strong>存储引擎</strong>层：</p><ul><li><p><strong>Server 层</strong>：主要包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。</p></li><li><p><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 <strong>InnoDB、MyISAM、Memory</strong> 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</p></li></ul><h2 id="Server-层基本组件介绍"><a href="#Server-层基本组件介绍" class="headerlink" title="Server 层基本组件介绍"></a>Server 层基本组件介绍</h2><h3 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h3><p>连接器主要和<strong>身份认证和权限</strong>相关的功能相关，就好比一个级别很高的门卫一样。</p><p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p><h3 id="查询缓存-MySQL-8-0-版本后移除"><a href="#查询缓存-MySQL-8-0-版本后移除" class="headerlink" title="查询缓存(MySQL 8.0 版本后移除)"></a>查询缓存(MySQL 8.0 版本后移除)</h3><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p><p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p><p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p><p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p><p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p><h3 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h3><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p><p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p><p><strong>第二步，语法分析</strong>，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</p><p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>优化器的作用就是它认为的最优的<strong>执行方案</strong>去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p><p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p><h2 id="一条-SQL-语句是如何执行"><a href="#一条-SQL-语句是如何执行" class="headerlink" title="一条 SQL 语句是如何执行"></a>一条 SQL 语句是如何执行</h2><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_student A <span class="hljs-keyword">where</span> A.age<span class="hljs-operator">=</span><span class="hljs-string">&#x27;18&#x27;</span> <span class="hljs-keyword">and</span> A.name<span class="hljs-operator">=</span><span class="hljs-string">&#x27; 张三 &#x27;</span>;<br></code></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p><ul><li><p>先检查该语句<strong>是否有权限</strong>，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先<strong>查询缓存</strong>，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p></li><li><p>通过分析器进行<strong>词法分析</strong>，<strong>提取 SQL 语句的关键元素</strong>，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=’1’。然后<strong>判断这个 SQL 语句是否有语法错误</strong>，比如关键词是否正确等等，如果检查没问题就执行下一步。</p></li><li><p>接下来就是<strong>优化器进行确定执行方案</strong>，上面的 SQL 语句，可以有两种执行方案：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 <span class="hljs-number">18</span>。<br>b.先找出学生中年龄 <span class="hljs-number">18</span> 岁的学生，然后再查询姓名为“张三”的学生。<br></code></pre></td></tr></table></figure><ul><li><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p></li><li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p></li></ul><h3 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h3><p>以上就是一条查询 SQL 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？SQL 语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> tb_student A <span class="hljs-keyword">set</span> A.age<span class="hljs-operator">=</span><span class="hljs-string">&#x27;19&#x27;</span> <span class="hljs-keyword">where</span> A.name<span class="hljs-operator">=</span><span class="hljs-string">&#x27; 张三 &#x27;</span>;<br></code></pre></td></tr></table></figure><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p><ul><li><p>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</p></li><li><p>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</p></li><li><p>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</p></li><li><p>更新完成。</p></li></ul><p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p><p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 <strong>redo log 是 InnoDB 引擎特有的</strong>，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，<strong>binlog 日志只能用来归档</strong>。</p><p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p><ul><li><p><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p></li><li><p><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</p></li></ul><p>如果采用 <strong>redo log 两阶段提交</strong>的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p><ul><li><p>判断 redo log 是否完整，如果判断是完整的，就立即提交。</p></li><li><p>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</p></li></ul><p>这样就解决了数据一致性的问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>MySQL 主要分为 <strong>Server 层和引擎层</strong>，Server 层主要包括<strong>连接器、查询缓存、分析器、优化器、执行器</strong>，同时还有一个日志模块（<strong>binlog</strong>），这个日志模块所有执行引擎都可以共用，<strong>redolog 只有 InnoDB 有</strong>。</p></li><li><p>引擎层是插件式的，目前主要包括，<strong>MyISAM,InnoDB,Memory</strong> 等。</p></li><li><p>查询语句的执行流程如下：<strong>权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</strong></p></li><li><p>更新语句执行流程如下：<strong>分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</strong></p></li></ul><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a><strong>存储引擎</strong></h1><h2 id="MySQL-支持哪些存储引擎？默认使用哪个？"><a href="#MySQL-支持哪些存储引擎？默认使用哪个？" class="headerlink" title="MySQL 支持哪些存储引擎？默认使用哪个？"></a>MySQL 支持哪些存储引擎？默认使用哪个？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908172148275.png" alt="image-20220908172148275"></p><p>主要存储引擎以及功能如下：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908172213800.png" alt="image-20220908172213800"></p><p>MySQL5.5之前，默认存储引擎是MylSAM，5.5之后变成了InnoDB。</p><p>InnoDB支持的<strong>哈希索引</strong>是自适应的，InnoDB会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。</p><p>MySQL 5.6开始InnoDB支持全文索引。</p><h2 id="那存储引擎应该怎么选择？"><a href="#那存储引擎应该怎么选择？" class="headerlink" title="那存储引擎应该怎么选择？"></a>那存储引擎应该怎么选择？</h2><p>大致上可以这么选择：</p><ul><li>大多数情况下，使用默认的InnoDB就够了。如果要提供<strong>提交、回滚和恢复的事务安全（ACID 兼容）</strong>能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。</li><li>如果数据表主要用来<strong>插入和查询记录</strong>，则 <strong>MyISAM</strong> 引擎提供较高的处理效率。</li><li>如果只是<strong>临时存放数据</strong>，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 <strong>MEMORY</strong> 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。</li></ul><p>使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。</p><h2 id="InnoDB和MylSAM主要有什么区别？"><a href="#InnoDB和MylSAM主要有什么区别？" class="headerlink" title="InnoDB和MylSAM主要有什么区别？"></a>InnoDB和MylSAM主要有什么区别？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908174526568.png" alt="image-20220908174526568"></p><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p><p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html">MySQL 事务隔离级别详解open in new window</a>。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p><p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/E2S3AbqgaMevqcRf65-GykDq98ATjfCSA4IUeqk_7ME.pngtoken=W.LuJhepAXj28rmGMNzUwb-qHCaAjyOTpGOs7ceh3hGLgsV77WbxbKZOsY-xRYhbs" alt="error"></p><p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p><p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <strong>redo log</strong> 。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>6.索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 <strong>B+Tree</strong> 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a><strong>日志</strong></h1><h2 id="MySQL日志文件有哪些？分别介绍下作用？"><a href="#MySQL日志文件有哪些？分别介绍下作用？" class="headerlink" title="MySQL日志文件有哪些？分别介绍下作用？"></a>MySQL日志文件有哪些？分别介绍下作用？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908215650562.png" alt="image-20220908215650562"></p><p>MySQL日志文件有很多，包括 ：</p><ul><li><strong>错误日志（error log）</strong>：错误日志文件对MySQL的启动、运行、关闭过程进行了记录，能帮助定位MySQL问题。</li><li><strong>慢查询日志（slow query log）</strong>：慢查询日志是用来记录执行时间超过 <strong>long_query_time</strong> 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。</li><li><strong>一般查询日志（general log）</strong>：一般查询日志记录了所有对MySQL数据库请求的信息，无论请求是否正确执行。</li><li><strong>二进制日志（bin log）</strong>：关于二进制日志，它记录了数据库所有执行的DDL和DML语句（除了数据查询语句select、show等），以事件形式记录并保存在二进制文件中。</li></ul><p>还有两个<strong>InnoDB</strong>存储引擎特有的日志文件：</p><ul><li><strong>重做日志（redo log）</strong>：重做日志至关重要，因为它们记录了对于InnoDB存储引擎的事务日志。</li><li><strong>回滚日志（undo log）</strong>：回滚日志同样也是InnoDB引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB引擎不仅会记录redolog，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。</li></ul><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>redo log（重做日志）是InnoDB存储引擎独有的，它让MySQL拥有了崩溃恢复能力。</p><p>比如 MySQL 实例挂了或宕机了，重启时，InnoDB存储引擎会使用redo log恢复数据，保证数据的持久性与完整性。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908180104830.png" alt="image-20220908180104830"></p><p><strong>MySQL</strong> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <strong>Buffer Pool</strong> 中。</p><p>后续的查询都是先从 <strong>Buffer Pool</strong> 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。</p><p>更新表数据的时候，也是如此，发现 <strong>Buffer Pool</strong> 里存在要更新的数据，就直接在 <strong>Buffer Pool</strong> 里更新。</p><p>然后会把“<strong>在某个数据页上做了什么修改</strong>”记录到<strong>重做日志缓存（redo log buffer）</strong>里，接着刷盘到 <strong>redo log</strong> 文件里。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908180909891.png" alt="image-20220908180909891"></p><p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p><p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p><h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p>InnoDB 存储引擎为 redo log 的刷盘策略提供了 <strong>innodb_flush_log_at_trx_commit</strong> 参数，它支持三种策略：</p><ul><li><p><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</p></li><li><p><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</p></li><li><p><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</p></li></ul><p><strong>innodb_flush_log_at_trx_commit</strong> 参数默认为 1 ，也就是说当事务提交时会<strong>调用 fsync 对 redo log 进行刷盘</strong></p><p>另外，InnoDB 存储引擎有一个<strong>后台线程</strong>，每隔1 秒，就会把 redo log buffer 中的内容写到<strong>文件系统缓存（page cache）</strong>，然后调用 <strong>fsync</strong> 刷盘。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908181309250.png" alt="image-20220908181309250"></p><p>也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘。</p><p>因为在事务执行过程 redo log 记录是会写入redo log buffer 中，这些 redo log 记录会被后台线程刷盘。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908181359838.png" alt="image-20220908181359838"></p><p>除了后台线程每秒1次的轮询操作，还有一种情况，当 redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动刷盘。</p><p>下面是不同刷盘策略的流程图。</p><h5 id="innodb-flush-log-at-trx-commit-0"><a href="#innodb-flush-log-at-trx-commit-0" class="headerlink" title="innodb_flush_log_at_trx_commit=0"></a>innodb_flush_log_at_trx_commit=0</h5><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908181455376.png" alt="image-20220908181455376"></p><p>为0时，如果MySQL挂了或宕机可能会有1秒数据的丢失。</p><h5 id="innodb-flush-log-at-trx-commit-1"><a href="#innodb-flush-log-at-trx-commit-1" class="headerlink" title="innodb_flush_log_at_trx_commit=1"></a>innodb_flush_log_at_trx_commit=1</h5><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908181543540.png" alt="image-20220908181543540"></p><p>为1时， 只要事务提交成功，redo log记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间MySQL挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p><h5 id="innodb-flush-log-at-trx-commit-2"><a href="#innodb-flush-log-at-trx-commit-2" class="headerlink" title="innodb_flush_log_at_trx_commit=2"></a>innodb_flush_log_at_trx_commit=2</h5><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908181632240.png" alt="image-20220908181632240"></p><p>如果仅仅只是MySQL挂了不会有任何数据丢失，但是宕机可能会有1秒数据的丢失。</p><h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p>硬盘上存储的 redo log 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的redo日志文件大小都是一样的。</p><p>比如可以配置为一组4个文件，每个文件的大小是 1GB，整个 redo log 日志文件组可以记录4G的内容。</p><p>它采用的是<strong>环形数组</strong>形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908182238317.png" alt="image-20220908182238317"></p><p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <strong>write pos、checkpoint</strong></p><ul><li><p><strong>write pos</strong> 是当前记录的位置，一边写一边后移</p></li><li><p><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</p></li></ul><p>每次刷盘 redo log 记录到<strong>日志文件组</strong>中，write pos 位置就会后移更新。</p><p>每次 MySQL 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 redo log 记录，并把 checkpoint 后移更新。</p><p>write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908182729899.png" alt="image-20220908182729899"></p><p>如果 write pos 追上 checkpoint ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 checkpoint 推进一下。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908182834045.png" alt="image-20220908182834045"></p><h3 id="redo-log-小结"><a href="#redo-log-小结" class="headerlink" title="redo log 小结"></a>redo log 小结</h3><p>相信大家都知道 redo log 的作用和它的刷盘时机、存储形式。</p><p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有</strong> <strong>redo log</strong> <strong>什么事？</strong></p><p>它们不都是刷盘么？差别在哪里？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> Byte <span class="hljs-operator">=</span> <span class="hljs-number">8</span>bit<br><span class="hljs-number">1</span> KB <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> Byte<br><span class="hljs-number">1</span> MB <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> KB<br><span class="hljs-number">1</span> GB <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> MB<br><span class="hljs-number">1</span> TB <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> GB<br></code></pre></td></tr></table></figure><p>实际上，数据页大小是16KB，刷盘比较耗时，可能就修改了数据页里的几 Byte 数据，有必要把完整的数据页刷盘吗？</p><p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p><p>如果是写 redo log，一行记录可能就占几十 Byte，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p><p>所以用 redo log 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>redo log 它是物理日志，记录内容是“<strong>在某个数据页上做了什么修改</strong>”，属于 InnoDB 存储引擎。</p><p>而 binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。</p><p>那 binlog 到底是用来干嘛的？</p><p>可以说MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908213313383.png" alt="image-20220908213313383"></p><p>binlog会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p><h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p>binlog 日志有三种格式，可以通过binlog_format参数指定。</p><ul><li><strong>statement</strong></li><li><strong>row</strong></li><li><strong>mixed</strong></li></ul><p>指定<strong>statement</strong>，记录的内容是SQL语句原文，比如执行一条<strong>update T set update_time=now() where id=1</strong>，记录的内容如下。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908213421869.png" alt="image-20220908213421869"></p><p>同步数据时，会执行记录的SQL语句，但是有个问题，update_time=now()这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p><p>为了解决这种问题，我们需要指定为row，记录的内容不再是简单的SQL语句了，还包含操作的具体数据，记录内容如下。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908213517492.png" alt="image-20220908213517492"></p><p>row格式记录的内容看不到详细信息，要通过mysqlbinlog工具解析出来。</p><p>update_time=now()变成了具体的时间update_time=1627112756247，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p><p>这样就能保证同步数据的一致性，通常情况下都是指定为row，这样可以为数据库的恢复与同步带来更好的可靠性。</p><p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。</p><p>所以就有了一种折中的方案，指定为mixed，记录的内容是前两者的混合。</p><p>MySQL会判断这条SQL语句是否可能引起数据不一致，如果是，就用row格式，否则就用statement格式</p><h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到<strong>binlog cache</strong>，事务提交的时候，再把binlog cache写到<strong>binlog</strong>文件中。</p><p>因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache。</p><p>我们可以通过<strong>binlog_cache_size</strong>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（Swap）。</p><p>binlog日志刷盘流程如下</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908213744369.png" alt="image-20220908213744369"></p><ul><li><p><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></p></li><li><p><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></p></li></ul><p>write和fsync的时机，可以由参数sync_binlog控制，默认是0。</p><p>为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908213841944.png" alt="image-20220908213841944"></p><p>虽然性能得到提升，但是机器宕机，page cache里面的 binlog 会丢失。</p><p>为了安全起见，可以设置为1，表示每次提交事务都会执行fsync，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</p><p>最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908213916706.png" alt="image-20220908213916706"></p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p>redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力。</p><p>binlog（归档日志）保证了MySQL集群架构的数据一致性。</p><p>虽然它们都属于持久化的保证，但是侧重点不同。</p><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的写入时机不一样。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908214058360.png" alt="image-20220908214058360"></p><p>回到正题，redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？</p><p>我们以update语句为例，假设id=2的记录，字段c值是0，把字段c值更新成1，SQL语句为update T set c=1 where id=2。</p><p>假设执行过程中写完redo log日志后，binlog日志写期间发生了异常，会出现什么情况呢？</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908214137165.png" alt="image-20220908214137165"></p><p>由于binlog没写完就异常，这时候binlog里面没有对应的修改记录。因此，之后用binlog日志恢复数据时，就会少这一次更新，恢复出来的这一行c值是0，而原库因为redo log日志恢复，这一行c值是1，最终数据不一致。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908214216674.png" alt="image-20220908214216674"></p><p>为了解决两份日志之间的逻辑一致问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。</p><p>原理很简单，将redo log的写入拆成了两个步骤prepare和commit，这就是<strong>两阶段提交</strong>。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908214310160.png" alt="image-20220908214310160"></p><p>使用<strong>两阶段提交</strong>后，写入binlog时发生异常也不会有影响，因为MySQL根据redo log日志恢复数据时，发现redo log还处于prepare阶段，并且没有对应binlog日志，就会回滚该事务。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908214404416.png" alt="image-20220908214404416"></p><p>再看一个场景，redo log设置commit阶段发生异常，那会不会回滚事务呢？</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908214432260.png" alt="image-20220908214432260"></p><p>并不会回滚事务，它会执行上图框住的逻辑，虽然redo log是处于prepare阶段，但是能通过事务id找到对应的binlog日志，所以MySQL认为是完整的，就会提交事务恢复数据。</p><h2 id="binlog和redo-log有什么区别？"><a href="#binlog和redo-log有什么区别？" class="headerlink" title="binlog和redo log有什么区别？"></a>binlog和redo log有什么区别？</h2><ul><li>bin log会记录所有与数据库有关的日志记录，包括InnoDB、MyISAM等存储引擎的日志，而redo log只记InnoDB存储引擎的日志。</li><li>记录的内容不同，bin log记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而redo log记录的是关于每个页（Page）的更改的物理情况。</li><li>写入的时间不同，bin log仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有redo ertry被写入redo log中。</li><li>写入的方式也不相同，redo log是循环写入和擦除，bin log是追加写入，不会覆盖已经写的文件。</li></ul><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>另外，MVCC 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</p><h2 id="一条更新语句怎么执行的了解吗？"><a href="#一条更新语句怎么执行的了解吗？" class="headerlink" title="一条更新语句怎么执行的了解吗？"></a>一条更新语句怎么执行的了解吗？</h2><p>更新语句的执行是Server层和引擎层配合完成，数据除了要写入表中，还要记录相应的日志。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908220733335.png" alt="image-20220908220733335"></p><ol><li><p>执行器先找引擎获取ID=2这一行。ID是主键，存储引擎检索数据，找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p></li><li><p>执行器拿到引擎给的行数据，把这个值加上 1 ，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接又写入这行新数据。</p></li><li><p>引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。</p></li><li><p>执行器生成这个操作的binlog，并把binlog写入磁盘。</p></li><li><p>执行器调用引擎的提交事务接又，引擎把刚刚写入的redo log改成提交（commit）状态，<br>更新完成。</p></li></ol><p>从上图可以看出，MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。</p><p>不仅如此，在对redo log写入时有两个阶段的提交，一是binlog写入之前prepare状态的写入，二是binlog写入之后commit状态的写入。</p><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a><strong>SQL优化</strong></h1><h2 id="慢SQL如何定位呢？"><a href="#慢SQL如何定位呢？" class="headerlink" title="慢SQL如何定位呢？"></a>慢SQL如何定位呢？</h2><p>慢SQL的监控主要通过两个途径：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220908221555005.png" alt="image-20220908221555005"></p><ul><li><strong>慢查询日志</strong>：开启MySQL的慢查询日志，再通过一些工具比如mysqldumpslow去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。</li><li><strong>服务监控</strong>：可以在业务的基建中加入对慢SQL的监控，常见的方案有字节码插桩、连接池扩展、ORM框架过程，对服务运行中的慢SQL进行监控和告警。</li></ul><h2 id="有哪些方式优化慢SQL？"><a href="#有哪些方式优化慢SQL？" class="headerlink" title="有哪些方式优化慢SQL？"></a>有哪些方式优化慢SQL？</h2><p>慢SQL的优化，主要从两个方面考虑，SQL语句本身的优化，以及数据库设计的优化。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220909144014581.png" alt="image-20220909144014581"></p><h3 id="避免不必要的列"><a href="#避免不必要的列" class="headerlink" title="避免不必要的列"></a>避免不必要的列</h3><p>这个是老生常谈，但还是经常会出的情况，SQL查询的时候，应该只查询需要的列，而不要包含额外的列，像*<em>select **</em> 这种写法应该尽量避免。</p><h3 id="分页优化"><a href="#分页优化" class="headerlink" title="分页优化"></a><strong>分页优化</strong></h3><h4 id="过大的分页查询为什么会慢？"><a href="#过大的分页查询为什么会慢？" class="headerlink" title="过大的分页查询为什么会慢？"></a><strong>过大的分页查询为什么会慢？</strong></h4><p>下面我们先构造一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql">#先创建一张MySQL表<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `limit_optimize_tbl` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `account` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `order_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">2000002</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8<br><br><span class="hljs-keyword">create</span> index idx_account <span class="hljs-keyword">on</span> limit_optimize_tbl(account);<br><span class="hljs-keyword">create</span> index idx_order_id <span class="hljs-keyword">on</span> limit_optimize_tbl(order_id);<br><br>#创建一个插入数据的存储过程<br>DELIMITER <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> limit_optimize_test()<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> i <span class="hljs-type">INT</span>;<br>    <span class="hljs-keyword">SET</span> i<span class="hljs-operator">=</span><span class="hljs-number">1000000</span>;<br>    WHILE i<span class="hljs-operator">&lt;=</span><span class="hljs-number">3000000</span> DO<br>        <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> limit_optimize_tbl(account,order_id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;test_123&#x27;</span>,concat(<span class="hljs-string">&#x27;order&#x27;</span>, i));<br>        <span class="hljs-keyword">SET</span> i<span class="hljs-operator">=</span>i<span class="hljs-operator">+</span><span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">END</span> WHILE;<br><span class="hljs-keyword">END</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><br>DELIMITER ;<br><br>#调用存储过程，插入<span class="hljs-number">200</span>万行数据<br><span class="hljs-keyword">call</span> limit_optimize_test();<br></code></pre></td></tr></table></figure><p>下面的这行 SQL 是一个常见的分页查询的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这种写法是最简单的，但同时也是最容易出问题的。</p><p>曾经有人做过调查，用户在浏览前端页面时，假如这个页面是分页浏览的（例如淘宝），用户只会浏览前面几页，一般翻页超过 10 页很多人就开始表现的不耐烦了。</p><p>在翻页比较少的情况下，LIMIT 子句并不会表现出性能问题。</p><p>但是假如用户要直接跳到最后一页呢？</p><p>通常情况下，由于要保证所有的页面都可以正常跳转，因此可能不会使用如下这种语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id <span class="hljs-keyword">desc</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>而是继续采用正序顺序做分页查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>采用这种 SQL 查询的话，此时从 MySQL 中取出这 10 行数据的代价是非常大的，需要先排序出前面 1000010 条记录，然后抛弃前面的 1000000 条。</p><p>查询数据和排序的代价非常高。</p><p>我们再来看一下上面这个 SQL 语句的执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span> \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: limit_optimize_tbl<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: idx_order_id<br>      key_len: <span class="hljs-number">302</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">10</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">NULL</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span> \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: limit_optimize_tbl<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ALL</span><br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: <span class="hljs-keyword">NULL</span><br>      key_len: <span class="hljs-keyword">NULL</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1994816</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> filesort<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>从执行计划中你可以看到，在大分页的时候，MySQL 并没有走索引扫描，而是使用了全表扫描的方式。</p><p>那这又是为什么呢？</p><p>MySQL 数据库采用了基于代价的查询优化器，而查询代价的估算是基于 CPU 代价和 IO 代价。</p><p>由于现在机械硬盘还没有被完全淘汰掉，因此在类似这种局部扫描的动作中，随机 IO 的代价，仍然被 MySQL 的查询优化器认为是非常高的。</p><p>对于局部扫描，MySQL 会根据数据量的情况和数据获取的条件，去做代价估算，决定是采用顺序扫描还是随机读取存储系统。</p><p><strong>如果 MySQL 在查询代价估算中，认为采取顺序扫描方式比局部随机扫描的效率更高的话，就会放弃索引，转向顺序扫描的方式</strong>。</p><p>这就是为什么在大分页中 MySQL 数据库走了全表扫描的原因。</p><p>下面我们还是使用刚刚的 SQL 语句，再来实验一下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs sql">#这两个<span class="hljs-keyword">SQL</span>语句是查询优化器改变策略的一个临界点，在笔者电脑上测试通过<br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">5660</span>,<span class="hljs-number">10</span> \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: limit_optimize_tbl<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: idx_order_id<br>      key_len: <span class="hljs-number">302</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">5670</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">NULL</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">5661</span>,<span class="hljs-number">10</span> \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: limit_optimize_tbl<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: <span class="hljs-keyword">ALL</span><br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: <span class="hljs-keyword">NULL</span><br>      key_len: <span class="hljs-keyword">NULL</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">1994816</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> filesort<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>从上面的实验你可以看到，在这个临界点上，MySQL 分别采用了<strong>索引扫描</strong>和<strong>全表扫描</strong>的查询优化方式。</p><p>你可以自行运行下这两个 SQL 语句，比较下执行时间。</p><p>由于 MySQL 的查询优化器的算法核心我们是无法人工干预的，因此我们的优化思路应该着眼于如何<strong>让分页维持在最佳的效率区间</strong>。</p><p>下面我们就来看下如何优化。</p><p>优化可以从两个角度进行分析：<strong>SQL 改写优化与业务角度优化</strong>。</p><h4 id="SQL-改写优化"><a href="#SQL-改写优化" class="headerlink" title="SQL 改写优化"></a><strong>SQL 改写优化</strong></h4><h5 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h5><p>由于索引是有序的，因此这种优化方式的思路是直接在索引上完成排序和分页的操作。</p><p>先来说说什么是<strong>覆盖索引</strong>。</p><p>如果一个 SQL 语句，通过索引即可直接获取查询结果，而<strong>不再需要回表查询</strong>，就称这个索引覆盖了这条 SQL 语句。</p><p>也就是平时所说的不需要回表操作。</p><p>在 MySQL 数据库中使用执行计划查看，如果 <strong>extra</strong> 这一列中显示 <strong>Using index</strong>，就表示这条 SQL 语句使用了<strong>覆盖索引</strong>。</p><p>下面我们看下刚刚的那条 SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span> \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: limit_optimize_tbl<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: idx_order_id<br>      key_len: <span class="hljs-number">302</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">10</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">NULL</span><br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> order_id <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span> \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: limit_optimize_tbl<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: idx_order_id<br>      key_len: <span class="hljs-number">302</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">10</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br><br>mysql<span class="hljs-operator">&gt;</span> explain <span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span> \G<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> <span class="hljs-number">1.</span> <span class="hljs-type">row</span> <span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span><br>           id: <span class="hljs-number">1</span><br>  select_type: SIMPLE<br>        <span class="hljs-keyword">table</span>: limit_optimize_tbl<br>   partitions: <span class="hljs-keyword">NULL</span><br>         type: index<br>possible_keys: <span class="hljs-keyword">NULL</span><br>          key: idx_order_id<br>      key_len: <span class="hljs-number">302</span><br>          <span class="hljs-keyword">ref</span>: <span class="hljs-keyword">NULL</span><br>         <span class="hljs-keyword">rows</span>: <span class="hljs-number">10</span><br>     filtered: <span class="hljs-number">100.00</span><br>        Extra: <span class="hljs-keyword">Using</span> index<br><span class="hljs-number">1</span> <span class="hljs-type">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span>, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>从这个实验中可以看到，除了 select * 的那条 SQL 语句，其他两个都使用了覆盖索引。</p><p>你也可以对比一下使用了覆盖索引的大分页和和没有使用覆盖索引的性能差异。</p><p>在我的环境中执行实验中的 “LIMIT 1000000,10” 的分页查询，没有使用覆盖索引的 SQL 语句执行时间是 2.51s，使用了覆盖索引的 SQL 语句执行时间是 0.16s，优化效果还是非常明显的。</p><h5 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h5><p>由于在 <strong>SELECT</strong> 语句中我们很少会只查询某一两个列，因此上述覆盖索引的适用范围就比较有限。</p><p>可以通过<strong>将分页的 SQL 语句改写成子查询</strong>的方法获得性能的提升：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;=</span>(<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">1000000</span>,<span class="hljs-number">1</span>) limit <span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> account  <span class="hljs-operator">|</span> order_id     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000001</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000000 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000002</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000001 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000003</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000002 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000004</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000003 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000005</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000004 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000006</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000005 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000007</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000006 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000008</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000007 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000009</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000008 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000010</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000009 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.16</span> sec)<br></code></pre></td></tr></table></figure><p>执行时间和上一节的使用了覆盖索引的 SQL 语句基本一致。</p><p>不知道你有没有观察到，这种优化方法也有其局限性：</p><ol><li>首先，分页的数据必须是连续的</li><li>其次，WHERE 子句里面不能再添加别的条件</li></ol><h5 id="延迟关联"><a href="#延迟关联" class="headerlink" title="延迟关联"></a>延迟关联</h5><p>和上述子查询的做法类似，我们也可以使用 <strong>JOIN</strong> 的语法，<strong>先在索引上完成分页的操作，然后再回表获取需要的数据列</strong>。</p><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> a.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id limit <span class="hljs-number">1000000</span>,<span class="hljs-number">10</span>) b <span class="hljs-keyword">on</span> a.id<span class="hljs-operator">=</span>b.id;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> account  <span class="hljs-operator">|</span> order_id     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000001</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000000 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000002</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000001 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000003</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000002 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000004</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000003 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000005</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000004 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000006</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000005 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000007</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000006 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000008</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000007 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000009</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000008 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000010</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000009 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.15</span> sec)<br></code></pre></td></tr></table></figure><p>你可以和上一小节的子查询优化的方式做个对比，在采用了 JOIN 语法改写之后，上面的两个限制都解除了，并且 SQL 的执行效率没有损失。</p><h5 id="记录书签"><a href="#记录书签" class="headerlink" title="记录书签"></a>记录书签</h5><p>和上述使用覆盖索引的思路不同，<strong>记录书签的优化思路是使用书签记录上一页数据的位置，下次分页时直接从这个书签的位置开始扫描</strong>，从而避免 MySQL 扫描大量的数据行再丢弃的操作。</p><p>示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;=</span><span class="hljs-number">1000001</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> account  <span class="hljs-operator">|</span> order_id     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000001</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000000 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000002</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000001 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000003</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000002 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000004</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000003 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000005</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000004 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000006</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000005 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000007</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000006 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000008</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000007 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000009</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000008 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000010</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000009 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.00</span> sec)<br></code></pre></td></tr></table></figure><p>从上面的 SQL 语句你可以看到，由于使用了主键索引来做分页的操作，SQL 语句的性能是极佳的。</p><p>使用其他列做书签也是可以的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">where</span> order_id<span class="hljs-operator">&gt;=</span><span class="hljs-string">&#x27;order2000000&#x27;</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span>;<br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-operator">|</span> id      <span class="hljs-operator">|</span> account  <span class="hljs-operator">|</span> order_id     <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000001</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000000 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000002</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000001 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000003</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000002 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000004</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000003 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000005</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000004 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000006</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000005 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000007</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000006 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000008</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000007 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000009</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000008 <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> <span class="hljs-number">1000010</span> <span class="hljs-operator">|</span> test_123 <span class="hljs-operator">|</span> order2000009 <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">---------+----------+--------------+</span><br><span class="hljs-number">10</span> <span class="hljs-keyword">rows</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">set</span> (<span class="hljs-number">0.01</span> sec)<br></code></pre></td></tr></table></figure><p>这里要给你提个醒，如果没有使用主键索引或唯一索引做这个书签，排序的字段有大量重复值的情况下，输出的结果不一定是准确的，不适合使用这种写法。</p><h5 id="反向查找"><a href="#反向查找" class="headerlink" title="反向查找"></a>反向查找</h5><p>反向查找即我们在本文的开头提到的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> limit_optimize_tbl <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> order_id <span class="hljs-keyword">desc</span> limit <span class="hljs-number">0</span>,<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>这种优化的思路来自于二分查找，也就是说，<strong>当偏移量超过记录数的一半时，就可以使用这种写法来获得性能的提升</strong>。</p><p>不过这种方法需要在分页前知道符合条件的总的记录条数，但是在 InnoDB 存储引擎中，COUNT (*) 的开销其实也不小。</p><p>因此建议你仅在一些特殊情况下选用，例如<strong>直接跳到尾页</strong>。</p><h4 id="业务角度优化"><a href="#业务角度优化" class="headerlink" title="业务角度优化"></a>业务角度优化</h4><h5 id="翻页限制"><a href="#翻页限制" class="headerlink" title="翻页限制"></a>翻页限制</h5><h6 id="不允许翻过多的页"><a href="#不允许翻过多的页" class="headerlink" title="不允许翻过多的页"></a><strong>不允许翻过多的页</strong></h6><p>一言以蔽之，就是不给你查了。<br>把 LIMIT 分页的偏移量做一个限制，超过某个阈值就停止。<br>我们以淘宝网为例，使用比较热门的 “连衣裙” 的关键词进行搜索，网站仅仅提供了 100 个数据页。<br>很多大型互联网公司由于数据量巨大，都有使用这种方法。<br>粗暴又有效。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/v2-9554bb5793a4296b773f516bf6f7e846_1440w.jpg" alt="img"></p><h6 id="流式分页"><a href="#流式分页" class="headerlink" title="流式分页"></a><strong>流式分页</strong></h6><p>这种分页方式比较适用于移动端，即只能一页一页的向前或向后加载，不提供跳转的功能。<br>可以在上一级入口中提供业务列表给用户选择，从而减少分页。<br>这种分页方式在电商和新闻类 APP 上应用的非常广泛，你也可以试试。</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p>合理地设计和使用索引，是优化慢SQL的利器。</p><h4 id="利用覆盖索引"><a href="#利用覆盖索引" class="headerlink" title="利用覆盖索引"></a><strong>利用覆盖索引</strong></h4><p>InnoDB使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引</p><p>例如对于如下查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> city<span class="hljs-operator">=</span><span class="hljs-string">&#x27;上海&#x27;</span><br></code></pre></td></tr></table></figure><p>我们将被查询的字段建⽴到联合索引中，这样查询结果就可以直接从索引中获取</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">add</span> index idx_city_name (city, name);<br></code></pre></td></tr></table></figure><h4 id="低版本避免使用or查询"><a href="#低版本避免使用or查询" class="headerlink" title="低版本避免使用or查询"></a><strong>低版本避免使用or查询</strong></h4><p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。</p><h4 id="避免使用-或者-lt-gt-操作符"><a href="#避免使用-或者-lt-gt-操作符" class="headerlink" title="避免使用 != 或者 &lt;&gt; 操作符"></a><strong>避免使用 != 或者 &lt;&gt; 操作符</strong></h4><p>SQL中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引</p><p>解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描</p><p>例如，把<strong>column&lt;&gt;’aaa’</strong>，改成<strong>column&gt;’aaa’ or column&lt;’aaa’</strong>，就可以使用索引了</p><h4 id="适当使用前缀索引"><a href="#适当使用前缀索引" class="headerlink" title="适当使用前缀索引"></a><strong>适当使用前缀索引</strong></h4><p>适当地使用前缀索引，可以降低索引的空间占用，提高索引的查询效率。</p><p>比如，邮箱的后缀都是固定的“@xxx.com”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> test <span class="hljs-keyword">add</span> index index2(email(<span class="hljs-number">6</span>));<br></code></pre></td></tr></table></figure><p>PS:需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引</p><h4 id="避免列上函数运算"><a href="#避免列上函数运算" class="headerlink" title="避免列上函数运算"></a><strong>避免列上函数运算</strong></h4><p>要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span> ;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> <span class="hljs-keyword">month</span>(updateTime) <span class="hljs-operator">=</span> <span class="hljs-number">7</span> ;<br></code></pre></td></tr></table></figure><h4 id="正确使用联合索引"><a href="#正确使用联合索引" class="headerlink" title="正确使用联合索引"></a><strong>正确使用联合索引</strong></h4><p>使用联合索引的时候，注意最左匹配原则。</p><h3 id="JOIN优化"><a href="#JOIN优化" class="headerlink" title="JOIN优化"></a>JOIN优化</h3><h4 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a><strong>优化子查询</strong></h4><p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大</p><h4 id="小表驱动大表"><a href="#小表驱动大表" class="headerlink" title="小表驱动大表"></a><strong>小表驱动大表</strong></h4><p>关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL内部会遍历驱动表，再去连接被驱动表。</p><p>比如left join，左表就是驱动表，A表小于B表，建立连接的次数就少，查询速度就被加快了。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> name <span class="hljs-keyword">from</span> A <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> B ;<br></code></pre></td></tr></table></figure><h4 id="适当增加冗余字段"><a href="#适当增加冗余字段" class="headerlink" title="适当增加冗余字段"></a><strong>适当增加冗余字段</strong></h4><p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p><h4 id="避免使用JOIN关联太多的表"><a href="#避免使用JOIN关联太多的表" class="headerlink" title="避免使用JOIN关联太多的表"></a><strong>避免使用JOIN关联太多的表</strong></h4><p>《阿里巴巴Java开发手册》规定不要join超过三张表，第一join太多降低查询的速度，第二join的buffer会占用更多的内存。</p><p>如果不可避免要join多张表，可以考虑使用数据异构的方式异构到ES中查询。</p><h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><h4 id="利用索引扫描做排序"><a href="#利用索引扫描做排序" class="headerlink" title="利用索引扫描做排序"></a><strong>利用索引扫描做排序</strong></h4><p>MySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的</p><p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢</p><p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行</p><p>例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">--建立索引（date,staff_id,customer_id）</span><br><span class="hljs-keyword">select</span> staff_id, customer_id <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> <span class="hljs-type">date</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;2010-01-01&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> staff_id,customer_id;<br></code></pre></td></tr></table></figure><p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序</p><h3 id="UNION优化"><a href="#UNION优化" class="headerlink" title="UNION优化"></a>UNION优化</h3><h4 id="条件下推"><a href="#条件下推" class="headerlink" title="条件下推"></a><strong>条件下推</strong></h4><p>MySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引</p><p>最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化</p><p>此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高。</p><h2 id="怎么看执行计划（explain），如何理解其中各个字段的含义？"><a href="#怎么看执行计划（explain），如何理解其中各个字段的含义？" class="headerlink" title="怎么看执行计划（explain），如何理解其中各个字段的含义？"></a>怎么看执行计划（explain），如何理解其中各个字段的含义？</h2><p>explain是sql优化的利器，除了优化慢sql，平时的sql编写，也应该先explain，查看一下执行计划，看看是否还有优化的空间。</p><p>直接在 select 语句之前增加explain关键字，就会返回执行计划的信息。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910140953658.png" alt="image-20220910140953658"></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910141026496.png" alt="image-20220910141026496"></p><p><strong>1. id</strong> 列：MySQL会为每个select语句分配一个唯一的id值<br><strong>2. select_type</strong> 列，查询的类型，根据关联、union、子查询等等分类，常见的查询类型有SIMPLE、PRIMARY。<br><strong>3. table</strong> 列：表示 explain 的一行正在访问哪个表。<br><strong>4. type</strong> 列：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。<br>性能从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt;index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><ul><li>system： 当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快</li><li>const：表示查询时命中 primary key 主键或者 unique 唯一索引，或者被连接的部分是一个常量(const)值。这类扫描效率极高，返回数据量少，速度非常快。</li><li>eq_ref：查询时命中主键primary key 或者 unique key索引， type 就是eq_ref。</li><li>ref_or_null：这种连接类型类似于 ref，区别在于 MySQL会额外搜索包含NULL值的行。</li><li>index_merge：使用了索引合并优化方法，查询使用了两个以上的索引。</li><li>unique_subquery：替换下面的 IN子查询，子查询返回不重复的集合。</li><li>index_subquery：区别于unique_subquery，用于非唯一索引，可以返回重复值。</li><li>range：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在where语句中使用<br>bettween…and、&lt;、&gt;、&lt;=、in 等条件查询 type 都是 range。</li><li>index：Index 与ALL 其实都是读全表，区别在于index是遍历索引树读取，而ALL是从硬盘中读取。</li><li>ALL:就不用多说了，全表扫描。</li></ul><p><strong>5. possible_keys</strong> 列：显示查询可能使用哪些索引来查找，使用索引优化sql的时候比较重要。<br><strong>6. key</strong> 列：这一列显示 mysql 实际采用哪个索引来优化对该表的访问，判断索引是否失效的时候常用。<br><strong>7. key_len</strong> 列：显示了 MySQL使用<br><strong>8. ref</strong> 列：ref 列展示的就是与索引列作等值匹配的值，常见的有：const（常量），func，NULL，字段名。<br><strong>9. rows</strong> 列：这也是一个重要的字段，MySQL查询优化器根据统计信息，估算SQL要查到结果集需要扫描读取的数据行数，这个值非常直观显示SQL的效率好坏，原则上rows越少越好。<br><strong>10. Extra</strong> 列：显示不适合在其它列的额外信息，虽然叫额外，但是也有一些重要的信息：</p><ul><li>Using index：表示MySQL将使用覆盖索引，以避免回表</li><li>Using where：表示会在存储引擎检索之后再进行过滤</li><li>Using temporary ：表示对查询结果排序时会使用一个临时表。</li></ul><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h1><h2 id="何为索引？有什么作用？"><a href="#何为索引？有什么作用？" class="headerlink" title="何为索引？有什么作用？"></a>何为索引？有什么作用？</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p><strong>优点</strong> ：</p><ul><li><p>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</p></li><li><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p></li></ul><p><strong>缺点</strong> ：</p><ul><li><p>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</p></li><li><p>索引需要使用物理文件存储，也会耗费一定空间。</p></li></ul><p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h2 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p><strong>为何能够通过 key 快速取出 value呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hash = hashfunc(key)<br>index = hash % array_size<br></code></pre></td></tr></table></figure><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910145551358.png" alt="image-20220910145551358"></p><p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后HashMap为了减少链表过长的时候搜索时间过长引入了红黑树。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910145623148.png" alt="image-20220910145623148"></p><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p><p>既然哈希表这么快，<strong>为什么MySQL 没有使用其作为索引的数据结构呢？</strong></p><p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p><p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。</p><p>试想一种情况:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> tb1 <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">500</span>;<br></code></pre></td></tr></table></figure><p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p><h3 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h3><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910165413911.png" alt="B+"></p><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。</p><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li><p>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</p></li><li><p>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</p></li><li><p>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</p></li></ul><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p><p><strong>MyISAM</strong> 引擎中，B+Tree 叶节点的 data 域存放的是<strong>数据记录的地址</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引</strong>”。</p><p><strong>InnoDB</strong> 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 <strong>data 域保存了完整的数据记录</strong>。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（或聚集索引）</strong>”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p><h3 id="那一棵B-树能存储多少条数据呢？"><a href="#那一棵B-树能存储多少条数据呢？" class="headerlink" title="那一棵B+树能存储多少条数据呢？"></a><strong>那一棵B+树能存储多少条数据呢？</strong></h3><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910172522706.png" alt="image-20220910172522706"></p><p>假设索引字段是 bigint 类型，长度为 8 字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。非叶子节点(一页)可以存储 16384/14=1170 个这样的 单元(键值+指针)，代表有 1170 个指针。</p><p>树深度为 2 的时候，有 1170^2 个叶子节点，可以存储的数据为 <strong>1170 * 1170 *16=</strong> <strong>21902400</strong> 。</p><p>在查找数据时一次页的查找代表一次 IO，也就是说，一张 2000 万左右的表，查询数据最多需要访问 3 次磁盘。</p><p>所以在 InnoDB 中 B+ 树深度一般为 <strong>1-3 层</strong>，它就能满足千万级的数据存储。</p><h3 id="为什么要用-B-树，而不用普通二叉树？"><a href="#为什么要用-B-树，而不用普通二叉树？" class="headerlink" title="为什么要用 B+ 树，而不用普通二叉树？"></a><strong>为什么要用 B+ 树，而不用普通二叉树？</strong></h3><p>可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数。</p><p><strong>为什么不用普通二叉树？</strong></p><p>普通二叉树存在退化的情况，如果它退化成链表，相当于全表扫描。平衡二叉树相比于二叉</p><p>查找树来说，查找效率更稳定，总体的查找速度也更快。</p><p><strong>为什么不用平衡二叉树呢？</strong></p><p>读取数据的时候，是从磁盘读到内存。如果树这种数据结构作为索引，那每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是 B+ 树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快。</p><h3 id="为什么用-B-树而不用-B-树呢？"><a href="#为什么用-B-树而不用-B-树呢？" class="headerlink" title="为什么用 B+ 树而不用 B 树呢？"></a>为什么用 B+ 树而不用 B 树呢？</h3><p>B+相比较B树，有这些优势：</p><ul><li>它是 B Tree 的变种，B Tree 能解决的问题，它都能解决。<br>B Tree 解决的两大问题：<strong>每个节点存储更多关键字；路数更多</strong></li><li><strong>扫库、扫表能力更强</strong><br>如果我们要对表进行全表扫描，只需要遍历叶子节点就可以 了，不需要遍历整棵 B+Tree拿到所有的数据。</li><li>B+Tree 的磁盘读写能力相对于 B Tree 来说更强，<strong>IO次数更少</strong><br>根节点和枝节点不保存数据区， 所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多，IO次数更少。</li><li><strong>排序能力更强</strong><br>因为叶子节点上有下一个数据区的指针，数据形成了<strong>链表</strong>。</li><li><strong>效率更加稳定</strong><br>B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的。</li></ul><h3 id="Hash-索引和-B-树索引区别是什么？"><a href="#Hash-索引和-B-树索引区别是什么？" class="headerlink" title="Hash 索引和 B+ 树索引区别是什么？"></a>Hash 索引和 B+ 树索引区别是什么？</h3><ul><li>B+ 树可以进行范围查询，Hash 索引不能。</li><li>B+ 树支持联合索引的最左侧原则，Hash 索引不支持。</li><li>B+ 树支持 order by 排序，Hash 索引不支持。</li><li>Hash 索引在等值查询上比 B+ 树效率更高。</li><li>B+ 树使用 like 进行模糊查询的时候，like 后面（比如 % 开头）的话可以起到优化的作</li><li>用，Hash 索引根本无法进行模糊查询。</li></ul><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910164140079.png" alt="image-20220910164140079"></p><h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910150438065.png" alt="image-20220910150438065"></p><h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><p><strong>PS:不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</strong></p><ul><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ul><p>二级索引:</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910151114591.png" alt="二级索引"></p><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><p>首先理解聚簇索引不是一种新的索引，而是而是一种 数据存储方式 。 聚簇表示数据行和相邻的键值紧凑地存储在一起。我们熟悉的两种存储引擎——MyISAM采用的是非聚簇索引，InnoDB采用的是聚簇索引。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910202911377.png" alt="image-20220910202911377"></p><p>可以这么说：</p><ul><li>索引的数据结构是树，聚簇索引的索引和数据存储在一棵树上，树的叶子节点就是数据，非聚簇索引索引和数据不在一棵树上。</li><li>一个表中只能拥有一个聚簇索引，而非聚簇索引一个表可以存在多个。</li><li>聚簇索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</li><li>聚簇索引：物理存储按照索引排序；非聚簇索引：物理存储不按照索引排序；</li></ul><h2 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h2><p>在InnoDB存储引擎里，利用辅助索引查询，先通过辅助索引找到主键索引的键值，再通过主键值查出主键索引里面没有符合要求的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。</p><p>例如:*<em>select * from user where name = ‘张三’;*</em></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910203254480.png" alt="image-20220910203254480"></p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用辅助索引中就能够取得，不用去查主键索引，这时候使用的索引就叫做覆盖索引，避免了回表。</p><p>比如，<strong>select name from user where name = ‘张三’;</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910203424203.png" alt="image-20220910203424203"></p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p><h2 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h2><p>注意：最左前缀原则、最左匹配原则、最左前缀匹配原则这三个都是一个概念。</p><p><strong>最左匹配原则</strong> ：在InnoDB的联合索引中，查询的时候只有匹配了前一个/左边的值之后，才能匹配下一个。</p><p>根据最左匹配原则，我们创建了一个组合索引，如 (a1,a2,a3)，相当于创建了（a1）、(a1,a2)和 (a1,a2,a3) 三个索引。</p><p>为什么不从最左开始查，就无法匹配呢？</p><p>比如有一个user表，我们给 name 和 age 建立了一个组合索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">add</span> INDEX comidx_name_phone (name,age);<br></code></pre></td></tr></table></figure><p>组合索引在 B+Tree 中是复合的数据结构，它是按照从左到右的顺序来建立搜索树的 (name 在左边，age 在右边)。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910203812088.png" alt="image-20220910203812088"></p><p>从这张图可以看出来，name 是有序的，age 是无序的。当 name 相等的时候， age 才是有序的。</p><p>这个时候我们使用where name= ‘张三‘ and age = ‘20 ‘去查询数据的时候， B+Tree 会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。如果 name 相同的时候再比较age。但是如果查询条件没有 name，就不知道下一步应该查哪个 节点，因为建立搜索树的<br>时候 name 是第一个比较因子，所以就没用上索引。</p><h2 id="索引下推优化"><a href="#索引下推优化" class="headerlink" title="索引下推优化"></a>索引下推优化</h2><p>索引条件下推优化（<strong>Index Condition Pushdown (ICP)</strong> ）是MySQL5.6添加的，用于优化数据查询。</p><ul><li>不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL Server，MySQL Server进行过滤条件的判断。</li><li>当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL Server将这一部分判断条件下推给存储引擎，然后由存储引擎通过判断索引是否符合MySQLServer传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。</li></ul><p>例如一张表，建了一个联合索引（name, age），查询语句：*<em>select * from t_user where name like ‘张%’ and age=10*</em>;，由于name使用了范围查询，根据最左匹配原则：</p><p>不使用ICP，引擎层查找到name like ‘张%’的数据，再由Server层去过滤age=10这个条件，这样一来，就回表了两次，浪费了联合索引的另外一个字段age。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910205005074.png" alt="image-20220910205005074"></p><p>但是，使用了索引下推优化，把where的条件放到了引擎层执行，直接根据name like ‘张%’ and age=10的条件进行过滤，减少了回表的次数。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910205110920.png" alt="image-20220910205110920"></p><p>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p><h2 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h2><p><strong>1.选择合适的字段创建索引：</strong></p><ul><li><p><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</p></li><li><p><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</p></li><li><p><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</p></li><li><p><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</p></li><li><p><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</p></li></ul><p><strong>2.被频繁更新的字段应该慎重建立索引。</strong></p><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><p><strong>3.尽可能的考虑建立联合索引而不是单列索引。</strong></p><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><p><strong>4.注意避免冗余索引</strong> 。</p><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><p><strong>5.考虑在字符串类型的字段上使用前缀索引代替普通索引。</strong></p><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><h2 id="索引哪些情况下会失效呢"><a href="#索引哪些情况下会失效呢" class="headerlink" title="索引哪些情况下会失效呢"></a>索引哪些情况下会失效呢</h2><ul><li>查询条件包含<strong>or</strong>，可能导致索引失效</li><li>如果字段类型是字符串，where时一定用引号括起来，否则会因为<strong>隐式类型转换</strong>，索引失效</li><li><strong>like通配符</strong>可能导致索引失效。</li><li>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</li><li>在索引列上使用mysql的<strong>内置函数</strong>，索引失效。</li><li>对<strong>索引列运算</strong>（如，+、-、*、/），索引失效。</li><li>索引字段上使用（<strong>！=</strong> 或者 <strong>&lt; &gt;，not in</strong>）时，可能会导致索引失效。</li><li>索引字段上使用<strong>is null， is not null</strong>，可能导致索引失效。</li><li>左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。</li><li>MySQL优化器估计使用全表扫描要比使用索引快,则不使用索引。</li></ul><h2 id="MySQL-如何为表字段添加索引？"><a href="#MySQL-如何为表字段添加索引？" class="headerlink" title="MySQL 如何为表字段添加索引？"></a>MySQL 如何为表字段添加索引？</h2><p>1.添加 PRIMARY KEY（主键索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY ( `<span class="hljs-keyword">column</span>` )<br></code></pre></td></tr></table></figure><p>2.添加 UNIQUE(唯一索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> ( `<span class="hljs-keyword">column</span>` )<br></code></pre></td></tr></table></figure><p>3.添加 INDEX(普通索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> INDEX index_name ( `<span class="hljs-keyword">column</span>` )<br></code></pre></td></tr></table></figure><p>4.添加 FULLTEXT(全文索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> FULLTEXT ( `<span class="hljs-keyword">column</span>`)<br></code></pre></td></tr></table></figure><p>5.添加多列索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> INDEX index_name ( `column1`, `column2`, `column3` )<br></code></pre></td></tr></table></figure><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910205630795.png" alt="image-20220910205630795"></p><p>如果按锁粒度划分，有以下 3 种：</p><ul><li>表锁： 开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。</li><li>行锁： 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。</li><li>页锁： 开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般</li></ul><p>如果按照兼容性，有两种，</p><ul><li>共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。</li><li>排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。</li></ul><h2 id="InnoDB里的行锁实现"><a href="#InnoDB里的行锁实现" class="headerlink" title="InnoDB里的行锁实现"></a>InnoDB里的行锁实现</h2><p>我们拿这么一个用户表来表示行级锁，其中插入了 4 行数据，主键值分别是1,6,8,12，现在简化它的聚簇索引结构，只保留数据记录。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910214409739.png" alt="image-20220910214409739"></p><p>InnoDB的行锁的主要实现如下：</p><ul><li><strong>Record Lock 记录锁</strong></li></ul><p>记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如*<em>select * from t where id =6 for update*</em>;就会将id=6的记录锁定。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910214828711.png" alt="image-20220910214828711"></p><ul><li><strong>Gap Lock 间隙锁</strong></li></ul><p>间隙锁(Gap Locks) 的间隙指的是两个记录之间逻辑上尚未填入数据的部分,是一个<strong>左开右开空间</strong> 。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910214941003.png" alt="image-20220910214941003"></p><p>间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个record，此时就会将对应的间隙区间锁定。例如<strong>select * from t where id =3 for update**;或者**select * from t where id &gt; 1 and id &lt; 6 for update</strong>;就会将(1,6)区间锁定。</p><ul><li><strong>Next-key Lock 临键锁</strong></li></ul><p>临键指的是间隙加上它右边的记录组成的 <strong>左开右闭区间</strong> 。比如上述的(1,6]、(6,8]等。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910215510444.png" alt="image-20220910215510444"></p><p>临键锁就是<strong>记录锁(Record Locks)**和</strong>间隙锁(Gap Locks)<strong>的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分</strong>record<strong>记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个</strong>record*<em>的右边的临键区间。例如<br>**select * from t where id &gt; 5 and id &lt;= 7*</em> for update;会锁住**(4,7]、(7,+∞)**。</p><p><strong>mysql</strong>默认行锁类型就是临键锁(<strong>Next-Key Locks</strong>)。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(<strong>Next-Key Locks</strong>)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。</p><p><strong>间隙锁(Gap Locks)**和</strong>临键锁(Next-Key Locks)<strong>都是用来解决</strong>幻读问题**的，在已提交读（READ COMMITTED）隔离级别下，间隙锁(Gap Locks)和临键锁(Next-Key Locks)都会失效！</p><p>上面是行锁的三种实现算法，除此之外，在行上还存在插入意向锁。</p><ul><li><strong>Insert Intention Lock 插入意向锁</strong></li></ul><p>一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了意向锁 ，如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某个 间隙 中插入新记录，但是现在在等待。这种类型的锁命名为 <strong>Insert Intention Locks</strong> ，也就是<strong>插入意向锁</strong> 。</p><p>假如我们有个<strong>T1事务</strong>，给(1,6)区间加上了<strong>意向锁</strong>，现在有个<strong>T2事务</strong>，要插入一个数据，id为4 ，它会获取一个（1,6）区间的插入意向锁，又有有个T3事务，想要插入一个数据，id为 3 ，它也会获取一个（1,6）区间的插入意向锁，但是，这两个插入意向锁锁不会互斥。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220910222457105.png" alt="image-20220910222457105"></p><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>意向锁是一个<strong>表级锁</strong>，不要和插入意向锁搞混。</p><p>意向锁的出现是为了支持InnoDB的多粒度锁，<strong>它解决的是表锁和行锁共存的问题</strong>。</p><p>当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。</p><p>假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；</p><p>有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。</p><p>有了意向锁之后，要执行的事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务B申请表的互斥锁时会被阻塞。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911123822324.png" alt="image-20220911123822324"></p><h2 id="MySQL的乐观锁和悲观锁"><a href="#MySQL的乐观锁和悲观锁" class="headerlink" title="MySQL的乐观锁和悲观锁"></a>MySQL的乐观锁和悲观锁</h2><ul><li><strong>悲观锁（Pessimistic Concurrency Control）</strong></li></ul><p>悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。</p><p>数据库中的<strong>行锁，表锁，读锁，写锁</strong>均为悲观锁。</p><ul><li><strong>乐观锁（Optimistic Concurrency Control）</strong></li></ul><p>乐观锁认为数据的变动不会太频繁。</p><p>乐观锁通常是通过在表中增加一个**版本(version)或时间戳(timestamp)**来实现，其中，版本最为常用。</p><p>事务在从数据库中取数据时，会将该数据的版本也取出来(v1)，当事务对数据变动完毕想要将其更新到表中时，会将之前取出的版本v1与数据中最新的版本v2相对比，如果v1=v2，那么说明在数据变动期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时version会加 1 ，以此来表明数据已被变动。</p><p>如果，v1不等于v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。</p><h2 id="MySQL-死锁问题"><a href="#MySQL-死锁问题" class="headerlink" title="MySQL 死锁问题"></a>MySQL 死锁问题</h2><p>排查死锁的一般步骤是这样的：</p><ul><li>（ 1 ）查看死锁日志 show engine innodb status;</li><li>（ 2 ）找出死锁 sql</li><li>（ 3 ）分析 sql 加锁情况</li><li>（ 4 ）模拟死锁案发</li><li>（ 5 ）分析死锁日志</li><li>（ 6 ）分析死锁结果</li></ul><p>当然，这只是一个简单的流程说明，实际上生产中的死锁千奇百怪，排查和解决起来没那么简单</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="MySQL-事务的四大特性"><a href="#MySQL-事务的四大特性" class="headerlink" title="MySQL 事务的四大特性"></a>MySQL 事务的四大特性</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911152256595.png" alt="image-20220911152256595"></p><ul><li><strong>原子性</strong>：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li><strong>一致性</strong>：指在事务开始之前和事务结束以后，数据不会被破坏，假如 A 账户给 B 账户转10 块钱，不管成功与否，A 和 B 的总金额是不变的。</li><li><strong>隔离性</strong>：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。</li><li><strong>持久性</strong>：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。</li></ul><h2 id="那ACID靠什么保证的呢？"><a href="#那ACID靠什么保证的呢？" class="headerlink" title="那ACID靠什么保证的呢？"></a>那ACID靠什么保证的呢？</h2><ul><li>事务的隔离性是通过数据库锁的机制实现的。</li><li>事务的一致性由undo log来保证：undo log是逻辑日志，记录了事务的insert、update、delete操作，回滚的时候做相反的delete、update、insert操作来恢复数据。</li><li>事务的原子性和持久性由redo log来保证：redolog被称作重做日志，是物理日志，事务提交的时候，必须先将事务的所有日志写入redo log持久化，到事务的提交操作才算完成。</li></ul><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911152812313.png" alt="image-20220911152812313"></p><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911153038317.png" alt="image-20220911153038317"></p><ul><li><strong>读未提交（Read Uncommitted）</strong></li><li><strong>读已提交（Read Committed）</strong></li><li><strong>可重复读（Repeatable Read）</strong></li><li><strong>串行化（Serializable）</strong></li></ul><p>MySQL默认的事务隔离级别是**可重复读 (Repeatable Read)**。</p><h2 id="幻读，脏读，不可重复读"><a href="#幻读，脏读，不可重复读" class="headerlink" title="幻读，脏读，不可重复读"></a>幻读，脏读，不可重复读</h2><ul><li>事务 A、B 交替执行，事务 A 读取到事务 B 未提交的数据，这就是脏读。</li><li>在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是不可重复读。</li><li>事务 A 查询一个范围的结果集，另一个并发事务 B 往这个范围中插入 / 删除了数据，并静悄悄地提交，然后事务 A 再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。</li></ul><p>不同的隔离级别，在并发事务下可能会发生的问题：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911154336548.png" alt="image-20220911154336548"></p><p><strong>不可重复读和幻读有什么区别呢？</strong></p><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h2 id="事务的各个隔离级别的实现"><a href="#事务的各个隔离级别的实现" class="headerlink" title="事务的各个隔离级别的实现"></a>事务的各个隔离级别的实现</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>读未提交，就不用多说了，采取的是<strong>读不加锁原理</strong>。</p><ul><li>事务读不加锁，不阻塞其他事务的读和写</li><li>事务写阻塞其他事务写，但不阻塞其他事务读；</li></ul><h3 id="读取已提交-amp-可重复读"><a href="#读取已提交-amp-可重复读" class="headerlink" title="读取已提交&amp;可重复读"></a>读取已提交&amp;可重复读</h3><p>读取已提交和可重复读级别利用了<strong>ReadView和MVCC</strong>，也就是每个事务只能读取它能看到的<br>版本（ReadView）。</p><ul><li><strong>READ COMMITTED</strong>：每次读取数据前都生成一个ReadView</li><li><strong>REPEATABLE READ</strong> ： 在第一次读取数据时生成一个ReadView串行化</li></ul><h3 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h3><p>串行化的实现采用的是<strong>读写都加锁</strong>的原理。</p><p>串行化的情况下，对于同一行事务，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：<strong>select … lock in share mode(共享锁)**，</strong>select … for update、update、insert、delete(排他锁)**都是一种当前读。</p><p>测试：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911175944047.png" alt="image-20220911175944047"></p><p>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内 容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当我们 加排他锁的时候，也是当前读操作。</p><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>简单的select（不加锁）就是快照读，快照读，读取的是<strong>记录数据的可见版本</strong>，有可能是<strong>历史数据</strong>， 不加锁，是非阻塞读。</p><ul><li> <strong>Read Committed</strong>：每次select，都生成一个快照读。</li><li> <strong>Repeatable Read</strong>：开启事务后第一个select语句才是快照读的地方。</li><li> <strong>Serializable</strong>：快照读会退化为当前读。</li></ul><p>测试:</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911180508766.png" alt="image-20220911180508766"></p><p>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照 读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同 的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><h4 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h4><p>全称 Multi-Version Concurrency Control，<strong>多版本并发控制</strong>。指维护一个数据的多个版本， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的<strong>三个隐式字段、undo log日志、readView</strong>。</p><h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911180815226.png" alt="image-20220911180815226"></p><p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了 这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911180839960.png" alt="image-20220911180839960"></p><p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键， 如果有主键，则不会添加该隐藏字段。</p><h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。 当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。 而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。 </p><h4 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h4><p>有一张表原始数据为：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911191234515.png" alt="image-20220911191234515"></p><ul><li><strong>DB_TRX_ID</strong> : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是 自增的。</li><li><strong>DB_ROLL_PTR</strong> ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</li></ul><p>然后，有四个并发事务同时在访问这张表。</p><p>A. 第一步</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911191339478.png" alt="image-20220911191339478"></p><p>当事务2执行第一条修改语句时，会记录<strong>undo log</strong>日志，记录数据变更之前的样子; 然后更新记录， 并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911191424281.png" alt="image-20220911191424281"></p><p>B.第二步</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911191456083.png" alt="image-20220911191456083"></p><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911191614690.png" alt="image-20220911191614690"></p><p>C. 第三步</p><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记 录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911191648058.png" alt="image-20220911191648058"></p><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条 记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h4 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h4><p><strong>ReadView（读视图）</strong>是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911191829890.png" alt="image-20220911191829890"></p><p>而在<strong>readview</strong>中就规定了版本链数据的访问规则： <strong>trx_id 代表当前undolog版本链对应事务ID</strong>。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911192407624.png" alt="image-20220911192407624"></p><p>不同的隔离级别，生成<strong>ReadView</strong>的时机不同： </p><ul><li><strong>READ COMMITTED</strong> ：在事务中<strong>每一次</strong>执行快照读时生成ReadView。 </li><li><strong>REPEATABLE READ</strong>：仅在事务中<strong>第一次</strong>执行快照读时生成ReadView，后续复用该ReadView。</li></ul><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><h4 id="RC隔离级别"><a href="#RC隔离级别" class="headerlink" title="RC隔离级别"></a>RC隔离级别</h4><p><strong>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</strong></p><p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的? 在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读 都会生成一个ReadView，那么两次生成的ReadView如下。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911192724348.png" alt="image-20220911192724348"></p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则， 到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><p>A. 先来看第一次快照读具体的读取过程：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911192812721.png" alt="image-20220911192812721"></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911192833689.png" alt="image-20220911192833689"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><ul><li>先匹配<img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911193540427.png" alt="image-20220911193540427" style="zoom:25%;" />这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li><li>再匹配第二条<img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911193723009.png" alt="image-20220911193723009" style="zoom:25%;" />，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也 不满足 ，都不满足，则继续匹配undo log版本链的下一条。</li><li>再匹配第三条<img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911193756104.png" alt="image-20220911193756104" style="zoom:25%;" />，这条记 录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照 读，返回的数据就是版本链中记录的这条数据。</li></ul><p>B. 再来看第二次快照读具体的读取过程:</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911193850811.png" alt="image-20220911193850811"></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911193905500.png" alt="image-20220911193905500"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><ul><li>先匹配<img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911194012918.png" alt="image-20220911194012918" style="zoom:25%;" />这条记录，这条记录对应的 trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ， 都不满足，则继续匹配undo log版本链的下一条。</li><li>再匹配第二条<img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911194036373.png" alt="image-20220911194036373" style="zoom:25%;" />，这条 记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次 快照读，返回的数据就是版本链中记录的这条数据。</li></ul><h4 id="RR隔离级别"><a href="#RR隔离级别" class="headerlink" title="RR隔离级别"></a>RR隔离级别</h4><p>RR隔离级别下，仅在事务中第一次执行快照读时生成<strong>ReadView</strong>，后续<strong>复用该ReadView</strong>。 而RR 是可 重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911194218075.png" alt="image-20220911194218075"></p><p>我们看到，在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该 ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返 回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 <strong>InnoDB表的隐藏字段、UndoLog 版本链、ReadView</strong>来实现的。 而<strong>MVCC + 锁</strong>，则实现了事务的隔离性。 而<strong>一致性则是由redolog 与 undolog保证</strong>。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-MySQL/image-20220911194425916.png" alt="image-20220911194425916"></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试-Java基础</title>
    <link href="/weiblog/2022/09/06/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/"/>
    <url>/weiblog/2022/09/06/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念与常识"><a href="#基本概念与常识" class="headerlink" title="基本概念与常识"></a><strong>基本概念与常识</strong></h1><h2 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="headerlink" title="什么是字节码?采用字节码的好处是什么?"></a>什么是字节码?采用字节码的好处是什么?</h2><p>在 Java 中，JVM 可以理解的代码就叫做字节码（<strong>即扩展名为 .class 的文件</strong>），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。  </p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906111423536.png" alt="image-20220906111423536"></p><p>我们需要格外注意的是 <strong>.class-&gt;机器码</strong> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 <strong>JIT 属于运行时编译</strong>。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（<strong>热点代码</strong>），而这也就是 <strong>JIT 所需要编译的部分</strong>。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。<strong>JDK 9</strong> 引入了一种新的<strong>编译模式 AOT</strong>(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持<strong>分层编译和 AOT 协作</strong>使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p><h2 id="一次编写、到处运行"><a href="#一次编写、到处运行" class="headerlink" title="一次编写、到处运行"></a>一次编写、到处运行</h2><p>JVM（Java虚拟机）是Java跨平台的关键。</p><p>在程序运行前，Java源代码（.java）需要经过编译器编译成字节码（.class）。在程序运行时，JVM负责将字节码翻译成特定平台下的机器码并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</p><p>同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。</p><p><strong>注意事项</strong></p><ol><li>编译的结果是生成字节码、不是机器码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行；</li><li>跨平台的是Java程序、而不是JVM，JVM是用C/C++开发的软件，不同平台下需要安装不同版本的JVM。</li></ol><h2 id="Oracle-JDK-vs-OpenJDK"><a href="#Oracle-JDK-vs-OpenJDK" class="headerlink" title="Oracle JDK vs OpenJDK"></a>Oracle JDK vs OpenJDK</h2><ol><li>OpenJDK 是一个参考模型并且是<strong>完全开源</strong>的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 <strong>Oracle JDK</strong>，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK 使用 <strong>BCL/OTN</strong> 协议获得许可，而 OpenJDK 根据 <strong>GPL v2</strong> 许可获得许可。</li></ol><p>🌈 拓展一下：</p><ul><li>BCL 协议（Oracle Binary Code License Agreement）： 可以使用 JDK（支持商用），但是不能进行修改。</li><li>OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。</li><li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 <strong>Oracle JDK</strong>，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK 使用 <strong>BCL/OTN</strong> 协议获得许可，而 OpenJDK 根据 <strong>GPL v2</strong> 许可获得许可。</li></ul><p>🌈 拓展一下：</p><ul><li><p>BCL 协议（Oracle Binary Code License Agreement）： 可以使用 JDK（支持商用），但是不能进行修改。</p></li><li><p>OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。</p><ol><li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 <strong>Oracle JDK</strong>，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li><li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK 使用 <strong>BCL/OTN</strong> 协议获得许可，而 OpenJDK 根据 <strong>GPL v2</strong> 许可获得许可。</li></ol><p>🌈 拓展一下：</p><ul><li><p>BCL 协议（Oracle Binary Code License Agreement）： 可以使用 JDK（支持商用），但是不能进行修改。</p></li><li><p>OTN 协议（Oracle Technology Network License Agreement）： 11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。</p></li><li><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906111806538.png" alt="image-20220906111806538"></p></li></ul></li></ul><h2 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++的区别?"></a>Java 和 C++的区别?</h2><p>都是面向对象的语言，都支持<strong>封装、继承和多态</strong></p><p>Java 不提供<strong>指针</strong>来直接访问内存，程序内存更加安全</p><p>Java 的类是<strong>单继承</strong>的，C++ 支持多<strong>重继承</strong>；虽然 Java 的类不可以多继承，但是接口可以多继承。</p><p>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</p><p>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</p><h2 id="为什么说-Java-语言“编译与解释并存”？"><a href="#为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="为什么说 Java 语言“编译与解释并存”？"></a>为什么说 Java 语言“编译与解释并存”？</h2><ul><li><strong>编译型</strong> ：编译型语言 (opens new window) 会通过编译器</li></ul><p>(opens new window)将源代码<strong>一次**</strong>性**翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</p><ul><li><strong>解释型</strong> ：解释型语言</li></ul><p>(opens new window)会通过<strong>解释器</strong> (opens new window)<strong>一句一句</strong>的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</p><ul><li><strong>编译型</strong> ：编译型语言 (opens new window) 会通过编译器</li></ul><p>(opens new window)将源代码<strong>一次**</strong>性**翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</p><ul><li><strong>解释型</strong> ：解释型语言</li></ul><p>(opens new window)会通过<strong>解释器</strong> (opens new window)<strong>一句一句</strong>的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906112004658.png" alt="image-20220906112004658"></p><p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过<strong>先编译，后解释</strong>两个步骤，由 Java 编写的程序需要先经过<strong>编译步骤，生成字节码（.class 文件）</strong>，这种字节码必须由 <strong>Java 解释器</strong>来解释执行。</p><p><strong>为什么说 Java 语言“编译与解释并存”？</strong></p><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过<strong>先编译，后解释</strong>两个步骤，由 Java 编写的程序需要先经过<strong>编译步骤，生成字节码（.class 文件）</strong>，这种字节码必须由 <strong>Java 解释器</strong>来解释执行。</p><h2 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h2><ul><li><strong>JVM</strong></li></ul><p><strong>Java 虚拟机（JVM）</strong>是运行 Java 字节码的虚拟机。</p><p>JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><ul><li><strong>JRE</strong></li></ul><p><strong>Java 运行时环境</strong></p><p>它是运行已编译 Java 程序所需的所有内容的集合，包括 <strong>Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件</strong>。但是，它不能用于创建新程序。</p><ul><li><strong>JDK</strong></li></ul><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。<strong>它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）</strong>。它能够创建和编译程序。</p><h2 id="JAVA语言的特点"><a href="#JAVA语言的特点" class="headerlink" title="JAVA语言的特点"></a>JAVA语言的特点</h2><ul><li><p>1、简单易学、有丰富的类库 </p></li><li><p>2、面向对象（Java最重要的特性，让程序耦合度更低，内聚性更高） 封装，继承，多态</p></li><li><p>3、与平台无关性（JVM是Java跨平台使用的根本） </p></li><li><p>4、可靠安全</p></li><li><p>5、支持多线程</p></li><li><p>6、支持网络编程</p></li><li><p>7、编译与解释并存</p></li></ul><h2 id="线程、程序、进程"><a href="#线程、程序、进程" class="headerlink" title="线程、程序、进程"></a>线程、程序、进程</h2><p>要说线程，必须得先说说进程。</p><ul><li>进程：进程是代码在数据集合上的一次运行活动，是<strong>系统进行资源分配和调度的基本单位</strong>。</li><li>线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</li></ul><p>操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。</p><p><strong>程序</strong>是含有<strong>指令和数据的文件</strong>，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a><strong>基本语法</strong></h1><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p><strong>+=</strong> 操作符会进行<strong>隐式自动类型转换</strong>,此处<strong>a+=b</strong>隐式的<strong>将加操作的结果类型强制转换为持有结果的类</strong> 型,而a=a+b则不会自动进行类型转换.如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>b = a + b; <span class="hljs-comment">// 报编译错误:cannot convert from int to byte</span><br>b += a;<br></code></pre></td></tr></table></figure><p>以下代码是否有错,有的话怎么改？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">short</span> s1= <span class="hljs-number">1</span>;<br>s1 = s1 + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>有错误.short类型在进行运算时会自动提升为int类型,也就是说 s1+1 的运算结果是int类型,而s1是 short类型,此时编译器会报错</p><p>正确写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">short</span> s1= <span class="hljs-number">1</span>;<br>s1 += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>+=操作符会对右边的表达式结果强转匹配左边的数据类型,所以没错.</p><p>在Java语言中，当参与运算的两个数是<strong>byte、short或int类型</strong>时，他们首先会被转化成int类型，然后在进行计算。然后把计算的结果赋值给用来存储结果的变量。如果用来存储结果变量的类型是byte或者short，这意味着需要把int类型转化成byte或者short类型。a+=b和a = a+b的区别就在于<strong>a+=b会隐式的把运算结果转换为a的类型</strong>。而a = a+b不会把a+b运算结果的类型隐式转换为a的类型。</p><h2 id="使用过可变长参数吗？"><a href="#使用过可变长参数吗？" class="headerlink" title="使用过可变长参数吗？"></a>使用过可变长参数吗？</h2><p>从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 <code>printVariable</code> 方法就可以接受 0 个或者多个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，可变参数只能作为函数的<strong>最后一个参数</strong>，但其前面可以有也可以没有任何其他参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(String arg1, String... args)</span> &#123;<br>   <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？</strong></p><p>答案是会<strong>优先匹配固定参数</strong>的方法，因为固定参数的方法匹配度更高。</p><p>我们通过下面这个例子来证明一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 微信搜 JavaGuide 回复&quot;面试突击&quot;即可免费领取个人原创的 Java 面试手册</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Guide哥</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2021/12/13 16:52</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableLengthArgument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String... args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (String s : args) &#123;<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String arg1, String arg2)</span> &#123;<br>        System.out.println(arg1 + arg2);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        printVariable(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>);<br>        printVariable(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ab<br>a<br>b<br>c<br>d<br></code></pre></td></tr></table></figure><p>另外，Java 的可变参数<strong>编译后实际会被转换成一个数组</strong>，我们看编译后生成的 <code>class</code>文件就可以看出来了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VariableLengthArgument</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printVariable</span><span class="hljs-params">(String... args)</span> &#123;<br>        String[] var1 = args;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> args.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var3 &lt; var2; ++var3) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> var1[var3];<br>            System.out.println(s);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理。</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a><strong>重载</strong></h3><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>《Java 核心技术》这本书是这样介绍重载的：</p><p>如果多个方法(比如 <code>StringBuilder</code> 的构造方法)有相同的名字、不同的参数， 便产生了重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br></code></pre></td></tr></table></figure><p>编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数， 就会产生编译时错误， 因为根本不存在匹配， 或者没有一个比其他的更好(这个过程被称为重载解析(overloading resolution))。<strong>Java 允许重载任何方法， 而不只是构造器方法</strong>。</p><p>综上：<strong>重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a><strong>重写</strong></h3><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><p><strong>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</strong></p><p>如果父类方法访问修饰符为 <strong><code>private/final/static</code></strong> 则子类就<strong>不能重写该方法</strong>，但是被 <code>static</code> 修饰的方法能够被再次声明。</p><p><strong>构造方法无法被重写</strong></p><p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</strong>。</p><blockquote><p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理。</p><p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p></blockquote><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906114511133.png" alt="image-20220906114511133"></p><p><strong>方法的重写要遵循“两同两小一大”</strong>（以下内容摘录自《疯狂 Java 讲义》：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><p>⭐️ 关于 <strong>重写的返回值类型</strong> 这里需要额外多说明一下，上面的表述不太清晰准确：<strong>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hero</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级英雄&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Hero</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超人&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Hero <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hero</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperSuperMan</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SuperMan</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;超级超级英雄&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> SuperMan <span class="hljs-title function_">hero</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperMan</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="和-equals"><a href="#和-equals" class="headerlink" title="== 和 equals()"></a>== 和 equals()</h2><h3 id=""><a href="#" class="headerlink" title="=="></a>==</h3><p>对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于<strong>基本数据类型</strong>来说，<code>==</code> 比较的是<strong>值</strong>。</li><li>对于<strong>引用数据类型</strong>来说，<code>==</code> 比较的是对象的<strong>内存地址</strong>。</li></ul><p>因为 <strong>Java 只有值传递</strong>，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。两边的操作数必须是<strong>同一类型</strong>的（可以是 <strong>父子类之间</strong>）才能编译通过。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p> 不能用于判断基本数据类型的变量，<strong>只能用来判断两个对象是否相等</strong>。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>     <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有覆盖 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，<strong>等价于通过“==”比较</strong>这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类覆盖了 <code>equals()</code>方法</strong> ：一般我们都覆盖 <code>equals()</code>方法来<strong>比较两个对象中的属性是否相等</strong>；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><p>举个例子（这里只是为了举例。实际上，你按照下面这种写法的话，像 IDEA 这种比较智能的 IDE 都会提示你将 <code>==</code> 换成 <code>equals()</code> ）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// a 为一个引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// b为另一个引用,对象的内容一样</span><br><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 放在常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(aa == bb);<span class="hljs-comment">// true</span><br>System.out.println(a == b);<span class="hljs-comment">// false</span><br>System.out.println(a.equals(b));<span class="hljs-comment">// true</span><br>System.out.println(<span class="hljs-number">42</span> == <span class="hljs-number">42.0</span>);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p><p><code>String</code>类<code>equals()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object anObject)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == anObject) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> String) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">anotherString</span> <span class="hljs-operator">=</span> (String)anObject;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>            <span class="hljs-type">char</span> v1[] = value;<br>            <span class="hljs-type">char</span> v2[] = anotherString.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h2><h3 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode() 有什么用？"></a><strong>hashCode() 有什么用？</strong></h3><p><code>hashCode()</code> 的作用是<strong>获取哈希码</strong>（<code>int</code> 整数），也称为<strong>散列码</strong>。这个哈希码的作用是确定该对象在哈希表中的<strong>索引位置</strong>。</p><p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是<strong>本地方法</strong>，也就是用 C 语言或 C++ 实现的，<strong>该方法通常用来将对象的内存地址转换为整数</strong>之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><h3 id="为什么要有-hashCode？"><a href="#为什么要有-hashCode？" class="headerlink" title="为什么要有 hashCode？"></a><strong>为什么要有 hashCode？</strong></h3><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <strong>equals</strong>() 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。 </p><h3 id="那为什么-JDK-还要同时提供这两个方法呢？"><a href="#那为什么-JDK-还要同时提供这两个方法呢？" class="headerlink" title="那为什么 JDK 还要同时提供这两个方法呢？"></a><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong></h3><p>是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HastSet</code>的过程）！</p><p>我们在前面也提到了添加元素进<code>HastSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <strong><code>hashCode</code></strong> <strong>帮助我们大大缩小了查找成本</strong>。</p><h3 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong></h3><p>这是因为两个对象的**<code>hashCode</code> **值相等并不代表两个对象就相等。</p><h3 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong></h3><p>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p><p>总结下来就是 ：</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能<strong>会导致</strong> <strong><code>equals</code></strong> <strong>方法判断是相等的两个对象，<code>hashCode</code></strong> 值却不相等。例子：<strong>可能会造成再HashSet中存在两个相等的元素，但是他们的哈希值不同</strong>。</p><p><strong>思考</strong> ：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p><p><strong>总结</strong> ：</p><ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul><p><strong>拓展</strong></p><p><strong>Hashcode冲突：</strong></p><p>产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般 有以下几种方式来处理:</p><ul><li><strong>拉链法</strong>:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链 表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储. </li><li><strong>开放定址法</strong>:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总 能找到,并将记录存入</li><li><strong>再哈希</strong>:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数 计算地址,直到无冲突.</li></ul><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h2><p>Java中的变量分为成员变量和局部变量，它们的区别如下：</p><p><strong>成员变量：</strong></p><ol><li>成员变量是在类的范围里定义的变量；</li><li>成员变量<strong>有默认初始值</strong>；</li><li>未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同；</li><li>被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。</li></ol><p><strong>局部变量：</strong></p><ol><li>局部变量是在方法里定义的变量；</li><li>局部变量没有默认初始值；</li><li>局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。</li></ol><p><strong>注意事项</strong>Java中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。</p><h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><p>这个需要结合 JVM 的相关知识，主要原因如下：</p><ol><li><strong>静态方法</strong>是属于类的，在<strong>类加载</strong>的时候就会分配内存，可以通过类名直接访问。而<strong>非静态成员</strong>属于实例对象，只有在对象实例化之后才存在，需要通过类的<strong>实例对象去访问</strong>。</li><li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><h3 id="静态方法和实例方法有何不同？"><a href="#静态方法和实例方法有何不同？" class="headerlink" title="静态方法和实例方法有何不同？"></a>静态方法和实例方法有何不同？</h3><p><strong>1、调用方式</strong></p><p>在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p>不过，需要注意的是一般不建议使用 <code>对象.方法名</code> 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。</p><p>因此，一般建议使用 <code>类名.方法名</code> 的方式来调用静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staicMethod</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//......</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        <span class="hljs-comment">// 调用实例方法</span><br>        person.method();<br>        <span class="hljs-comment">// 调用静态方法</span><br>        Person.staicMethod()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、访问类成员是否存在限制</strong></p><p><strong>静态方法</strong>在访问本类的成员时，<strong>只允许访问静态成员（即静态成员变量和静态方法）</strong>，不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p><h2 id="什么是方法的返回值-方法有哪几种类型？"><a href="#什么是方法的返回值-方法有哪几种类型？" class="headerlink" title="什么是方法的返回值?方法有哪几种类型？"></a>什么是方法的返回值?方法有哪几种类型？</h2><h4 id="什么是方法的返回值-方法有哪几种类型？-1"><a href="#什么是方法的返回值-方法有哪几种类型？-1" class="headerlink" title="什么是方法的返回值?方法有哪几种类型？"></a>什么是方法的返回值?方法有哪几种类型？</h4><p><strong>方法的返回值</strong> 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！</p><p>我们可以按照方法的返回值和参数类型将方法分为下面这几种：</p><ul><li><strong>1.无参数无返回值的方法</strong></li><li><strong>2.有参数无返回值的方法</strong></li><li><strong>3.有返回值无参数的方法</strong></li><li><strong>4.有返回值有参数的方法</strong></li></ul><h2 id="continue、break-和-return-的区别是什么？"><a href="#continue、break-和-return-的区别是什么？" class="headerlink" title="continue、break 和 return 的区别是什么？"></a>continue、break 和 return 的区别是什么？</h2><p>在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：</p><ol><li><strong>continue</strong> ：指跳出当前的这一次循环，继续下一次循环。</li><li><strong>break</strong> ：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><strong>return</strong>; ：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><strong>return value</strong>; ：return 一个特定值，用于有返回值函数的方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;0&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">2</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">3</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i == <span class="hljs-number">4</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;xixi&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            System.out.println(<span class="hljs-string">&quot;haha&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;heihei&quot;</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span><br>xixi<br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br>xixi<br><span class="hljs-number">3</span><br>haha<br></code></pre></td></tr></table></figure><h2 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h2><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p><p>++ 和 – 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 <code>b = ++a</code> 时，先自增（自己增加 1），再赋值（赋值给 b）；当 <code>b = a++</code> 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“<strong>符号在前就先加/减，符号在后就后加/减</strong>”。</p><h2 id="注释有哪几种？注释越多越好吗？"><a href="#注释有哪几种？注释越多越好吗？" class="headerlink" title="注释有哪几种？注释越多越好吗？"></a>注释有哪几种？注释越多越好吗？</h2><p>Java 中的注释有三种：</p><ol><li><strong>单行注释</strong></li><li><strong>多行注释</strong></li><li><strong>文档注释</strong>。</li></ol><p>在我们编写代码的时候，如果代码量比较少，我们自己或者团队其他成员还可以很轻易地看懂代码，但是当项目结构一旦复杂起来，我们就需要用到注释了。注释并不会执行(编译器在编译代码之前会把代码中的所有注释抹掉,字节码中不保留注释)，是我们程序员写给自己看的，注释是你的代码说明书，能够帮助看代码的人快速地理清代码之间的逻辑关系。因此，在写程序的时候随手加上注释是一个非常好的习惯。</p><h2 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别?"></a>字符型常量和字符串常量的区别?</h2><ul><li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符</li><li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li><strong>占内存大小</strong> ： 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： <code>char</code> 在 Java 中占两个字节)</strong></li></ul><h2 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h2><p>instanceof 严格来说是Java中的一个<strong>双目运算符</strong>，用来<strong>测试一个对象是否为一个类的实例</strong>，用法为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> obj <span class="hljs-keyword">instanceof</span> Class<br></code></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，<strong>当 obj 为 Class 的对象，或者是其直接 或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false</strong>。 注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能 确定类型，则通过编译，具体看运行时定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>System.out.println(i <span class="hljs-keyword">instanceof</span> Integer);<span class="hljs-comment">//编译不通过 i必须是引用类型，不能是基本类型</span><br>System.out.println(i <span class="hljs-keyword">instanceof</span> Object);<span class="hljs-comment">//编译不通过</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>System.out.println(integer <span class="hljs-keyword">instanceof</span> Integer);<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返</span><br><span class="hljs-comment">//回 false。</span><br>System.out.println(<span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> Object);<br></code></pre></td></tr></table></figure><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><strong>基本数据类型</strong></h1><h2 id="Java-中的几种基本数据类型了解么？"><a href="#Java-中的几种基本数据类型了解么？" class="headerlink" title="Java 中的几种基本数据类型了解么？"></a>Java 中的几种基本数据类型了解么？</h2><p><strong>Java 中有 8 种基本数据类型</strong>，分别为：</p><ol><li>6 种数字类型：<ul><li>4 种整数型：<strong>byte、short、int、long</strong></li><li>2 种浮点型：<strong>float、double</strong></li></ul></li><li>1 种字符类型：<strong>char</strong></li><li>1 种布尔型：<strong>boolean</strong>。</li></ol><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906180157973.png" alt="image-20220906180157973"></p><p>虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有 任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java 虚拟机中的<strong>int</strong>数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素 boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字 节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数据是32位（这里不是指的 是32/64位系统，而是指CPU硬件层面），具有<strong>高效存取</strong>的特点。</p><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一（《Java 编程思想》2.2 节有提到）。</p><p><strong>注意：</strong></p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li><code>char a = &#39;h&#39;</code>char :单引号，<code>String a = &quot;hello&quot;</code> :双引号。</li></ol><p>这八种基本类型都有对应的包装类分别为：**<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。**</p><p><strong>包装类型不赋值就是</strong> <strong><code>Null</code></strong> <strong>，而基本类型有默认值且不是</strong> **<code>Null</code>**。</p><p>另外，这个问题建议还可以先从 JVM 层面来分析。</p><p><strong>基本数据类型</strong>直接存放在 Java 虚拟机栈中的<strong>局部变量表</strong>中，而<strong>包装类型</strong>属于对象类型，我们知道对象实例都存在于<strong>堆</strong>中。相比于对象类型， 基本数据类型占用的空间非常小。</p><p>引用类型就是对一个对象的引用，根据引用对象类型的不同，可以将引用类型分为3类，即数组、类、接口类型。引用类型本质上就是通过指针，指向堆中对象所持有的内存空间，只是Java语言不再沿用指针这个说法而已。</p><h2 id="int和Integer有什么区别，二者在做-运算时会得到什么结果"><a href="#int和Integer有什么区别，二者在做-运算时会得到什么结果" class="headerlink" title="int和Integer有什么区别，二者在做==运算时会得到什么结果"></a>int和Integer有什么区别，二者在做==运算时会得到什么结果</h2><p>int是基本数据类型，Integer是int的包装类。二者在做==运算时，Integer会<strong>自动拆箱</strong>为int类型，然后再进行比较。届时，如果两个int值相等则返回true，否则就返回false。</p><h2 id="如何对Integer和Double类型判断相等？"><a href="#如何对Integer和Double类型判断相等？" class="headerlink" title="如何对Integer和Double类型判断相等？"></a>如何对Integer和Double类型判断相等？</h2><p>Integer、Double不能直接进行比较，这包括：</p><ul><li>不能用==进行直接比较，因为它们是不同的数据类型；</li><li>不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等；</li><li>不能使用compareTo方法进行比较，虽然它们都有compareTo方法，但该方法只能对相同类型进行比较。</li></ul><p>整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以<strong>将Integer、Double先转为转换为相同的基本数据类（如double）</strong>，然后使用==进行比较。 </p><p><strong>示例代码</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer i <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;</span><br>Double d <span class="hljs-operator">=</span> <span class="hljs-number">100.00</span><span class="hljs-comment">;</span><br>System.out.println(i.doubleValue() <span class="hljs-operator">=</span><span class="hljs-operator">=</span> d.doubleValue())<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="为啥要有包装类？"><a href="#为啥要有包装类？" class="headerlink" title="为啥要有包装类？"></a>为啥要有包装类？</h2><p><strong>参考答案</strong></p><p>Java语言是面向对象的语言，其设计理念是“<strong>一切皆对象</strong>”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。</p><p><strong>扩展阅读</strong></p><p>Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。</p><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p><strong>什么是自动拆装箱？</strong></p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> i;   <span class="hljs-comment">//拆箱</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">L1<br> LINENUMBER <span class="hljs-number">8</span> L1<br> ALOAD <span class="hljs-number">0</span><br> BIPUSH <span class="hljs-number">10</span><br> INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;<br> PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;<br>L2<br> LINENUMBER <span class="hljs-number">9</span> L2<br> ALOAD <span class="hljs-number">0</span><br> ALOAD <span class="hljs-number">0</span><br> GETFIELD AutoBoxTest.i : Ljava/lang/Integer;<br> INVOKEVIRTUAL java/lang/Integer.intValue ()I<br> PUTFIELD AutoBoxTest.n : I<br> RETURN<br></code></pre></td></tr></table></figure><p>从字节码中，我们发现装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 **<code>xxxValue()</code>**方法。</p><p>因此，</p><ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul><p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 应该使用 long 而不是 Long</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0L</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= Integer.MAX_VALUE; i++)<br>        sum += i;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要 这样就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>试题1： 以下代码会输出什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br> <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br> <span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br> <span class="hljs-type">Integer</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br> <span class="hljs-type">Integer</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br> <br> System.out.println(i1==i2);<br> System.out.println(i3==i4);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对 象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br> <span class="hljs-keyword">if</span>(i &gt;= -<span class="hljs-number">128</span> &amp;&amp; i &lt;= IntegerCache.high)<br> <span class="hljs-keyword">return</span> IntegerCache.cache[i + <span class="hljs-number">128</span>];<br> <span class="hljs-keyword">else</span><br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br> &#125;<br></code></pre></td></tr></table></figure><p>其中<strong>IntegerCache类</strong>的实现为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br> <span class="hljs-keyword">static</span> &#123;<br> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br> <span class="hljs-comment">// high value may be configured by property</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br> <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br> <span class="hljs-comment">// Use Long.decode here to avoid invoking methods that</span><br> <span class="hljs-comment">// require Integer&#x27;s autoboxing cache to be initialized</span><br> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Long.decode(integerCacheHighPropValue).intValue();<br> i = Math.max(i, <span class="hljs-number">127</span>);<br> <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br> h = Math.min(i, Integer.MAX_VALUE - -low);<br> &#125;<br> high = h;<br> cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br> <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br> cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br> &#125;<br> <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>从这2段代码可以看出，在通过<strong>valueOf方法</strong>创建Integer对象的时候，如果数值在**[-128,127]<strong>之间， 便返回指向</strong>IntegerCache.cache**中已经存在的对象的引用；否则创建一个新的Integer对象。 上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是 同一个对象，而i3和i4则是分别指向不同的对象。</p><p><strong>面试题2：以下代码输出什么</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br> <span class="hljs-type">Double</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100.0</span>;<br> <span class="hljs-type">Double</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">100.0</span>;<br> <span class="hljs-type">Double</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">200.0</span>;<br> <span class="hljs-type">Double</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">200.0</span>;<br> <br> System.out.println(i1==i2);<br> System.out.println(i3==i4);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-literal">false</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>原因： 在某个范围内的整型数值的个数是有限的，而浮点数却不是。</p><h2 id="包装类型的常量池技术了解么？"><a href="#包装类型的常量池技术了解么？" class="headerlink" title="包装类型的常量池技术了解么？"></a>包装类型的常量池技术了解么？</h2><p>Java 基本类型的包装类的大部分都实现了<strong>常量池技术</strong>。</p><p><strong>Byte,Short,Integer,Long</strong> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的<strong>缓存数据</strong>，<strong>Character</strong> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<strong>Boolean</strong> 直接返回 <strong>True or False</strong>。</p><p><strong>Integer 缓存源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>Character</code> 缓存源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Character <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-keyword">if</span> (c &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// must cache</span><br>      <span class="hljs-keyword">return</span> CharacterCache.cache[(<span class="hljs-type">int</span>)c];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>(c);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterCache</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">CharacterCache</span><span class="hljs-params">()</span>&#123;&#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Character cache[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>[<span class="hljs-number">127</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; cache.length; i++)<br>            cache[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Character</span>((<span class="hljs-type">char</span>)i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>Boolean</code> 缓存源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">boolean</span> b)</span> &#123;<br>    <span class="hljs-keyword">return</span> (b ? TRUE : FALSE);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>两种浮点数类型的包装类 <strong>Float,Double</strong>并没有实现常量池技术。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">33</span>;<br>System.out.println(i1 == i2);<span class="hljs-comment">// 输出 true</span><br><span class="hljs-type">Float</span> <span class="hljs-variable">i11</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br><span class="hljs-type">Float</span> <span class="hljs-variable">i22</span> <span class="hljs-operator">=</span> <span class="hljs-number">333f</span>;<br>System.out.println(i11 == i22);<span class="hljs-comment">// 输出 false</span><br><span class="hljs-type">Double</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br><span class="hljs-type">Double</span> <span class="hljs-variable">i4</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.2</span>;<br>System.out.println(i3 == i4);<span class="hljs-comment">// 输出 false</span><br></code></pre></td></tr></table></figure><p>下面我们来看一下问题。下面的代码的输出结果是 <code>true</code> 还是 <code>flase</code> 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">40</span>);<br>System.out.println(i1==i2);<br></code></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是常量池中的对象。而**<code>Integer i2 = new Integer(40)</code>** <strong>会直接创建新的对象</strong>。 因此，答案是 <code>false</code> 。</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906174815320.png" alt="image-20220906174815320"></p><p>缓存池</p><p><strong>new Integer(123) 与 Integer.valueOf(123)</strong> 的区别在于:</p><ul><li>new Integer(123) 每次都会新建一个对象</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">123</span>);<br>System.out.println(x == y);    <span class="hljs-comment">// false</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">z</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">123</span>);<br>System.out.println(z == k);   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器会<strong>在缓冲池范围内的基本类型</strong>自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>System.out.println(m == n); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>基本类型对应的缓冲池如下:</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \u0000 to \u007F</li></ul><p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><p>如果在缓冲池之外：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">323</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">323</span>;<br>System.out.println(m == n); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a><strong>面向对象基础</strong></h1><h2 id="面向对象和面向过程"><a href="#面向对象和面向过程" class="headerlink" title="面向对象和面向过程"></a>面向对象和面向过程</h2><p><strong>面向过程</strong>：是<strong>分析解决问题的步骤</strong>，然后用函数把这些步骤一步一步地实现，然后在使用的时候一 一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p><p><strong>面向对象</strong>：<strong>是把构成问题的事务分解成各个对象</strong>，而建立对象的目的也不是为了完成一个个步骤， 而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特 性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><p><strong>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性</strong>。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</p><p> <strong>封装的目的</strong></p><p>封装是面向对象编程语言对客观世界的模拟，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：</p><ul><li><p><strong>隐藏类的实现细节；</strong></p></li><li><p><strong>让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；</strong></p></li><li><p><strong>可进行数据检查，从而有利于保证对象信息的完整性；</strong></p></li><li><p><strong>便于修改，提高代码的可维护性。</strong></p><p>为了实现良好的封装，需要从两个方面考虑：</p></li><li><p><strong>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；</strong></p></li><li><p><strong>把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。</strong></p></li></ul><p>封装实际上有两个方面的含义：把该隐藏的隐藏起来，把该暴露的暴露出来。这两个方面都需要通过使用Java提供的访问控制符来实现。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h3><p>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。<strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类</strong>。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p><p><strong>关于继承如下 3 点请记住：</strong></p><ol><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a><strong>多态</strong></h3><p>多态，顾名思义，表示一个对象具有多种的状态，具体表现为<strong>父类的引用指向子类的实例。</strong></p><p><strong>多态的特点:</strong></p><ul><li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul><p>Java中的多态是怎么实现的</p><p>多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。对于父类型，可以有三种形式，即<strong>普通的类、抽象类、接口</strong>。对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法。</p><p>抽象也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。</p><h2 id="final用法"><a href="#final用法" class="headerlink" title="final用法"></a>final用法</h2><p>final也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了: </p><ul><li><p><strong>被final修饰的类不可以被继承</strong> </p></li><li><p><strong>被final修饰的方法不可以被重写</strong> </p></li><li><p><strong>被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.</strong> </p></li><li><p><strong>被final修饰的方法,JVM会尝试将其内联,以提高运行效率</strong> </p></li><li><p><strong>被final修饰的常量,在编译阶段会存入常量池中.</strong> </p></li></ul><p>对final域的读和写更像是普通的变量访问，编译器和处理器要遵守两个重排序规则：</p><ul><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li></ul><p>下面，我们通过一些示例性的代码来分别说明这两个规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalExample</span> &#123;<br>    <span class="hljs-type">int</span> i;                            <span class="hljs-comment">//普通变量</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> j;                      <span class="hljs-comment">//final变量</span><br>    <span class="hljs-keyword">static</span> FinalExample obj;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">FinalExample</span> <span class="hljs-params">()</span> &#123;     <span class="hljs-comment">//构造函数</span><br>        i = <span class="hljs-number">1</span>;                        <span class="hljs-comment">//写普通域</span><br>        j = <span class="hljs-number">2</span>;                        <span class="hljs-comment">//写final域</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span> <span class="hljs-params">()</span> &#123;    <span class="hljs-comment">//写线程A执行</span><br>        obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalExample</span> ();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span> <span class="hljs-params">()</span> &#123;       <span class="hljs-comment">//读线程B执行</span><br>        <span class="hljs-type">FinalExample</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> obj;       <span class="hljs-comment">//读对象引用</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> object.i;                <span class="hljs-comment">//读普通域</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> object.j;                <span class="hljs-comment">//读final域</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里假设一个线程A执行writer ()方法，随后另一个线程B执行reader ()方法，注意两者的调用先后关系！</p><p>下面我们通过这两个线程的交互来说明这两个规则。</p><h3 id="写final域的重排序规则"><a href="#写final域的重排序规则" class="headerlink" title="写final域的重排序规则"></a><strong>写final域的重排序规则</strong></h3><p>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p><ul><li>JMM禁止编译器把final域的写重排序到构造函数之外。</li><li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li></ul><p>现在让我们分析writer ()方法。writer ()方法只包含一行代码：finalExample = new FinalExample ()。这行代码包含两个步骤：</p><ul><li>构造一个FinalExample类型的对象；</li><li>把这个对象的引用赋值给引用变量obj。</li></ul><p>假设线程B读对象引用与读对象的成员域之间没有重排序（马上会说明为什么需要这个假设），下图是一种可能的执行时序：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/v2-3869fced5d21179df3f02f1fc2a58665_1440w.jpg" alt="img"></p><p>在上图中，写普通域的操作被编译器重排序到了构造函数之外，读线程B错误的读取了普通变量i初始化之前的值。而写final域的操作，被写final域的重排序规则“限定”在了构造函数之内，读线程B正确的读取了final变量初始化之后的值。</p><p>写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。以上图为例，在读线程B“看到”对象引用obj时，很可能obj对象还没有构造完成（对普通域i的写操作被重排序到构造函数外，此时初始值2还没有写入普通域i）。</p><p>总结一下：也就是对象初始化final变量和普通变量，然后将初始化的对象引用赋值给其它变量前，final变量可以保证已经被初始化，但是普通变量不能保证，可能会导致读取的普通变量是一个空值，或者说是未初始化的值，导致异常。</p><h3 id="读final域的重排序规则"><a href="#读final域的重排序规则" class="headerlink" title="读final域的重排序规则"></a><strong>读final域的重排序规则</strong></h3><p>读final域的重排序规则如下：</p><ul><li>在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。</li></ul><p>reader()方法包含三个操作：</p><ol><li>初次读引用变量obj;</li><li>初次读引用变量obj指向对象的普通域j。</li><li>初次读引用变量obj指向对象的final域i。</li></ol><p>现在我们假设写线程A没有发生任何重排序，同时程序在不遵守间接依赖的处理器上执行，下面是一种可能的执行时序：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/v2-4bba1060156b86b5786eb81d832b12bd_r.jpg" alt="preview"></p><p>在上图中，读对象的普通域的操作被处理器重排序到读对象引用之前。读普通域时，该域还没有被写线程A写入，这是一个错误的读取操作。而读final域的重排序规则会把读对象final域的操作“限定”在读对象引用之后，此时该final域已经被A线程初始化过了，这是一个正确的读取操作。</p><p>总结一下：<strong>在读一个对象的final变量之前，一定会先读包含这个final域的对象的引用，所以不用担心读到对象的final变量，会因为重排除导致读到的是一个未初始化的值，但是对象的普通变量就不能这样保证</strong>。</p><p>对读和写finlal域，整体总结一下：<strong>写final域的重排序规则会要求译编器在final域的写之后，构造函数return之前，插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入一个LoadLoad屏障</strong>。</p><h3 id="如果final域是引用类型"><a href="#如果final域是引用类型" class="headerlink" title="如果final域是引用类型"></a><strong>如果final域是引用类型</strong></h3><p>上面我们看到的final域是基础数据类型，下面让我们看看如果final域是引用类型，将会有什么效果？请看下列示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalReferenceExample</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] intArray;                     <span class="hljs-comment">//final是引用类型</span><br>  <span class="hljs-keyword">static</span> FinalReferenceExample obj;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalReferenceExample</span> <span class="hljs-params">()</span> &#123;        <span class="hljs-comment">//构造函数</span><br>      intArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];              <span class="hljs-comment">//1</span><br>      intArray[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;                   <span class="hljs-comment">//2</span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writerOne</span> <span class="hljs-params">()</span> &#123;          <span class="hljs-comment">//写线程A执行</span><br>      obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalReferenceExample</span> ();  <span class="hljs-comment">//3</span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writerTwo</span> <span class="hljs-params">()</span> &#123;          <span class="hljs-comment">//写线程B执行</span><br>      obj.intArray[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;                 <span class="hljs-comment">//4</span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span> <span class="hljs-params">()</span> &#123;              <span class="hljs-comment">//读线程C执行</span><br>      <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) &#123;                    <span class="hljs-comment">//5</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> obj.intArray[<span class="hljs-number">0</span>];       <span class="hljs-comment">//6</span><br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/v2-d2d2465e3e68f8c74bcf9054c3d172c7_r.jpg" alt="preview"></p><p>在上图中，1是对final域的写入，2是对这个final域引用的对象的成员域的写入，3是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的1不能和3重排序外，2和3也不能重排序。</p><p>JMM可以确保读线程C至少能看到写线程A在构造函数中对final引用对象的成员域的写入。即C至少能看到数组下标0的值为1。而写线程B对数组元素的写入，读线程C可能看的到，也可能看不到。JMM不保证线程B的写入对读线程C可见，因为写线程B和读线程C之间存在数据竞争，此时的执行结果不可预知。</p><p>如果想要确保读线程C看到写线程B对数组元素的写入，写线程B和读线程C之间需要使用同步原语（lock或volatile）来确保内存可见性。</p><blockquote><p>总结一下：如果final域为引用类型，这个其实和非引用类型禁止重排序的规则基本一样。上面的示例，writerTwo()和reader()同时对一个数据进行操作，存在竞争关系，也很好理解，我换一个非引用类型，也一样存在并发，解决方案就是加锁。</p></blockquote><h3 id="为什么final引用不能从构造函数内“逸出”"><a href="#为什么final引用不能从构造函数内“逸出”" class="headerlink" title="为什么final引用不能从构造函数内“逸出”"></a><strong>为什么final引用不能从构造函数内“逸出”</strong></h3><p>前面我们提到过，写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实要得到这个效果，还需要一个保证：</p><blockquote><p>在构造函数内部，不能让这个被构造对象的引用为其他线程可见，也就是对象引用不能在构造函数中“逸出”。</p></blockquote><p>为了说明问题，让我们来看下面示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalReferenceEscapeExample</span> &#123;<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> i;<br>  <span class="hljs-keyword">static</span> FinalReferenceEscapeExample obj;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalReferenceEscapeExample</span> <span class="hljs-params">()</span> &#123;<br>      i = <span class="hljs-number">1</span>;                              <span class="hljs-comment">//1写final域</span><br>      obj = <span class="hljs-built_in">this</span>;                          <span class="hljs-comment">//2 this引用在此“逸出”</span><br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalReferenceEscapeExample</span> ();<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> reader &#123;<br>      <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) &#123;                     <span class="hljs-comment">//3</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> obj.i;                 <span class="hljs-comment">//4</span><br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设一个线程A执行writer()方法，另一个线程B执行reader()方法。这里的操作2使得对象还未完成构造前就为线程B可见。即使这里的操作2是构造函数的最后一步，且即使在程序中操作2排在操作1后面，执行read()方法的线程仍然可能无法看到final域被初始化后的值，因为这里的操作1和操作2之间可能被重排序。实际的执行时序可能如下图所示：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/v2-8fa3251115aebd3953ff0888a94f8091_1440w.jpg" alt="img"></p><p>从上图我们可以看出：在构造函数返回前，被构造对象的引用不能为其他线程可见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</p><h2 id="static用法"><a href="#static用法" class="headerlink" title="static用法"></a>static用法</h2><p>所有的人都知道static关键字这两个基本的用法:<strong>静态变量和静态方法</strong>.也就是被static所修饰的变量/ 方法都属于类的静态资源,<strong>类实例所共享</strong>.</p><p>除了静态变量和静态方法之外,static也用于<strong>静态块</strong>,多用于初始化操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> calss PreCache&#123;<br> <span class="hljs-keyword">static</span>&#123;<br> <span class="hljs-comment">//执行相关操作</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此外static也多用于修饰内部类,此时称之为<strong>静态内部类</strong>.</p><p>最后一种用法就是静态导包,即 <strong>import static</strong> .import static是在JDK 1.5之后引入的新特性,可以用 来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br> <span class="hljs-comment">//System.out.println(Math.sin(20));传统做法</span><br> System.out.println(sin(<span class="hljs-number">20</span>));<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Java类里只能包含成员变量、方法、构造器、初始化块、内部类（包括接口、枚举）5种成员，而static可以修饰<strong>成员变量、方法、初始化块、内部类</strong>（包括接口、枚举），以static修饰的成员就是类成员。类成员属于整个类，而不属于单个对象。</p><p>对static关键字而言，有一条非常重要的规则：<strong>类成员（包括成员变量、方法、初始化块、内部类和内部枚举）不能访问实例成员（包括成员变量、方法、初始化块、内部类和内部枚举）</strong>。因为类成员是属于类的，类成员的作用域比实例成员的作用域更大，完全可能出现类成员已经初始化完成，但实例成员还不曾初始化的情况，如果允许类成员访问实例成员将会引起大量错误。 </p><p><strong>static修饰的类能不能被继承</strong></p><p><strong>static修饰的类可以被继承。</strong></p><p>如果使用static来修饰一个内部类，则这个内部类就属于外部类本身，而不属于外部类的某个对象。因此使用static修饰的内部类被称为<strong>类内部类</strong>，有的地方也称为<strong>静态内部类</strong>。</p><p>static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员属于整个类，而不属于单个对象。外部类的上一级程序单元是包，所以不可使用static修饰；而内部类的上一级程序单元是外部类，使用static修饰可以将内部类变成外部类相关，而不是外部类实例相关。因此static关键字不可修饰外部类，但可修饰内部类。</p><p>静态内部类需满足如下规则：</p><ol><li><p>静态内部类可以包含静态成员，也可以包含非静态成员；</p></li><li><p>静态内部类不能访问外部类的实例成员，只能访问它的静态成员；</p></li><li><p>外部类的所有方法、初始化块都能访问其内部定义的静态内部类；</p></li><li><p>在外部类的外部，也可以实例化静态内部类，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.内部类 变量名 = <span class="hljs-keyword">new</span> 外部类.内部类构造方法();<br></code></pre></td></tr></table></figure></li></ol><h2 id="Java访问权限"><a href="#Java访问权限" class="headerlink" title="Java访问权限"></a>Java访问权限</h2><p>Java语言为我们提供了三种访问修饰符，即private、protected、public，在使用这些修饰符修饰目标时，一共可以形成四种访问权限，即<strong>private、default、protected、public</strong>，注意在不加任何修饰符时为default访问权限。</p><p>在<strong>修饰成员变量/成员方法</strong>时，该成员的四种访问权限的含义如下：</p><ul><li>private：该成员可以被该类<strong>内部成员</strong>访问；</li><li>default：该成员可以被该类<strong>内部成员</strong>访问，也可以被<strong>同一包下其他的类</strong>访问；</li><li>protected：该成员可以被该类<strong>内部成员</strong>访问，也可以被<strong>同一包下其他的类</strong>访问，还可以被<strong>它的子类</strong>访问；</li><li>public：该成员可以被<strong>任意包下，任意类的成员</strong>进行访问。</li></ul><p>在<strong>修饰类</strong>时，该类只有两种访问权限，对应的访问权限的含义如下：</p><ul><li>default：该类可以被<strong>同一包下其他的类</strong>访问；</li><li>public：该类可以被<strong>任意包下，任意的类</strong>所访问。</li></ul><h2 id="一个Java文件里可以有多个类"><a href="#一个Java文件里可以有多个类" class="headerlink" title="一个Java文件里可以有多个类"></a>一个Java文件里可以有多个类</h2><ol><li>一个java文件里可以有多个类，但最多只能有一个被<strong>public</strong>修饰的类；</li><li>如果这个java文件中包含<strong>public</strong>修饰的类，则这个类的名称必须和java文件名一致。</li></ol><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong> ：深拷贝会<strong>完全复制整个对象</strong>，包括这个对象所包含的内部对象。</li></ul><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h3><p>浅拷贝的示例代码如下，我们这里实现了 <code>Cloneable</code> 接口，并重写了 <code>clone()</code> 方法。<code>clone()</code> 方法的实现很简单，直接调用的是父类 <code>Object</code> 的 <code>clone()</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Address <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Address) <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">private</span> Address address;<br>    <span class="hljs-comment">// 省略构造函数、Getter&amp;Setter方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>            <span class="hljs-keyword">return</span> person;<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>测试 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// true</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 使用的仍然是同一个 <code>Address</code> 对象。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h3><p>这里我们简单对 <code>Person</code> 类的 <code>clone()</code> 方法进行修改，连带着要把 <code>Person</code> 对象内部的 <code>Address</code> 对象一起复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>        person.setAddress(person.getAddress().clone());<br>        <span class="hljs-keyword">return</span> person;<br>    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;武汉&quot;</span>));<br><span class="hljs-type">Person</span> <span class="hljs-variable">person1Copy</span> <span class="hljs-operator">=</span> person1.clone();<br><span class="hljs-comment">// false</span><br>System.out.println(person1.getAddress() == person1Copy.getAddress());<br></code></pre></td></tr></table></figure><p>从输出结构就可以看出， <code>person1</code> 的克隆对象和 <code>person1</code> 包含的 <code>Address</code> 对象已经是不同的了。</p><p><strong>那什么是引用拷贝呢？</strong> 简单来说，<strong>引用拷贝就是两个不同的引用指向同一个对象。</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906211832053.png" alt="image-20220906211832053"></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906211847040.png" alt="image-20220906211847040"></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906211856438.png" alt="image-20220906211856438"></p><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><p>从<strong>设计目的</strong>上来说，二者有如下的区别：</p><p>接口体现的是一种<strong>规范</strong>。对于接口的实现者而言，<strong>接口规定了实现者必须向外提供哪些服务</strong>；对于接口的调用者而言，<strong>接口规定了调用者可以调用哪些服务</strong>，以及如何调用这些服务。当在一个程序中使用接口时，<strong>接口是多个模块间的耦合标准</strong>；当在多个应用程序之间使用接口时，<strong>接口是多个程序之间的通信标准</strong>。</p><p>抽象类体现的是一种<strong>模板式设计</strong>。抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。</p><p>从使用方式上来说，二者有如下的<strong>区别</strong>：</p><ul><li>接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；抽象类则完全可以包含普通方法。</li><li>接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。</li><li>接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</li><li>接口里不能包含初始化块；但抽象类则完全可以包含初始化块。</li><li>一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。</li></ul><p>扩展阅读</p><p>接口和抽象类很像，它们都具有如下<strong>共同的特征</strong>：</p><ul><li>接口和抽象类都<strong>不能被实例化</strong>，它们都位于继承树的顶端，用于被其他类实现和继承。</li><li>接口和抽象类都可以包含抽象方法，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。</li></ul><p><strong>面向接口编程</strong></p><p>接口体现的是一种规范和实现分离的设计哲学，充分利用接口可以极好地<strong>降低程序各模块之间的耦合</strong>，从而提高系统的可扩展性和可维护性。基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。</p><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><h3 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h3><p>构造方法特点如下：</p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p><strong>构造方法不能被 override（重写）,但是可以 overload（重载）</strong>,所以你可以看到<strong>一个类中有多个构造函数</strong>的情况。</p><p>构造方法不能重写。因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。</p><p><strong>Constructor(构造器)**不能被继承，所以不能被</strong>override(重写)<strong>，但是可以被</strong>overloading(重载)**。构造器就是构造方法，能够被重载（同类中不同参数列表的构造器），不能够被重写（子类使用super方法可以调用）。</p><h3 id="如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗?"></a>如果一个类没有声明构造方法，该程序能正确执行吗?</h3><p>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有<strong>默认的不带参数的构造方法</strong>。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，这时候，就不能直接 new 一个对象而不传递参数了，所以我们一直在不知不觉地使用构造方法，这也是为什么我们<strong>在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）</strong>。<strong>如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来</strong>（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</p><h2 id="Java创建对象"><a href="#Java创建对象" class="headerlink" title="Java创建对象"></a>Java创建对象</h2><h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><h3 id="Java创建对象方式"><a href="#Java创建对象方式" class="headerlink" title="Java创建对象方式"></a>Java创建对象方式</h3><p>java中提供了以下四种创建对象的方式:</p><ul><li><strong>new创建新对象</strong> </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure><ul><li><strong>通过反射机制</strong> </li></ul><p>使用 newInstance()，但是得处理两个异常 InstantiationException、 IllegalAccessException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">User user=User.class.newInstance();<br>Object object=(Object)Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).newInstance()<br></code></pre></td></tr></table></figure><ul><li><strong>采用clone机制</strong> </li><li><strong>通过序列化机制</strong> </li></ul><p>调用 ObjectInputStream 类的 readObject() 方法。 我们反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造函 数。一个对象实现了 Serializable 接口，就可以把对象写入到文件中，并通过读取文件来创建对 象。</p><h1 id="JAVA常见对象"><a href="#JAVA常见对象" class="headerlink" title="JAVA常见对象"></a><strong>JAVA常见对象</strong></h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String、StringBuffer、StringBuilder-的区别？String-为什么是不可变的"><a href="#String、StringBuffer、StringBuilder-的区别？String-为什么是不可变的" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?"></a><strong>String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?</strong></h3><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a><strong>可变性</strong></h4><p>简单的来说：<code>String</code> 类中使用 <strong>final</strong> <strong>关键字</strong>修饰字符数组来保存字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>我们知道被</strong> <code>final</code> <strong>关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象</strong>。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li><strong>保存字符串的数组被 final 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</strong></li><li><strong><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</strong></li></ol><p>在 Java 9 之后，<code>String</code> 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <strong>byte 数组</strong>存储字符串。</p><p><strong>StringBuilder</strong>与 <strong>StringBuffer</strong>都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多<strong>修改字符串的方法</strong>比如 <code>append</code> 方法。</p><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h4><p><strong>String中的对象是不可变的，也就可以理解为常量，线程安全</strong>。AbstractStringBuilder 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，<strong>StringBuffer 是线程安全的</strong>，内部使用 synchronized 进行同步，所以是线程安全的。<strong>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的</strong>。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h4><p><strong>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</strong> </p><p><strong>对于三者使用的总结：</strong></p><ul><li>操作少量的数据: 适用 String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li></ul><h3 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h3><p>Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906221904219.png" alt="image-20220906221904219"></p><p>不过，在循环内使用<strong>“+”</strong>进行字符串的拼接的话，<strong>存在比较明显的缺陷：编译器不会创建单个 StringBuilder</strong> <strong>以复用，会导致创建过多的 StringBuilder 对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    s += arr[i];<br>&#125;<br>System.out.println(s);<br></code></pre></td></tr></table></figure><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着<strong>每循环一次就会创建一个</strong> <strong><code>StringBuilder</code></strong> 对象。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906222043648.png" alt="image-20220906222043648"></p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题了。</p><h3 id="String-equals-和-Object-equals-有何区别？"><a href="#String-equals-和-Object-equals-有何区别？" class="headerlink" title="String#equals() 和 Object#equals() 有何区别？"></a>String#equals() 和 Object#equals() 有何区别？</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><h3 id="字符串常量池的作用了解吗？"><a href="#字符串常量池的作用了解吗？" class="headerlink" title="字符串常量池的作用了解吗？"></a>字符串常量池的作用了解吗？</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 放在常量池中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>; <span class="hljs-comment">// 从常量池中查找</span><br>System.out.println(aa==bb);<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>JDK1.7 之前</strong>运行时常量池逻辑包含字符串常量池存放在<strong>方法区</strong>。<strong>JDK1.7</strong> 的时候，字符串常量池被从方法区拿到了<strong>堆中</strong>。</p><h3 id="String类有哪些方法？"><a href="#String类有哪些方法？" class="headerlink" title="String类有哪些方法？"></a>String类有哪些方法？</h3><p>String类是Java最常用的API，它包含了大量处理字符串的方法，比较常用的有：</p><ul><li>char charAt(int index)：返回指定索引处的字符；</li><li>String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；</li><li>String[] split(String regex)：以指定的规则将此字符串分割成数组；</li><li>String trim()：删除字符串前导和后置的空格；</li><li>int indexOf(String str)：返回子串在此字符串首次出现的索引；</li><li>int lastIndexOf(String str)：返回子串在此字符串最后出现的索引；</li><li>boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；</li><li>boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；</li><li>String toUpperCase()：将此字符串中所有的字符大写；</li><li>String toLowerCase()：将此字符串中所有的字符小写；</li><li>String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；</li><li>String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串</li></ul><h3 id="String可以被继承吗？"><a href="#String可以被继承吗？" class="headerlink" title="String可以被继承吗？"></a>String可以被继承吗？</h3><p>在Java中，String类被设计为不可变类，主要表现在它保存字符串的成员变量是final的。</p><ul><li>Java 9之前字符串采用char[]数组来保存字符，即 private final char[] value；</li><li>Java 9做了改进，采用byte[]数组来保存字符，即 private final byte[] value；</li></ul><p>之所以要把String类设计为不可变类，主要是出于安全和性能的考虑，可归纳为如下4点。</p><ul><li>由于字符串无论在任何 Java 系统中都广泛使用，会用来存储敏感信息，如账号，密码，网络路径，文件处理等场景里，保证字符串 String 类的安全性就尤为重要了，如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。</li><li>在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。</li><li>字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 hashCode() 方法来确定元素的位置。由于字符串 hashcode 属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 hashcode，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。</li><li>当字符串不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的 String.intern() 方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存。</li></ul><p>因为要保证String类的不可变，那么将这个类定义为final的就很容易理解了。如果没有final修饰，那么就会存在String的子类，这些子类可以重写String类的方法，强行改变字符串的值，这便违背了String类设计的初衷。 </p><h3 id="使用字符串时，new和””推荐使用哪种方式"><a href="#使用字符串时，new和””推荐使用哪种方式" class="headerlink" title="使用字符串时，new和””推荐使用哪种方式"></a>使用字符串时，new和””推荐使用哪种方式</h3><p>先看看 “hello” 和 new String(“hello”) 的区别：</p><ul><li>当Java程序直接使用 “hello” 的字符串直接量时，JVM将会使用<strong>常量池</strong>来管理这个字符串；</li><li>当使用 new String(“hello”) 时，JVM会先使用常量池来管理 “hello” 直接量，再调用String类的构造器来创建一个<strong>新的String对象</strong>，新创建的String对象被保存在<strong>堆内存</strong>中。</li></ul><p>显然，采用new的方式会多创建一个对象出来，会占用更多的内存，所以一般建议使用<strong>直接量的方式</strong>创建字符串。 </p><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>拼接字符串有很多种方式，其中最常用的有4种，下面列举了这4种方式各自适合的场景。</p><ol><li>+ 运算符：如果拼接的都是字符串直接量，则适合使用 + 运算符实现拼接；</li><li>StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全，则适合使用StringBuilder；</li><li>StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer；</li><li>String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法；</li></ol><p><strong>用 + 运算符拼接字符串时：</strong></p><ul><li>如果拼接的都是<strong>字符串直接量</strong>，则在编译时<strong>编译器会将其直接优化为一个完整的字符串</strong>，和你直接写一个完整的字符串是一样的，所以效率非常的高。</li><li>如果拼接的字符串中<strong>包含变量</strong>，则在编译时编译器采用StringBuilder对其进行优化，即自动创建<strong>StringBuilder</strong>实例并调用其<strong>append()**方法，将这些字符串拼接在一起，效率也很高。但如果这个拼接操作是在</strong>循环中<strong>进行的，那么</strong>每次循环编译器都会创建一个StringBuilder实例**，再去拼接字符串，相当于执行了 new StringBuilder().append(str)，所以此时效率很低。</li></ul><p><strong>采用StringBuilder/StringBuffer拼接字符串时：</strong></p><ul><li>StringBuilder/StringBuffer都有字符串缓冲区，缓冲区的容量在创建对象时确定，并且<strong>默认为16</strong>。当拼接的字符串超过缓冲区的容量时，会触发缓冲区的<strong>扩容机制，即缓冲区加倍</strong>。</li><li>缓冲区频繁的扩容会降低拼接的性能，所以如果能提前预估最终字符串的长度，则建议在创建可变字符串对象时，放弃使用默认的容量，<strong>可以指定缓冲区的容量为预估的字符串的长度</strong>。</li></ul><p><strong>采用String类的concat方法拼接字符串时：</strong></p><ul><li>concat方法的拼接逻辑是，先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。</li><li>在拼接大量字符串的时候，concat方法的效率低于StringBuilder。但是只拼接2个字符串时，concat方法的效率要优于StringBuilder。并且这种拼接方式代码简洁，<strong>所以只拼2个字符串时建议优先选择concat方法</strong>。</li></ul><h3 id="String-a-“abc”-，说一下这个过程会创建什么，放在哪里？"><a href="#String-a-“abc”-，说一下这个过程会创建什么，放在哪里？" class="headerlink" title="String a = “abc”; ，说一下这个过程会创建什么，放在哪里？"></a>String a = “abc”; ，说一下这个过程会创建什么，放在哪里？</h3><p>JVM会使用常量池来管理字符串直接量。在执行这句话时，JVM会先检查常量池中是否已经存有”abc”，若没有则将”abc”存入常量池，否则就复用常量池中已有的”abc”，将其引用赋值给变量a。</p><h3 id="new-String-“abc”-是去了哪里，仅仅是在堆里面吗？"><a href="#new-String-“abc”-是去了哪里，仅仅是在堆里面吗？" class="headerlink" title="new String(“abc”) 是去了哪里，仅仅是在堆里面吗？"></a>new String(“abc”) 是去了哪里，仅仅是在堆里面吗？</h3><p>在执行这句话时，JVM会先使用常量池来管理字符串直接量，即<strong>将”abc”存入常量池</strong>。然后再创建一个新的String对象，这个对象会被保存在<strong>堆内存</strong>中。并且，堆中对象的数据会<strong>指向常量池中的直接量</strong>。</p><h3 id="string不可变的好处"><a href="#string不可变的好处" class="headerlink" title="string不可变的好处"></a>string不可变的好处</h3><p><strong>1. 可以缓存 hash 值</strong></p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><strong>2. String Pool 的需要</strong></p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220906223127273.png" alt="image-20220906223127273"></p><p><strong>3. 安全性</strong></p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><strong>4. 线程安全</strong></p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>使用 <strong>String.intern()</strong> 可以保证相同内容的字符串变量引用同一的内存对象。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;aaa&quot;</span>);<br>System.out.println(s1 == s2);           <span class="hljs-comment">// false</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> s1.intern();<br>System.out.println(s1.intern() == s3);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果是采用 “bbb” 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bbb&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;bbb&quot;</span>;<br>System.out.println(s4 == s5);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>在 Java 7 之前，字符串常量池被放在运行时常量池中，它属于永久代。而在 Java 7，字符串常量池被移到 Native Method 中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<span class="hljs-comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> <span class="hljs-comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><span class="hljs-comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<span class="hljs-comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span><br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><span class="hljs-comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><span class="hljs-comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><span class="hljs-comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<span class="hljs-comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<span class="hljs-comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<span class="hljs-comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<span class="hljs-comment">//实例被垃圾回收器回收的时候触发的操作</span><br><br></code></pre></td></tr></table></figure><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a><strong>泛型</strong></h1><h2 id="Java-泛型了解么？"><a href="#Java-泛型了解么？" class="headerlink" title="Java 泛型了解么？"></a>Java 泛型了解么？</h2><p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">12</span>);<br><span class="hljs-comment">//这里直接添加会报错</span><br>list.add(<span class="hljs-string">&quot;a&quot;</span>);<br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">List</span>&gt; clazz = list.getClass();<br><span class="hljs-type">Method</span> <span class="hljs-variable">add</span> <span class="hljs-operator">=</span> clazz.getDeclaredMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br><span class="hljs-comment">//但是通过反射添加是可以的</span><br><span class="hljs-comment">//这就说明在运行期间所有的泛型信息都会被擦掉</span><br>add.invoke(list, <span class="hljs-string">&quot;kl&quot;</span>);<br>System.out.println(list);<br><br></code></pre></td></tr></table></figure><p>泛型一般有三种使用方式: <strong>泛型类、泛型接口、泛型方法</strong>。</p><p><strong>1.泛型类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generic</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T key;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Generic</span><span class="hljs-params">(T key)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generic</span>&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure><p><strong>2.泛型接口</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Generator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;T&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;String&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.泛型方法</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(E[] inputArray)</span> &#123;<br>    <span class="hljs-keyword">for</span> (E element : inputArray) &#123;<br>        System.out.printf(<span class="hljs-string">&quot;%s &quot;</span>, element);<br>    &#125;<br>    System.out.println();<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建不同类型数组： Integer, Double 和 Character</span><br>Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>String[] stringArray = &#123; <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span> &#125;;<br>printArray(intArray);<br>printArray(stringArray);<br></code></pre></td></tr></table></figure><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><h3 id="一、各种语言中的编译器是如何处理泛型的"><a href="#一、各种语言中的编译器是如何处理泛型的" class="headerlink" title="一、各种语言中的编译器是如何处理泛型的"></a><strong>一、各种语言中的编译器是如何处理泛型的</strong></h3><p>通常情况下，一个编译器处理泛型有两种方式：</p><p>1.<strong>Code specialization</strong>。在实例化一个泛型类或泛型方法时都产生一份新的目标代码（字节码or二进制代码）。例如，针对一个泛型List，可能需要 针对String，Integer，Float产生三份目标代码。</p><p>2**.Code sharing**。对每个泛型类只生成唯一的一份目标代码；该泛型类的所有实例都映射到这份目标代码上，在需要的时候执行类型检查和类型转换。</p><p>C++ 中的模板（template）是典型的Code specialization实现。C++ 编译器会为每一个泛型类实例生成一份执行代码。执行代码中Integer List和String List是两种不同的类型。这样会导致<strong>代码膨胀</strong>（code bloat）。 C#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符）或是运行期的CLR中都是切实存在的，List<Integer>与List<String>就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型被称为<strong>真实泛型</strong>。 Java语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经被替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此对于运行期的Java语言来说，ArrayList<Integer>与ArrayList<String>就是同一个类。<strong>所以说泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为伪泛型</strong>。</p><p>C++和C#是使用Code specialization的处理机制，前面提到，他有一个缺点，那就是<strong>会导致代码膨胀</strong>。另外一个弊端是在引用类型系统中，浪费空间，因为引用类型集合中元素本质上都是一个指针。没必要为每个类型都产生一份执行代码。而这也是Java编译器中采用Code sharing方式处理泛型的主要原因。</p><p>Java编译器通过Code sharing方式为每个泛型类型创建唯一的字节码表示，并且将该泛型类型的实例都映射到这个唯一的字节码表示上。将多种泛型类形实例映射到唯一的字节码表示是通过类型擦除（type erasure）实现的。</p><h3 id="二、什么是类型擦除"><a href="#二、什么是类型擦除" class="headerlink" title="二、什么是类型擦除"></a><strong>二、什么是类型擦除</strong></h3><p>前面我们多次提到这个词：<strong>类型擦除</strong>（type erasure），那么到底什么是类型擦除呢？</p><p>类型擦除指的是通过类型参数合并，将泛型类型实例关联到<strong>同一份字节码</strong>上。编译器只为泛型类型生成一份字节码，并将其实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。 类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java字节码。 类型擦除的主要过程如下： <strong>1.将所有的泛型参数用其最左边界（最顶级的父类型）类型替换。（这部分内容可以看：Java泛型中extends和super的理解） 2.移除所有的类型参数。</strong></p><h3 id="三、Java编译器处理泛型的过程"><a href="#三、Java编译器处理泛型的过程" class="headerlink" title="三、Java编译器处理泛型的过程"></a><strong>三、Java编译器处理泛型的过程</strong></h3><p><strong>code 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();  <br>    map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hollis&quot;</span>);  <br>    map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>);  <br>    System.out.println(map.get(<span class="hljs-string">&quot;name&quot;</span>));  <br>    System.out.println(map.get(<span class="hljs-string">&quot;age&quot;</span>));  <br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>反编译后的code 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    <span class="hljs-type">Map</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();  <br>    map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;hollis&quot;</span>);  <br>    map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;22&quot;</span>); <br>    System.out.println((String) map.get(<span class="hljs-string">&quot;name&quot;</span>));  <br>    System.out.println((String) map.get(<span class="hljs-string">&quot;age&quot;</span>));  <br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>code 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span>&lt;A&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(A that)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumericValue</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;NumericValue&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumericValue</span><span class="hljs-params">(<span class="hljs-type">byte</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(NumericValue that)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value - that.value;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>反编译后的code 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Comparable</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">( Object that)</span>;<br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NumericValue</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NumericValue</span><span class="hljs-params">(<span class="hljs-type">byte</span> value)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(NumericValue that)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> value - that.value;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object obj)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> compareTo((NumericValue)obj);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span> value;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>code 3:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;A <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;A&gt;&gt; A <span class="hljs-title function_">max</span><span class="hljs-params">(Collection&lt;A&gt; xs)</span> &#123;<br>        Iterator&lt;A&gt; xi = xs.iterator();<br>        <span class="hljs-type">A</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> xi.next();<br>        <span class="hljs-keyword">while</span> (xi.hasNext()) &#123;<br>            <span class="hljs-type">A</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> xi.next();<br>            <span class="hljs-keyword">if</span> (w.compareTo(x) &lt; <span class="hljs-number">0</span>)<br>                w = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> w;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>反编译后的code 3:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Collections</span><span class="hljs-params">()</span><br>    &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Comparable <span class="hljs-title function_">max</span><span class="hljs-params">(Collection xs)</span><br>    &#123;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> xs.iterator();<br>        <span class="hljs-type">Comparable</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> (Comparable)xi.next();<br>        <span class="hljs-keyword">while</span>(xi.hasNext())<br>        &#123;<br>            <span class="hljs-type">Comparable</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (Comparable)xi.next();<br>            <span class="hljs-keyword">if</span>(w.compareTo(x) &lt; <span class="hljs-number">0</span>)<br>                w = x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> w;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>E - Element (在集合中使用，因为集合中存放的是元素)</p><p>T - Type（Java 类）</p><p>K - Key（键）</p><p>V - Value（值）</p><p>N - Number（数值类型）</p><p>？ - 表示不确定的java类型（无限制通配符类型）</p><p>S、U、V - 2nd、3rd、4th types</p><p>Object - 是所有类的根类，任何类的对象都可以设置给该Object引用变量，使用的时候可能需要类型强制转换，但是用使用了泛型T、E等这些标识符后，在实际用之前类型就已经确定了，不需要再进行类型强制转换。</p><h2 id="你的项目中哪里用到了泛型？"><a href="#你的项目中哪里用到了泛型？" class="headerlink" title="你的项目中哪里用到了泛型？"></a>你的项目中哪里用到了泛型？</h2><ul><li><p>可用于定义通用返回结果 <strong>CommonResult<T></strong> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型</p></li><li><p>定义 Excel 处理类 <strong>ExcelUtil<T></strong> 用于动态指定 Excel 导出的数据类型</p></li><li><p>用于构建集合工具类。参考 Collections 中的 sort, binarySearch 方法</p></li></ul><h2 id="List-lt-super-T-gt-和List-lt-extends-T-gt"><a href="#List-lt-super-T-gt-和List-lt-extends-T-gt" class="headerlink" title="List&lt;? super T&gt;和List&lt;? extends T&gt;"></a>List&lt;? super T&gt;和List&lt;? extends T&gt;</h2><ul><li>? 是类型通配符，List&lt;?&gt; 可以表示各种泛型List的父类，意思是<strong>元素类型未知的List</strong>；</li><li>List&lt;? super T&gt; 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是<strong>T的父类型</strong>；</li><li>List&lt;? extends T&gt; 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是<strong>T的子类型</strong>。</li></ul><p><strong>扩展阅读</strong></p><p>在Java的早期设计中，允许把Integer[]数组赋值给Number[]变量，此时如果试图把一个Double对象保存到该Number[]数组中，编译可以通过，但在运行时抛出ArrayStoreException异常。这显然是一种不安全的设计，因此Java在泛型设计时进行了改进，它不再允许把 List<Integer> 对象赋值给 List<Number> 变量。</p><p>数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型，但G<Foo> 不是 G<Bar> 的子类型。Foo[]自动向上转型为Bar[]的方式被称为型变，也就是说，Java的数组支持型变，但Java集合并不支持型变。Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a><strong>反射</strong></h1><h2 id="反射的定义、优缺点及应用场景"><a href="#反射的定义、优缺点及应用场景" class="headerlink" title="反射的定义、优缺点及应用场景"></a>反射的定义、优缺点及应用场景</h2><h3 id="何为反射？"><a href="#何为反射？" class="headerlink" title="何为反射？"></a>何为反射？</h3><p>Java 的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为 Java 语言的反射机制。反射被视为动态语言的关键。</p><h3 id="反射机制优缺点"><a href="#反射机制优缺点" class="headerlink" title="反射机制优缺点"></a>反射机制优缺点</h3><p><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供<strong>开箱即用</strong>的功能提供了便利</p><p><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以<strong>无视泛型参数的安全检查</strong>（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。使用反射 性能较低，需要解析字节码，将内存中的对象进行解析</p><p>解决方案： </p><p>1、通过setAccessible(true) 关闭JDK的安全检查来提升反射速度； </p><p>2、多次创建一个类的实例时，有缓存会快很多 </p><p>3、 ReflectASM工具类，通过字节码生成的方式加快反射速度 2）相对不安全，破坏了封装性（因为通 过反射可以获得私有方法和属性）</p><h3 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h3><p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。</p><p>但是，这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 <strong>Spring/Spring Boot、MyBatis</strong> 等等框架中都大量使用了反射机制。</p><p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p><p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理类中的真实对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;<br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p><p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p><p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p><h2 id="过反射获取Class对象的方法"><a href="#过反射获取Class对象的方法" class="headerlink" title="过反射获取Class对象的方法"></a>过反射获取Class对象的方法</h2><ul><li><strong>类名.class</strong>：即通过一个 Class 的静态变量 class 获取，实例如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> ImoocStudent.class;<br></code></pre></td></tr></table></figure><ul><li>**对象.getClass ()**：前提是有该类的对象实例，该方法由 java.lang.Object 类提供，实例如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ImoocStudent</span> <span class="hljs-variable">imoocStudent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImoocStudent</span>(<span class="hljs-string">&quot;小慕&quot;</span>);<br>Class imoocStudent.getClass();<br></code></pre></td></tr></table></figure><ul><li>**Class.forName (“包名.类名”)**：如果知道一个类的完整包名，可以通过 Class 类的静态方法 forName() 获得 Class 对象，实例如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cls</span> = Class.forName(<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>通过类加载器**xxxClassLoader.loadClass()**传入类路径获取:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> ClassLoader.loadClass(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>实现Java反射的类：</strong></p><ul><li>1）<strong>Class</strong>：表示正在运行的Java应用程序中的类和接口 注意： 所有获取对象的信息都需要Class类 来实现。 </li><li>2）<strong>Field</strong>：提供有关类和接口的属性信息，以及对它的动态访问权限。 </li><li>3）<strong>Constructor</strong>： 提供关于类的单个构造方法的信息以及它的访问权限 </li><li>4）<strong>Method</strong>：提供类或接口中某个方法的信息</li></ul><p><strong>反射的一些基本操作</strong></p><ol><li><strong>创建一个我们要使用反射操作的类</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javaguide;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TargetObject</span> &#123;<br>    <span class="hljs-keyword">private</span> String value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TargetObject</span><span class="hljs-params">()</span> &#123;<br>        value = <span class="hljs-string">&quot;JavaGuide&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publicMethod</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I love &quot;</span> + s);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">privateMethod</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;value is &quot;</span> + value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.使用反射操作这个类的方法以及参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javaguide;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException, NoSuchFieldException &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取 TargetObject 类的 Class 对象并且创建 TargetObject 类实例</span><br><span class="hljs-comment">         */</span><br>        Class&lt;?&gt; tagetClass = Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br>        <span class="hljs-type">TargetObject</span> <span class="hljs-variable">targetObject</span> <span class="hljs-operator">=</span> (TargetObject) tagetClass.newInstance();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取 TargetObject 类中定义的所有方法</span><br><span class="hljs-comment">         */</span><br>        Method[] methods = targetClass.getDeclaredMethods();<br>        <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>            System.out.println(method.getName());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取指定方法并调用</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">publicMethod</span> <span class="hljs-operator">=</span> targetClass.getDeclaredMethod(<span class="hljs-string">&quot;publicMethod&quot;</span>,<br>                String.class);<br><br>        publicMethod.invoke(targetObject, <span class="hljs-string">&quot;JavaGuide&quot;</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 获取指定参数并对参数进行修改</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> targetClass.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>        <span class="hljs-comment">//为了对类中的参数进行修改我们取消安全检查</span><br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        field.set(targetObject, <span class="hljs-string">&quot;JavaGuide&quot;</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 调用 private 方法</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Method</span> <span class="hljs-variable">privateMethod</span> <span class="hljs-operator">=</span> targetClass.getDeclaredMethod(<span class="hljs-string">&quot;privateMethod&quot;</span>);<br>        <span class="hljs-comment">//为了调用private方法我们取消安全检查</span><br>        privateMethod.setAccessible(<span class="hljs-literal">true</span>);<br>        privateMethod.invoke(targetObject);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">publicMethod<br>privateMethod<br>I love JavaGuide<br>value is JavaGuide<br></code></pre></td></tr></table></figure><p><strong>注意</strong> : 有读者提到上面代码运行会抛出 ClassNotFoundException 异常,具体原因是你没有下面把这段代码的包名替换成自己创建的 TargetObject 所在的包 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; targetClass = Class.forName(<span class="hljs-string">&quot;cn.javaguide.TargetObject&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p><code>Annontation</code> （注解） 是Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。</p><p>注解本质是一个继承了**<code>Annotation</code>** 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Override</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Annotation</span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用**@Override** 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <strong>@Value</strong>、**@Component**)都是通过反射来进行处理的。</li></ul><p>JDK 提供了很多内置的注解（比如 <strong>@Override</strong>、**@Deprecated**），同时，我们还可以自定义注解。</p><h1 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h1><h2 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h2><p>Java 中 IO 流分为几种?</p><ul><li><p>按照流的流向分，可以分为<strong>输入流和输出流</strong>；</p></li><li><p>按照操作单元划分，可以划分为<strong>字节流和字符流</strong>；</p></li><li><p>按照流的角色划分为<strong>节点流和处理流</strong>。</p></li></ul><p>Java IO 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><strong>InputStream/Reader</strong>: 所有的输入流的基类，前者是<strong>字节输入流</strong>，后者是<strong>字符输入流</strong>。</li><li><strong>OutputStream/Writer</strong>: 所有输出流的基类，前者是<strong>字节输出流</strong>，后者是<strong>字符输出流</strong>。</li></ul><h2 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h2><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p><p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果<strong>音频文件、图片</strong>等媒体文件用<strong>字节流</strong>比较好，如果涉及到<strong>字符</strong>的话使用<strong>字符流</strong>比较好。</p><h2 id="BIO、NIO、AIO？"><a href="#BIO、NIO、AIO？" class="headerlink" title="BIO、NIO、AIO？"></a>BIO、NIO、AIO？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907210051326.png" alt="image-20220907210051326"></p><p><strong>BIO</strong> (blocking I/O) ： 就是传统的IO，同步阻塞，服务器实现模式为一个连接一个线程，即 <strong>客<br>户端有连接请求时服务器端就需要启动一个线程进行处理</strong> ，如果这个连接不做任何事情会造<br>成不必要的线程开销，可以通过连接池机制改善(实现多个客户连接服务器)。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907210209850.png" alt="image-20220907210209850"></p><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4 以前的唯一选择，程序简单易理解。</p><p><strong>NIO</strong> ：全称 java non-blocking IO，是指 JDK 提供的新 API。从JDK1.4开始，Java 提供了一系列改进的输入/输出的新特性，被统称为NIO(即New IO)。</p><p>NIO是 <strong>同步非阻塞</strong> 的，服务器端用一个线程处理多个连接，客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有IO请求就进行处理：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907210351648.png" alt="image-20220907210351648"></p><p>NIO的数据是面向 <strong>缓冲区Buffer</strong> 的，必须从Buffer中读取或写入。</p><p>所以完整的NIO示意图：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907210423184.png" alt="image-20220907210423184"></p><p>可以看出，NIO的运行机制：</p><ul><li>每个Channel对应一个Buffer。</li><li>Selector对应一个线程，一个线程对应多个Channel。</li><li>Selector会根据不同的事件，在各个通道上切换。</li><li>Buffer是内存块，底层是数据。</li></ul><p><strong>AIO</strong> ：JDK 7 引入了 Asynchronous I/O，是 <strong>异步不阻塞</strong> 的 IO。在进行 I/O 编程中，常用到两种模式：Reactor 和 Proactor。Java 的 NIO 就是 Reactor，当有事件触发时，服务器端得到通知，进行相应的处理，完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p><h2 id="IO模型详解"><a href="#IO模型详解" class="headerlink" title="IO模型详解"></a>IO模型详解</h2><h3 id="何为-I-O"><a href="#何为-I-O" class="headerlink" title="何为 I/O?"></a>何为 I/O?</h3><p>I/O（<strong>I</strong>nput/<strong>O</strong>utpu） 即<strong>输入／输出</strong> 。</p><p><strong>我们先从计算机结构的角度来解读一下 I/O。</strong></p><p>根据冯.诺依曼结构，计算机结构分为 5 大部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907211415038.png" alt="image-20220907211415038"></p><p>输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。</p><p>输入设备向计算机输入数据，输出设备接收计算机输出的数据。</p><p><strong>从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。</strong></p><p><strong>我们再先从应用程序的角度来解读一下 I/O。</strong></p><p>根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 <strong>用户空间（User space）</strong> 和 <strong>内核空间（Kernel space ）</strong> 。</p><p>像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。</p><p>并且，用户空间的程序不能直接访问内核空间。</p><p>当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。</p><p>因此，用户进程想要执行 IO 操作的话，必须通过 <strong>系统调用</strong> 来间接访问内核空间。</p><p>我们在平常开发过程中接触最多的就是 <strong>磁盘 IO（读写文件）</strong> 和 <strong>网络 IO（网络请求和响应）</strong>。</p><p><strong>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。</strong></p><p>当应用程序发起 I/O 调用后，会经历两个步骤：</p><ol><li><strong>内核等待 I/O 设备准备好数据</strong></li><li><strong>内核将数据从内核空间拷贝到用户空间。</strong></li></ol><h3 id="有哪些常见的-IO-模型"><a href="#有哪些常见的-IO-模型" class="headerlink" title="有哪些常见的 IO 模型?"></a>有哪些常见的 IO 模型?</h3><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I/O</strong>、<strong>同步非阻塞 I/O</strong>、<strong>I/O 多路复用</strong>、<strong>信号驱动 I/O</strong> 和<strong>异步 I/O</strong>。</p><h3 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h3><h3 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a><strong>BIO (Blocking I/O)</strong></h3><p><strong>BIO 属于</strong>同步阻塞 IO 模型 <strong>。</strong></p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907211637713.png" alt="image-20220907211637713"></p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h3 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a><strong>NIO (Non-blocking/New I/O)</strong></h3><p>Java 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p><strong>Java 中的 NIO 可以看作是 I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>跟着我的思路往下看看，相信你会得到答案！</p><p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907211733470.png" alt="image-20220907211733470"></p><p>同步非阻塞 IO 模型中，应用程序会一直发起 <strong>read</strong> 调用，等待数据<strong>从内核空间拷贝到用户空间</strong>的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。<strong>通过轮询操作，避免了一直阻塞。</strong></p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的</strong>。</p><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907211839332.png" alt="image-20220907211839332"></p><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，目前几乎在所有的操作系统上都有支持。</p><ul><li><strong>select 调用</strong> ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li><strong>epoll 调用</strong> ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907212117819.png" alt="image-20220907212117819"></p><h3 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h3><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是<strong>异步 IO 模型</strong>。</p><p>异步 IO 是基于<strong>事件和回调机制</strong>实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907212236794.png" alt="image-20220907212236794"></p><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907212354609.png" alt="image-20220907212354609"></p><h2 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h2><p>方法 1：通过 <code>Scanner</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span>  <span class="hljs-operator">=</span> input.nextLine();<br>input.close();<br></code></pre></td></tr></table></figure><p>方法 2：通过 <code>BufferedReader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> input.readLine();<br></code></pre></td></tr></table></figure><h2 id="IO流用到了什么设计模式？"><a href="#IO流用到了什么设计模式？" class="headerlink" title="IO流用到了什么设计模式？"></a>IO流用到了什么设计模式？</h2><p>其实，Java的IO流体系还用到了一个设计模式—— <strong>装饰器模式</strong> 。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907212756379.png" alt="image-20220907212756379"></p><h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a><strong>序列化</strong></h1><h3 id="什么是序列化-什么是反序列化"><a href="#什么是序列化-什么是反序列化" class="headerlink" title="什么是序列化?什么是反序列化?"></a>什么是序列化?什么是反序列化?</h3><p>如果我们需要<strong>持久化 Java 对象</strong>比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p><p>简单来说：</p><ul><li><strong>序列化：</strong> <strong>将数据结构或对象转换成二进制字节流的过程</strong></li><li><strong>反序列化：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</strong></li></ul><p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p><p>维基百科是如是介绍序列化的：</p><p>序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。 </p><p>综上：<strong>序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中</strong>。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907212950852.png" alt="image-20220907212950852"></p><h3 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 <strong>transient</strong> 关键字修饰。</p><p>transient 关键字的作用是：<strong>阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</strong></p><p>关于 transient 还有几点注意：</p><ul><li>transient 只能<strong>修饰变量，</strong>不能修饰类和方法。</li><li>transient 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 int 类型，那么反序列后结果就是 0。</li><li>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li></ul><h3 id="Serializable接口有什么用？"><a href="#Serializable接口有什么用？" class="headerlink" title="Serializable接口有什么用？"></a>Serializable接口有什么用？</h3><p>这个接口只是一个标记，没有具体的作用，但是如果不实现这个接又，在有些序列化场景会报错，所以一般建议，创建的JavaBean类都实现 Serializable。</p><h3 id="serialVersionUID-又有什么用？"><a href="#serialVersionUID-又有什么用？" class="headerlink" title="serialVersionUID 又有什么用？"></a>serialVersionUID 又有什么用？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br></code></pre></td></tr></table></figure><p>serialVersionUID 就是起验证作用。</p><p>我们经常会看到这样的代码，这个 ID 其实就是用来验证序列化的对象和反序列化对应的对象ID 是否一致。</p><p>这个 ID 的数字其实不重要，无论是 1L 还是 IDE自动生成的，只要序列化时候对象的serialVersionUID 和反序列化时候对象的 serialVersionUID 一致的话就行。</p><p>如果没有显示指定 serialVersionUID ，则编译器会根据类的相关信息自动生成一个，可以认为是一个指纹。</p><p>所以如果你没有定义一个 serialVersionUID， 结果序列化一个对象之后，在反序列化之前把对象的类的结构改了，比如增加了一个成员变量，则此时的反序列化会失败。</p><p>因为类的结构变了，所以 serialVersionUID 就不一致。</p><h3 id="Java-序列化不包含静态变量？"><a href="#Java-序列化不包含静态变量？" class="headerlink" title="Java 序列化不包含静态变量？"></a>Java 序列化不包含静态变量？</h3><p>序列化的时候是不包含静态变量的。</p><h3 id="说说有几种序列化方式？"><a href="#说说有几种序列化方式？" class="headerlink" title="说说有几种序列化方式？"></a>说说有几种序列化方式？</h3><p>Java序列化方式有很多，常见的有三种：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907213807214.png" alt="image-20220907213807214"></p><ul><li>Java对象流列化 ：Java原生序列化方法即通过Java原生流(InputStream和OutputStream之间的转化)的方式进行转化，一般是对象输出流 ObjectOutputStream 和对象输入流ObjectInputStream 。</li><li>Json序列化：这个可能是我们最常用的序列化方式，Json序列化的选择很多，一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。</li><li>ProtoBuff序列化：ProtocolBuffer是一种轻便高效的结构化数据存储格式，ProtoBuff序列化对象可以很大程度上将其压缩，可以大大减少数据传输大小，提高系统性能。</li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h1><h2 id="Java的异常机制"><a href="#Java的异常机制" class="headerlink" title="Java的异常机制"></a>Java的异常机制</h2><p><strong>关于异常处理：</strong></p><p>在Java中，处理异常的语句由<strong>try、catch、finally</strong>三部分组成。其中，<strong>try块用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally块则用于回收资源</strong>。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。</p><p><strong>关于抛出异常：</strong></p><p>当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用<strong>throw</strong>关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过<strong>throws</strong>关键字声明抛出异常，则该异常将交给JVM处理。</p><p><strong>关于异常跟踪栈：</strong></p><p>程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息</p><h2 id="Excption与Error"><a href="#Excption与Error" class="headerlink" title="Excption与Error"></a>Excption与Error</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907214913794.png" alt="image-20220907214913794"></p><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <strong><code>Throwable</code></strong> <strong>类</strong>。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><p><strong>Exception</strong>: 程序本身可以处理的异常，可以通过 catch来进行捕获。<strong>Exception</strong>又可以分为 <strong>Checked Exception (受检查异常，必须处理)**和 **Unchecked Exception (不受检查异常，可以不处理)。</strong></p><ul><li><p><strong>Unchecked Exception</strong>：</p><ul><li><p><strong>NullPointerException：空指针异常；</strong>  </p></li><li><p><strong>ArithmeticException：算数异常；</strong>  </p></li><li><p><strong>ArrayIndexOutOfBoundsException：数组下标越界异常；</strong>  </p></li><li><p><strong>ClassCastException：类型转换异常。</strong></p></li></ul></li><li><p><strong>Checked Exception</strong>：</p><ul><li><strong>IOException：IO 异常</strong></li><li><strong>SQLException：SQL 异常</strong></li></ul></li></ul></li><li><p><strong>Error</strong> ：Error属于程序无法处理的错误，我们没办法通过 <code>catch</code> 来进行捕获 。</p><ul><li><strong>Java 虚拟机运行错误（Virtual MachineError）</strong></li><li><strong>虚拟机内存不够错误(<code>OutOfMemoryError</code>)</strong></li><li><strong>类定义错误（NoClassDefFoundError）</strong> </li></ul></li></ul><h2 id="Throwable-类常用方法有哪些？"><a href="#Throwable-类常用方法有哪些？" class="headerlink" title="Throwable 类常用方法有哪些？"></a>Throwable 类常用方法有哪些？</h2><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h2 id="说说你平时是怎么处理-Java-异常的？"><a href="#说说你平时是怎么处理-Java-异常的？" class="headerlink" title="说说你平时是怎么处理 Java 异常的？"></a><strong>说说你平时是怎么处理 Java 异常的？</strong></h2><p><strong>try-catch-finally</strong></p><ol><li><p><strong>捕获异常</strong></p><p>将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。</p></li><li><p><strong>处理异常</strong></p><p>在catch块中处理异常时，应该先记录日志，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。</p></li><li><p><strong>回收资源</strong></p><p>如果业务代码打开了某个资源，比如数据库连接、网络连接、磁盘文件等，则需要在这段业务代码执行完毕后关闭这项资源。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。</p></li></ol><p>其中 try 块是必须的， 阿里内部资料 catch 和 finally 至少存在一个标准异常处理流程</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907220715855.png" alt="image-20220907220715855"></p><p>抛出异常→捕获异常→捕获成功（当 catch 的异常类型与抛出的异常类型匹配时，捕获成功） →异常被处理，程序继续运行 抛出异常→捕获异常→捕获失败（当 catch 的异常类型与抛出异 常类型不匹配时，捕获失败）→异常未被处理，程序中断运行。</p><p>在开发过程中会使用到自定义异常，在通常情况下，程序很少会自己抛出异常，因为异常的类名通常也包含了该异常的有用信息，所以在选择抛出异常的时候，应该选择合适的异常类，从而可以明确地描述该异常情况，所以这时候往往都是自定义异常。 自定义异常通常是通过继承 java.lang.Exception 类，如果想自定义 Runtime 异常的话，可以继承 java.lang.RuntimeException类，实现一个无参构造和一个带字符串参数的有参构造方法。 在业务代码里，可以针对性的使用自定义异常。比如说：该用户不具备某某权限、余额不足等。</p><h2 id="try-catch-finally，try里有return，finally还执行么？"><a href="#try-catch-finally，try里有return，finally还执行么？" class="headerlink" title="try catch finally，try里有return，finally还执行么？"></a><strong>try catch finally，try里有return，finally还执行么？</strong></h2><p>执行，并且finally的执行早于try里面的return</p><p>结论：</p><ul><li>1、不管有木有出现异常，finally块中代码都会执行； </li><li>2、当try和catch中有return时，finally仍然会执行； </li><li>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的 值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数 返回值是在finally执行前确定的； </li><li>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li></ul><p><strong>注意事项</strong></p><p>如果在try块或catch块中使用 System.exit(1); 来退出虚拟机，则finally块将失去执行的机会。但是我们在实际的开发中，重来都不会这样做，所以尽管存在这种导致finally块无法执行的可能，也只是一种可能而已。</p><h2 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 try-with-resources 代替try-catch-finally？</h2><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</p><p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</p><p>《Effective Java》中明确指出：</p><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。 </p><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//读取文本文件的内容</span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    scanner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D://read.txt&quot;</span>));<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>    e.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (scanner != <span class="hljs-literal">null</span>) &#123;<br>        scanner.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>))) &#123;<br>    <span class="hljs-keyword">while</span> (scanner.hasNext()) &#123;<br>        System.out.println(scanner.nextLine());<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException fnfe) &#123;<br>    fnfe.printStackTrace();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedInputStream</span> <span class="hljs-variable">bin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;test.txt&quot;</span>)));<br>             <span class="hljs-type">BufferedOutputStream</span> <span class="hljs-variable">bout</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;out.txt&quot;</span>)))) &#123;<br>            <span class="hljs-type">int</span> b;<br>            <span class="hljs-keyword">while</span> ((b = bin.read()) != -<span class="hljs-number">1</span>) &#123;<br>                bout.write(b);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br></code></pre></td></tr></table></figure><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a><strong>动态代理</strong></h1><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><p><strong>代理模式的主要作用是</strong>扩展目标对象的功能<strong>，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p><p><strong>举个例子：你找了小红来帮你问话，小红就可以看作是代理你的代理对象，代理的行为（方法）是问话。</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%9F%BA%E7%A1%80/image-20220907221423842.png" alt="image-20220907221423842"></p><p>代理模式有静态代理和动态代理两种实现方式，我们 先来看一下静态代理模式的实现。</p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（*后面会具体演示代码*），非常不灵活（*比如接口一旦新增加方法，目标对象和代理对象都要进行修改*）且麻烦(*需要对每个目标类都单独写一个代理类*)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p><p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p><p><strong>静态代理实现步骤:</strong></p><ul><li><strong>定义一个接口及其实现类；</strong></li><li><strong>创建一个代理类同样实现这个接口</strong></li><li><strong>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</strong></li></ul><p>下面通过代码展示！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SmsService smsService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SmsProxy</span><span class="hljs-params">(SmsService smsService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.smsService = smsService;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method send()&quot;</span>);<br>        smsService.send(message);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method send()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SmsService</span> <span class="hljs-variable">smsService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsServiceImpl</span>();<br>        <span class="hljs-type">SmsProxy</span> <span class="hljs-variable">smsProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsProxy</span>(smsService);<br>        smsProxy.send(<span class="hljs-string">&quot;java&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">before <span class="hljs-keyword">method</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span><br><span class="hljs-title function_">send</span> <span class="hljs-title function_">message</span>:java<br>after <span class="hljs-keyword">method</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>可以输出结果看出，我们已经增加了 <code>SmsServiceImpl</code> 的<code>send()</code>方法。</p><h2 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h2><p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p><p>**说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。<br>**</p><p><strong>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p><p><strong>就 Java 来说，动态代理的实现方式有很多种，比如 JDK 动态代理、CGLIB 动态代理等等。</strong></p><p>guide-rpc-framework<a href="https://github.com/Snailclimb/guide-rpc-framework"> </a> (opens new window) 使用的是 JDK 动态代理，我们先来看看 JDK 动态代理的使用。</p><p>另外，虽然 guide-rpc-framework<a href="https://github.com/Snailclimb/guide-rpc-framework"> </a> (opens new window) 没有用到 CGLIB 动态代理，我们这里还是简单介绍一下其使用以及和JDK 动态代理的对比。</p><h3 id="JDK-动态代理机制"><a href="#JDK-动态代理机制" class="headerlink" title="JDK 动态代理机制"></a>JDK 动态代理机制</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p><p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span><br><span class="hljs-params">                                      Class&lt;?&gt;[] interfaces,</span><br><span class="hljs-params">                                      InvocationHandler h)</span><br>    <span class="hljs-keyword">throws</span> IllegalArgumentException<br>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法一共有 3 个参数：</p><ul><li><strong>loader</strong> :类加载器，用于加载代理对象。</li><li><strong>interfaces</strong> : 被代理类实现的一些接口；</li><li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li></ul><p><strong>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span><br>        <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br></code></pre></td></tr></table></figure><p>**<code>invoke()</code> 方法有下面三个参数： **</p><ul><li><p><strong>proxy:动态生成的代理类</strong> </p></li><li><p><strong>method : 与代理类对象调用的方法相对应</strong> </p></li><li><p><strong>args : 当前 method 方法的参数</strong></p></li></ul><p>也就是说：你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。 </p><h4 id="JDK-动态代理类使用步骤"><a href="#JDK-动态代理类使用步骤" class="headerlink" title="JDK 动态代理类使用步骤"></a>JDK 动态代理类使用步骤</h4><ul><li><strong>定义一个接口及其实现类；</strong></li><li><strong>自定义</strong> <strong><code>InvocationHandler</code></strong> <strong>并重写</strong><code>invoke</code><strong>方法，在</strong> <strong><code>invoke</code></strong> <strong>方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</strong></li><li><strong>通过</strong> <strong><code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></strong> <strong>方法创建代理对象；</strong></li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>这样说可能会有点空洞和难以理解，我上个例子，大家感受一下吧！</p><p><strong>1.定义发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.实现发送短信的接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SmsService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.定义一个 JDK 动态代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月11日 11:23:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理类中的真实对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException &#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p><p><strong>4.获取代理对象的工厂类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkProxyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>                target.getClass().getClassLoader(), <span class="hljs-comment">// 目标类的类加载</span><br>                target.getClass().getInterfaces(),  <span class="hljs-comment">// 代理需要实现的接口，可指定多个</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugInvocationHandler</span>(target)   <span class="hljs-comment">// 代理对象对应的自定义 InvocationHandler</span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p><p><strong>5.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SmsService</span> <span class="hljs-variable">smsService</span> <span class="hljs-operator">=</span> (SmsService) JdkProxyFactory.getProxy(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SmsServiceImpl</span>());<br>smsService.send(<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">before method send<br>send message:java<br>after method send<br></code></pre></td></tr></table></figure><h3 id="CGLIB-动态代理机制"><a href="#CGLIB-动态代理机制" class="headerlink" title="CGLIB 动态代理机制"></a>CGLIB 动态代理机制</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p><p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p><p>CGLIB<a href="https://github.com/cglib/cglib"> </a> (opens new window)(Code Generation Library)是一个基于ASM<a href="http://www.baeldung.com/java-asm"> </a> (opens new window)的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了CGLIB<a href="https://github.com/cglib/cglib"> </a> (opens new window)， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p><strong>在 CGLIB 动态代理机制中</strong> <code>MethodInterceptor</code> <strong>接口和</strong> <code>Enhancer</code> <strong>类是核心。</strong></p><p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Callback</span>&#123;<br>    <span class="hljs-comment">// 拦截被代理类中的方法</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, java.lang.reflect.Method method, Object[] args,MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>obj</strong> :被代理的对象（需要增强的对象）</li><li><strong>method</strong> :被拦截的方法（需要增强的方法）</li><li><strong>args</strong> :方法入参</li><li><strong>proxy</strong> :用于调用原始方法</li></ol><p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p><h4 id="CGLIB-动态代理类使用步骤"><a href="#CGLIB-动态代理类使用步骤" class="headerlink" title="CGLIB 动态代理类使用步骤"></a>CGLIB 动态代理类使用步骤</h4><ul><li><p><strong>定义一个类；</strong></p></li><li><p><strong>自定义</strong> <strong><code>MethodInterceptor</code></strong> <strong>并重写</strong> <strong><code>intercept</code></strong> <strong>方法，</strong><code>intercept</code> <strong>用于拦截增强被代理类的方法，和 JDK 动态代理中的</strong> <strong><code>invoke</code></strong> 方法类似；</p></li><li><p><strong>通过</strong> <strong><code>Enhancer</code></strong> <strong>类的</strong> **<code>create()</code>**创建代理类；</p></li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>不同于 JDK 动态代理不需要额外的依赖。CGLIB<a href="https://github.com/cglib/cglib"> </a> (opens new window)(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>1.实现一个使用阿里云发送短信的类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AliSmsService</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">send</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义MethodInterceptor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o           代理对象（增强的对象）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method      被拦截的方法（需要增强的方法）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args        方法入参</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy 用于调用原始方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(o, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.获取代理类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        <span class="hljs-type">Enhancer</span> <span class="hljs-variable">enhancer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DebugMethodInterceptor</span>());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.实际使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AliSmsService</span> <span class="hljs-variable">aliSmsService</span> <span class="hljs-operator">=</span> (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);<br>aliSmsService.send(<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure><p>运行上述代码之后，控制台打印出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">before method send<br>send message:java<br>after method send<br></code></pre></td></tr></table></figure><h3 id="JDK-动态代理和-CGLIB-动态代理对比"><a href="#JDK-动态代理和-CGLIB-动态代理对比" class="headerlink" title="JDK 动态代理和 CGLIB 动态代理对比"></a>JDK 动态代理和 CGLIB 动态代理对比</h3><p><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类</strong>。 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p><p>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p><h2 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h2><p><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</p><p><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试-Java并发编程</title>
    <link href="/weiblog/2022/09/02/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/weiblog/2022/09/02/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h2><p>先从总体上来说：</p><ul><li><p><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p></li><li><p><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而<strong>多线程并发编程</strong>正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p></li></ul><p>再深入到计算机底层来探讨：</p><ul><li><p><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</p></li><li><p><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</p></li></ul><h2 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。</p><h2 id="并行跟并发有什么区别？"><a href="#并行跟并发有什么区别？" class="headerlink" title="并行跟并发有什么区别？"></a>并行跟并发有什么区别？</h2><p>从操作系统的角度来看，线程是CPU分配的最小单位。</p><ul><li>并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。</li><li>并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。</li></ul><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114109343.png" alt="image-20220902114109343"></p><p>就好像我们去食堂打饭，并行就是我们在多个窗又排队，几个阿姨同时打菜；并发就是我们挤在一个窗又，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114143558.png" alt="image-20220902114143558"></p><h2 id="说说什么是进程和线程？"><a href="#说说什么是进程和线程？" class="headerlink" title="说说什么是进程和线程？"></a>说说什么是进程和线程？</h2><p>要说线程，必须得先说说进程。</p><ul><li>进程：进程是代码在数据集合上的一次运行活动，是<strong>系统进行资源分配和调度的基本单位</strong>。</li><li>线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</li></ul><p>操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。</p><p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p><p>一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140118921.png"></p><h2 id="说说线程有几种创建方式"><a href="#说说线程有几种创建方式" class="headerlink" title="说说线程有几种创建方式"></a>说说线程有几种创建方式</h2><p>Java中创建线程主要有三种方式，分别为继承<strong>Thread</strong>类、实现<strong>Runnable</strong>接口、实现<strong>Callable</strong>接口。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140459345.png"></p><ul><li><h3 id="继承Thread类，重写run-方法，调用start-方法启动线程"><a href="#继承Thread类，重写run-方法，调用start-方法启动线程" class="headerlink" title="继承Thread类，重写run()方法，调用start()方法启动线程"></a>继承Thread类，重写run()方法，调用start()方法启动线程</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    继承Thread类</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;This is child thread&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h3 id="实现-Runnable-接口，重写run-方法"><a href="#实现-Runnable-接口，重写run-方法" class="headerlink" title="实现 Runnable 接口，重写run()方法"></a>实现 Runnable 接口，重写run()方法</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Runnable!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RunnableTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableTask</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？</p><ul><li><h3 id="实现Callable接又，重写call-方法，这种方式可以通过FutureTask获取任务执行的返回值"><a href="#实现Callable接又，重写call-方法，这种方式可以通过FutureTask获取任务执行的返回值" class="headerlink" title="实现Callable接又，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值"></a>实现Callable接又，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,i am running!&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>                <span class="hljs-comment">//创建异步任务</span><br>                FutureTask&lt;String&gt; task=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallerTask</span>());<br>                <span class="hljs-comment">//启动线程</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//等待执行完成，并获取返回结果</span><br>                String result=task.get();<br>                System.out.println(result);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？"><a href="#为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？" class="headerlink" title="为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？"></a>为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？</h2><p>JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141434005.png"></p><p><strong>为什么我们不能直接调用run()方法？</strong> 也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。</p><h2 id="线程有哪些常用的调度方法？"><a href="#线程有哪些常用的调度方法？" class="headerlink" title="线程有哪些常用的调度方法？"></a>线程有哪些常用的调度方法？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141608203.png" alt="image-20220902141608203"></p><h3 id="线程等待与通知"><a href="#线程等待与通知" class="headerlink" title="线程等待与通知"></a>线程等待与通知</h3><p>在Object类中有一些函数可以用于线程的等待与通知。</p><ul><li><p>**wait()**：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：</p><ul><li><p>（ 1 ） 线程A调用了共享对象 notify()或者 notifyAll()方法；</p></li><li><p>（ 2 ）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</p></li></ul></li><li><p><strong>wait(long timeout)</strong> ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。</p></li><li><p>**wait(long timeout, int nanos)**，其内部调用的是 wait(long timout）函数。</p></li></ul><p>上面是线程等待的方法，而唤醒线程主要是下面两个方法：</p><ul><li><strong>notify()</strong> : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</li><li><strong>notifyAll()</strong> ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li></ul><p>Thread类也提供了一个方法用于等待的方法：</p><ul><li>**join()**：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。</li></ul><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul><li><strong>sleep(long millis)</strong> :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</li></ul><h3 id="让出优先权"><a href="#让出优先权" class="headerlink" title="让出优先权"></a>让出优先权</h3><ul><li><strong>yield()</strong> ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。</li></ul><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p><ul><li><strong>void interrupt()</strong> ：中断线程，例如，当线程A运行时，线程B可以调用钱程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。</li><li><strong>boolean isInterrupted() 方法</strong>： 检测当前线程是否被中断。</li><li><strong>boolean interrupted() 方法</strong>： 检测当前线程是否被中断，与 <strong>isInterrupted</strong> 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li></ul><h2 id="线程有几种状态？"><a href="#线程有几种状态？" class="headerlink" title="线程有几种状态？"></a>线程有几种状态？</h2><p>在Java中，线程共有六种状态：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902145605462.png" alt="image-20220902145605462"></p><p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160048587.png" alt="image-20220902160048587"></p><h2 id="什么是线程上下文切换？"><a href="#什么是线程上下文切换？" class="headerlink" title="什么是线程上下文切换？"></a>什么是线程上下文切换？</h2><p>使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。<img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160358011.png" alt="image-20220902160358011"></p><p>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160517970.png" alt="image-20220902160517970"></p><h2 id="守护线程了解吗？"><a href="#守护线程了解吗？" class="headerlink" title="守护线程了解吗？"></a>守护线程了解吗？</h2><ul><li>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。</li><li>在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。</li><li>那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。</li></ul><h2 id="线程间有哪些通信方式？"><a href="#线程间有哪些通信方式？" class="headerlink" title="线程间有哪些通信方式？"></a>线程间有哪些通信方式？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160908374.png" alt="image-20220902160908374"></p><h3 id="volatile和synchronized关键字"><a href="#volatile和synchronized关键字" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h3><ul><li><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p></li><li><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p></li></ul><h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a><strong>等待/通知机制</strong></h3><ul><li>可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</li></ul><h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a><strong>管道输入/输出流</strong></h3><ul><li><p><strong>管道输入/输出流</strong>和<strong>普通的文件输入/输出流</strong>或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p></li><li><p>管道输入/输出流主要包括了如下 4 种具体实现：<strong>PipedOutputStream、PipedInputStream、PipedReader和PipedWriter</strong>，前两种面向字节，而后两种面向字符。</p></li></ul><h3 id="使用Thread-join"><a href="#使用Thread-join" class="headerlink" title="使用Thread.join()"></a>使用Thread.join()</h3><ul><li>如果一个线程A执行了<strong>thread.join()**语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了</strong>join(long millis)<strong>和</strong>join(long millis,int nanos)**两个具备超时特性的方法。</li></ul><h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><ul><li><p><strong>ThreadLocal</strong>，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p></li><li><p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p></li></ul><h2 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul><li><p>两者最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</p></li><li><p>两者都可以<strong>暂停线程</strong>的执行。</p></li><li><p><strong>wait()</strong> 通常被用于线程间交互/通信，<strong>sleep()</strong> 通常被用于暂停执行。</p></li><li><p><strong>wait()</strong> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <strong>notify()</strong> 或者 <strong>notifyAll()</strong> 方法。<strong>sleep()</strong> 方法执行完成后，线程会自动苏醒。或者可以使用 <strong>wait(long timeout)</strong> 超时后线程会自动苏醒。</p></li></ul><h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用：</p><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。<br>在多线程的情况下，<strong>程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>需要注意的是，如果执行的是 <strong>native</strong> 方法，那么程序计数器记录的是 <strong>undefined</strong> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，<strong>程序计数器私有主要是为了线程切换后能恢复到正确的执行位置</strong>。</p><h2 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h2><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个<strong>栈帧</strong>用于存储<strong>局部变量表、操作数栈、常量池</strong>引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是<strong>线程私有的</strong>。</p><h2 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2019-4%E6%AD%BB%E9%94%811.png" alt="线程死锁示意图 "></p><p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 2</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource1<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource2<br>Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource2<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource1<br></code></pre></td></tr></table></figure><p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p>上面的例子符合产生死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h3><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p><ol><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p><strong>如何避免死锁？</strong></p><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><blockquote><p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></blockquote><p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource1<br>Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource2<br>Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource2<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource1<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource2<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource2<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们分析一下上面的代码为什么避免了死锁的发生?</p><p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902163020732.png" alt="image-20220902163020732"></p><ul><li><p>创建</p><p>创建了一个<strong>ThreadLocal</strong>变量<strong>localVariable</strong>，任何一个线程都能并发访问<strong>localVariable</strong>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个ThreadLocal变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li><p>写入</p><p>线程可以在任何地方使用<strong>localVariable</strong>，写入变量。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">localVariable.set(<span class="hljs-string">&quot;鄙人三某”);</span><br></code></pre></td></tr></table></figure><ul><li>读取<br>线程在任何地方读取的都是它写入的变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">localVariable.get();<br></code></pre></td></tr></table></figure><h2 id="你在工作中用到过ThreadLocal吗？"><a href="#你在工作中用到过ThreadLocal吗？" class="headerlink" title="你在工作中用到过ThreadLocal吗？"></a>你在工作中用到过ThreadLocal吗？</h2><p>有用到过的，用来做用户信息上下文的存储。</p><p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接又，都会在请求头中携带</p><p>一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p><p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p><p>这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取ThreadLocal中存的用户数据。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902170811800.png" alt="image-20220902170811800"></p><p>很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。</p><p>我们常用的数据库连接池也用到了ThreadLocal：</p><ul><li>数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。</li></ul><h2 id="ThreadLocal怎么实现的呢？"><a href="#ThreadLocal怎么实现的呢？" class="headerlink" title="ThreadLocal怎么实现的呢？"></a>ThreadLocal怎么实现的呢？</h2><p>我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取ThreadLocalMap，然后把元素存到这个map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//获取ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//讲当前元素存入map</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>    map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ThreadLocal</strong>实现的秘密都在这个<strong>ThreadLocalMap</strong>了，Thread类中定义了一个类型为<strong>ThreadLocal.ThreadLocalMap</strong>的成员变量<strong>threadLocals</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">//ThreadLocal.ThreadLocalMap是Thread的属性</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocalMap既然被称为Map，那么毫无疑问它是&lt;key,value&gt;型的数据结构。我们都知道map的本质是一个个&lt;key,value&gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br>    <span class="hljs-comment">//节点类</span><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-comment">//key赋值</span><br>        <span class="hljs-built_in">super</span>(k);<br>        <span class="hljs-comment">//value赋值</span><br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个 <strong>弱引用</strong> ，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">WeakReference</span><span class="hljs-params">(T referent)</span> &#123;<br><span class="hljs-built_in">super</span>(referent);<br>&#125;<br></code></pre></td></tr></table></figure><p>key的赋值，使用的是WeakReference的赋值。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902173027266.png" alt="image-20220902173027266"></p><p>所以，怎么回答ThreadLocal原理？要答出这几个点：</p><ul><li>Thread类有一个类型为<strong>ThreadLocal.ThreadLocalMap</strong>的实例变量<strong>threadLocals</strong>，每个线程都有一个属于自己的<strong>ThreadLocalMap</strong>。</li><li><strong>ThreadLocalMap</strong>内部维护着Entry数组，每个Entry代表一个完整的对象，key是<strong>ThreadLocal的弱引用</strong>，value是<strong>ThreadLocal的泛型值</strong>。</li><li>每个线程在往<strong>ThreadLocal</strong>里设置值的时候，都是往自己的<strong>ThreadLocalMap</strong>里存，读也是以某个<strong>ThreadLocal</strong>作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li><li>ThreadLocal本身不存储值，它只是作为一个<strong>key</strong>来让线程往<strong>ThreadLocalMap</strong>里存取值。</li></ul><h2 id="ThreadLocal-内存泄露是怎么回事？"><a href="#ThreadLocal-内存泄露是怎么回事？" class="headerlink" title="ThreadLocal 内存泄露是怎么回事？"></a>ThreadLocal 内存泄露是怎么回事？</h2><p>我们先来分析一下使用<strong>ThreadLocal</strong>时的内存，我们都知道，在<strong>JVM</strong>中，<strong>栈内存线程私有</strong>，存储了对象的引用，<strong>堆内存线程共享</strong>，存储了对象实例。</p><p>所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902193325147.png" alt="image-20220902193325147"></p><p><strong>ThreadLocalMap</strong>中使用的 key 为 <strong>ThreadLocal</strong> 的弱引用。</p><p><em>“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”</em></p><p>那么现在问题就来了，弱引用很容易被回收，如果<strong>ThreadLocal（ThreadLocalMap的Key）</strong>被垃圾回收器回收了，但是<strong>ThreadLocalMap</strong>生命周期和<strong>Thread</strong>是一样的，它这时候如果不被回收，就会出现这种情况：<strong>ThreadLocalMap</strong>的<strong>key</strong>没了，<strong>value</strong>还在，这就会 <strong>造成了内存泄漏问题</strong> 。</p><h2 id="那怎么解决内存泄漏问题呢？"><a href="#那怎么解决内存泄漏问题呢？" class="headerlink" title="那怎么解决内存泄漏问题呢？"></a>那怎么解决内存泄漏问题呢？</h2><p>很简单，使用完<strong>ThreadLocal</strong>后，及时调用<strong>remove</strong>()方法释放内存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>    localVariable.set(<span class="hljs-string">&quot;鄙人三某”);</span><br><span class="hljs-string">    ......</span><br><span class="hljs-string">    &#125; finally &#123;</span><br><span class="hljs-string">    localVariable.remove();</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>那为什么key还要设计成弱引用？</p><p>key设计成弱引用同样是为了防止内存泄漏。</p><p>假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。</p><h2 id="ThreadLocalMap的结构了解吗？"><a href="#ThreadLocalMap的结构了解吗？" class="headerlink" title="ThreadLocalMap的结构了解吗？"></a>ThreadLocalMap的结构了解吗？</h2><p>ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接又的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：<strong>元素数组和散列方法。</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902194739313.png" alt="image-20220902194739313"></p><p><strong>元素数组</strong></p><p>一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry[] table;<br></code></pre></td></tr></table></figure><p><strong>散列方法</strong></p><p>散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;运算（相当于取余）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span> );<br></code></pre></td></tr></table></figure><p>这里的<strong>threadLocalHashCode</strong>计算有点东西，每创建一个<strong>ThreadLocal</strong>对象，它就会新增<strong>0x61c88647</strong>，这个值很特殊，它是 <strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong> 。hash增量为 这个数字，带来的好处就是 hash <strong>分布非常均匀</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocalMap怎么解决Hash冲突的？"><a href="#ThreadLocalMap怎么解决Hash冲突的？" class="headerlink" title="ThreadLocalMap怎么解决Hash冲突的？"></a>ThreadLocalMap怎么解决Hash冲突的？</h2><p>我们可能都知道<strong>HashMap</strong>使用了链表来解决冲突，也就是所谓的链地址法。</p><p><strong>ThreadLocalMap</strong>没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式—— <strong>开放定址法</strong> 。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902212750305.png" alt="image-20220902212750305"></p><p>如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。</p><p>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</p><h2 id="ThreadLocalMap扩容机制了解吗？"><a href="#ThreadLocalMap扩容机制了解吗？" class="headerlink" title="ThreadLocalMap扩容机制了解吗？"></a>ThreadLocalMap扩容机制了解吗？</h2><p>在<strong>ThreadLocalMap.set()**方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中</strong>Entry<strong>的数量已经达到了列表的扩容阈值</strong>(len*2/3)<strong>，就开始执行</strong>rehash()**逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>rehash();<br></code></pre></td></tr></table></figure><p>再着看<strong>rehash</strong>()具体实现：这里会先去清理过期的<strong>Entry</strong>，然后还要根据条件判断<strong>size &gt;=threshold - threshold / 4</strong> 也就是*<em>size &gt;= threshold</em> 3/4**来决定是否需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//清理过期Entry</span><br>        expungeStaleEntries();<br>        <span class="hljs-comment">//扩容</span><br>        <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span> )<br>        resize();<br>    &#125;<br>    <span class="hljs-comment">//清理过期Entry</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>        Entry[] tab = table;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)<br>        expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着看看具体的<strong>resize</strong>()方法，扩容后的<strong>newTab</strong>的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的newTab，遍历完成之后，<strong>oldTab</strong>中所有的<strong>entry</strong>数据都已经放入到<strong>newTab</strong>中了，然后table引用指向<strong>newTab</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213343066.png" alt="image-20220902213343066"></p><p>具体代码：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213432939.png" alt="image-20220902213432939"></p><h2 id="父子线程怎么共享数据"><a href="#父子线程怎么共享数据" class="headerlink" title="父子线程怎么共享数据"></a>父子线程怎么共享数据</h2><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p><p>这时候可以用到另外一个类——<strong>InheritableThreadLocal</strong>。</p><p>使用起来很简单，在主线程的<strong>InheritableThreadLocal</strong>实例设置值，在子线程中就可以拿到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">threadLocal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>();<br>            <span class="hljs-comment">// 主线程</span><br>            threadLocal.set(<span class="hljs-string">&quot;不擅技术&quot;</span>);<br>            <span class="hljs-comment">//子线程</span><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.run();<br>            System.out.println(<span class="hljs-string">&quot;鄙人三某 ，&quot;</span> + threadLocal.get());<br>            &#125;<br>        &#125;;<br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="那原理是什么呢？"><a href="#那原理是什么呢？" class="headerlink" title="那原理是什么呢？"></a>那原理是什么呢？</h4><p>原理很简单，在Thread类里还有另外一个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>在<strong>Thread.init</strong>的时候，如果父线程的<strong>inheritableThreadLocals</strong>不为空，就把它赋给当前线程（子线程）的<strong>inheritableThreadLocals</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>)<br><span class="hljs-built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br></code></pre></td></tr></table></figure><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="说一下你对Java内存模型（JMM）的理解？"><a href="#说一下你对Java内存模型（JMM）的理解？" class="headerlink" title="说一下你对Java内存模型（JMM）的理解？"></a>说一下你对Java内存模型（JMM）的理解？</h2><p>Java内存模型（<strong>Java Memory Model</strong>，JMM），是一种<strong>抽象的模型</strong>，被定义出来屏蔽各种硬件和操作系统的<strong>内存访问差异</strong>。</p><p>JMM定义了<strong>线程和主内存</strong>之间的抽象关系：线程之间的<strong>共享变量</strong>存储在主内存（<strong>Main Memory</strong>）中，每个线程都有一个私有的本地内存（<strong>Local Memory</strong>），本地内存中存储了该线程<strong>以读/写共享变量的副本</strong>。</p><p>Java内存模型的抽象图：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114356751.png" alt="image-20220903114356751"></p><p>本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114449779.png" alt="image-20220903114449779"></p><p>图里面的是一个<strong>双核 CPU 系统架构</strong> ，每个核有自己的<strong>控制器和运算器</strong>，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的<strong>一级缓存</strong>，在有些架构里面还有一个<strong>所有 CPU 共享的二级缓存</strong>。 那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。</p><h2 id="说说你对原子性、可见性、有序性的理解"><a href="#说说你对原子性、可见性、有序性的理解" class="headerlink" title="说说你对原子性、可见性、有序性的理解"></a>说说你对原子性、可见性、有序性的理解</h2><p>原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。</p><ul><li><strong>原子性</strong>：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。</li><li><strong>可见性</strong>：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。</li><li><strong>有序性</strong>：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。</li></ul><h3 id="分析下面几行代码的原子性？"><a href="#分析下面几行代码的原子性？" class="headerlink" title="分析下面几行代码的原子性？"></a>分析下面几行代码的原子性？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>i++;<br>i = i + <span class="hljs-number">1</span> ;<br></code></pre></td></tr></table></figure><ul><li>第 1 句是基本类型赋值，是原子性操作。</li><li>第 2 句先读i的值，再赋值到j，两步操作，不能保证原子性。</li><li>第 3 和第 4 句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</li></ul><h3 id="原子性、可见性、有序性都应该怎么保证呢？"><a href="#原子性、可见性、有序性都应该怎么保证呢？" class="headerlink" title="原子性、可见性、有序性都应该怎么保证呢？"></a>原子性、可见性、有序性都应该怎么保证呢？</h3><ul><li><strong>原子性</strong>：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<strong>synchronized</strong> 。</li><li><strong>可见性</strong>：Java是利用<strong>volatile</strong> 关键字来保证可见性的，除此之外，<strong>final</strong> 和<strong>synchronized</strong> 也能保证可见性。</li><li><strong>有序性</strong>：<strong>synchronized</strong> 或者<strong>volatile</strong> 都可以保证多线程之间操作的有序性。</li></ul><h2 id="那说说什么是指令重排？"><a href="#那说说什么是指令重排？" class="headerlink" title="那说说什么是指令重排？"></a>那说说什么是指令重排？</h2><p>在执行程序时，为了提高性能，<strong>编译器和处理器</strong>常常会对指令做重排序。重排序分 3 种类型。</p><ol><li><p><strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</p></li><li><p><strong>内存系统的重排序</strong>。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ol><p>从Java源代码到最终实际执行的指令序列，会分别经历下面 3 种重排序，如图：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903115952545.png" alt="image-20220903115952545"></p><p>我们比较熟悉的<strong>双重校验单例模式</strong>就是一个经典的指令重排的例子，<strong>Singleton instance=new Singleton()；</strong>对应的JVM指令分为三步：<strong>分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间</strong>，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133213700.png" alt="image-20220903133213700"></p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h2 id="指令重排有限制吗？happens-before了解吗？"><a href="#指令重排有限制吗？happens-before了解吗？" class="headerlink" title="指令重排有限制吗？happens-before了解吗？"></a>指令重排有限制吗？happens-before了解吗？</h2><p>指令重排也是有一些限制的，有两个规则<strong>happens-before和as-if-serial</strong>来约束。</p><p><strong>happens-before</strong>的定义：</p><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><p>happens-before和我们息息相关的有<strong>六大规则</strong>：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133644636.png" alt="image-20220903133644636"></p><ul><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li></ul><h2 id="as-if-serial又是什么？单线程的程序一定是顺序的吗"><a href="#as-if-serial又是什么？单线程的程序一定是顺序的吗" class="headerlink" title="as-if-serial又是什么？单线程的程序一定是顺序的吗"></a>as-if-serial又是什么？单线程的程序一定是顺序的吗</h2><p>as-if-serial语义的意思是：<strong>不管怎么重排序（编译器和处理器为了提高并行度）</strong>， <strong>单线程程序的执行结果不能被改变</strong> 。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>; <span class="hljs-comment">// A</span><br><span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>; <span class="hljs-comment">// B</span><br><span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> pi * r * r; <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure><p>上面 3 个操作的数据依赖关系：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134841710.png" alt="image-20220903134841710"></p><p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。所以最终，程序可能会有两种执行顺序：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134956909.png" alt="image-20220903134956909"></p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。</p><h2 id="volatile实现原理了解吗？"><a href="#volatile实现原理了解吗？" class="headerlink" title="volatile实现原理了解吗？"></a>volatile实现原理了解吗？</h2><p>volatile有两个作用，保证 <strong>可见性</strong> 和 <strong>有序性</strong> 。</p><h3 id="volatile怎么保证可见性的呢？"><a href="#volatile怎么保证可见性的呢？" class="headerlink" title="volatile怎么保证可见性的呢？"></a>volatile怎么保证可见性的呢？</h3><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p><p>volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p><p>例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903135524735.png" alt="image-20220903135524735"></p><h3 id="volatile怎么保证有序性的呢？"><a href="#volatile怎么保证有序性的呢？" class="headerlink" title="volatile怎么保证有序性的呢？"></a>volatile怎么保证有序性的呢？</h3><p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140353177.png" alt="image-20220903140353177"></p><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p><strong>1.</strong> 在每个volatile写操作的前面插入一个StoreStore 屏障<br><strong>2.</strong> 在每个volatile写操作的后面插入一个StoreLoad 屏障<br><strong>3.</strong> 在每个volatile读操作的后面插入一个LoadLoad 屏障<br><strong>4.</strong> 在每个volatile读操作的后面插入一个LoadStore 屏障</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140503354.png" alt="image-20220903140503354"></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140518029.png" alt="image-20220903140518029"></p><h3 id="双重校验锁实现对象单例（线程安全）"><a href="#双重校验锁实现对象单例（线程安全）" class="headerlink" title="双重校验锁实现对象单例（线程安全）"></a>双重校验锁实现对象单例（线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="synchronized用过吗？怎么使用？"><a href="#synchronized用过吗？怎么使用？" class="headerlink" title="synchronized用过吗？怎么使用？"></a>synchronized用过吗？怎么使用？</h2><p>synchronized经常用的，用来保证代码的原子性。</p><p>synchronized主要有三种用法：</p><ul><li><strong>修饰实例方法</strong>: 作用于当前<strong>对象实例</strong>加锁，进入同步代码前要获得 当前对象实例的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>修饰静态方法</strong> ：也就是给<strong>当前类加锁</strong>，会作用于类的所有对象实例 ，进入同步代码前要获得当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> staic <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>修饰代码块</strong> ：<strong>指定加锁对象，对给定对象/类加锁</strong>。 <strong>synchronized(this|object)</strong> 表示进入同步代码库前要获得给定对象的锁。 <strong>synchronized(类.class)</strong> 表示进入同步代码前要获得 当前<strong>class</strong> 的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="synchronized的实现原理？"><a href="#synchronized的实现原理？" class="headerlink" title="synchronized的实现原理？"></a>synchronized的实现原理？</h2><h3 id="synchronized是怎么加锁的呢？"><a href="#synchronized是怎么加锁的呢？" class="headerlink" title="synchronized是怎么加锁的呢？"></a>synchronized是怎么加锁的呢？</h3><p>我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。</p><p><strong>1.</strong> <strong>synchronized修饰代码块时</strong>，JVM采用<strong>monitorenter、monitorexit</strong>两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。反编译一段synchronized修饰代码块代码，<strong>javap -c -s -v -l</strong><br><strong>SynchronizedDemo.class</strong>，可以看到相应的字节码指令。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903180902786.png" alt="image-20220903180902786"></p><p><strong>2.</strong> <strong>synchronized修饰同步方法时</strong>，JVM采用ACC_SYNCHRONIZED标记符来实现同步，这个标识指明了该方法是一个同步方法。<br>同样可以写段代码反编译看一下。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903181654514.png" alt="image-20220903181654514"></p><h3 id="synchronized锁住的是什么呢？"><a href="#synchronized锁住的是什么呢？" class="headerlink" title="synchronized锁住的是什么呢？"></a>synchronized锁住的是什么呢？</h3><p>monitorenter、monitorexit或者ACC_SYNCHRONIZED都是 <strong>基于Monitor实现</strong> 的。</p><p>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了<strong>monitor</strong> 。</p><p>所谓的Monitor其实是一种 <strong>同步工具</strong> ，也可以说是一种 <strong>同步机制</strong> 。在Java虚拟机（HotSpot）中，Monitor是由 <strong>ObjectMonitor实现</strong> 的，可以叫做内部锁，或者Monitor锁。</p><p>ObjectMonitor的工作原理：</p><ul><li>ObjectMonitor有两个队列：WaitSet、EntryList，用来保存ObjectWaiter 对象列表。</li><li>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait()方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入WaitSet 中，等待被唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMonitor() &#123;<br>_header = NULL;<br>_count = <span class="hljs-number">0</span> ; <span class="hljs-comment">// 记录线程获取锁的次数</span><br>_waiters = <span class="hljs-number">0</span> ,<br>_recursions = <span class="hljs-number">0</span> ; <span class="hljs-comment">//锁的重入次数</span><br>_object = NULL;<br>_owner = NULL; <span class="hljs-comment">// 指向持有ObjectMonitor对象的线程</span><br>_WaitSet = NULL; <span class="hljs-comment">// 处于wait状态的线程，会被加入到_WaitSet</span><br>_WaitSetLock = <span class="hljs-number">0</span> ;<br>_Responsible = NULL ;<br>_succ = NULL ;<br>_cxq = NULL ;<br>FreeNext = NULL ;<br>_EntryList = NULL ; <span class="hljs-comment">// 处于等待锁block状态的线程，会被加入到该列表</span><br>_SpinFreq = <span class="hljs-number">0</span> ;<br>_SpinClock = <span class="hljs-number">0</span> ;<br>OwnerIsThread = <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>可以类比一个去医院就诊的例子[18]：</p><ul><li><p>首先，患者在 门诊大厅 前台或自助挂号机 进行挂号 ；</p></li><li><p>随后，挂号结束后患者找到对应的 诊室就诊 ：</p><ul><li>诊室每次只能有一个患者就诊；</li><li>如果此时诊室空闲，直接进入就诊；</li><li>如果此时诊室内有其它患者就诊，那么当前患者进入候诊室，等待叫号；</li></ul></li><li><p>就诊结束后， 走出就诊室 ，候诊室的 下一位候诊患者 进入就诊室。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190305715.png" alt="image-20220903190305715"></p></li></ul><p>这个过程就和<strong>Monitor机制</strong>比较相似：</p><ul><li>门诊大厅：所有待进入的线程都必须先在入口Entry Set挂号才有资格；</li><li>就诊室：就诊室_Owner里里只能有一个线程就诊，就诊完线程就自行离开</li><li>候诊室：就诊室繁忙时，进入等待区（Wait Set），就诊室空闲的时候就从等待区（Wait Set）叫新的线程</li></ul><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190457240.png" alt="image-20220903190457240"></p><p>所以我们就知道了，同步是锁住的什么东西：</p><ul><li><strong>monitorenter</strong>，在判断拥有同步标识 <strong>ACC_SYNCHRONIZED</strong> 抢先进入此方法的线程会优先拥有 <strong>Monitor</strong> 的 <strong>owner</strong> ，此时计数器 +1。</li><li><strong>monitorexit</strong>，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</li></ul><h2 id="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"><a href="#除了原子性，synchronized可见性，有序性，可重入性怎么实现？" class="headerlink" title="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"></a>除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h2><h3 id="synchronized怎么保证可见性？"><a href="#synchronized怎么保证可见性？" class="headerlink" title="synchronized怎么保证可见性？"></a>synchronized怎么保证可见性？</h3><ul><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li><li>线程加锁后，其它线程无法获取主内存中的共享变量。</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li></ul><h3 id="synchronized怎么保证有序性？"><a href="#synchronized怎么保证有序性？" class="headerlink" title="synchronized怎么保证有序性？"></a>synchronized怎么保证有序性？</h3><ul><li>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。</li><li>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</li><li>所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。</li></ul><h3 id="synchronized怎么实现可重入的呢？"><a href="#synchronized怎么实现可重入的呢？" class="headerlink" title="synchronized怎么实现可重入的呢？"></a>synchronized怎么实现可重入的呢？</h3><ul><li>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。</li><li>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码、块之后，计数器就会-1，直到计数器清零，就释放锁了。</li><li>之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</li></ul><h2 id="锁升级？synchronized优化了解吗？"><a href="#锁升级？synchronized优化了解吗？" class="headerlink" title="锁升级？synchronized优化了解吗？"></a>锁升级？synchronized优化了解吗？</h2><p>了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？</p><p>Java对象头里，有一块结构，叫<strong>Mark Word</strong>标记字段，这块结构会随着锁的状态变化而变化。64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903215849935.png" alt="image-20220903215849935"></p><p>Mark Word存储对象自身的运行数据，如<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）</strong> 等。</p><h3 id="synchronized做了哪些优化？"><a href="#synchronized做了哪些优化？" class="headerlink" title="synchronized做了哪些优化？"></a>synchronized做了哪些优化？</h3><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong> 。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。</p><ul><li><strong>偏向锁</strong>：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</li><li><strong>轻量级锁</strong>：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。</li><li><strong>自旋锁</strong>：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</li><li><strong>锁粗化</strong>：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li><strong>锁消除</strong>：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</li></ul><h3 id="锁升级的过程是什么样的？"><a href="#锁升级的过程是什么样的？" class="headerlink" title="锁升级的过程是什么样的？"></a>锁升级的过程是什么样的？</h3><p>锁升级方向：无锁–&gt;偏向锁—&gt; 轻量级锁—-&gt;重量级锁，这个方向基本上是不可逆的。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903221140669.png" alt="image-20220903221140669"></p><p>我们看一下升级的过程：</p><p><strong>偏向锁：</strong></p><p><strong>偏向锁的获取：</strong></p><p><strong>1.</strong> 判断是否为可偏向状态–MarkWord中锁标志是否为‘01’，是否偏向锁是否为‘1’<br><strong>2.</strong> 如果是可偏向状态，则查看线程ID是否为当前线程，如果是，则进入步骤’5’，否则进入步骤‘3’<br><strong>3.</strong> 通过CAS操作竞争锁，如果竞争成功，则将MarkWord中线程ID设置为当前线程ID，然后执行‘5’；竞争失败，则执行‘4’<br><strong>4.</strong> CAS获取偏向锁失败表示有竞争。当达到safepoint时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块<br>**5. ** 执行同步代码</p><p><strong>偏向锁的撤销：</strong></p><ol><li> 偏向锁不会主动释放(撤销)，只有遇到其他线程竞争时才会执行撤销，由于撤销需要知道当前持有该偏向锁的线程栈状态，因此要等到<strong>safepoint</strong>时执行，此时持有该偏向锁的线程（T）有‘2’，‘3’两种情况；</li><li>撤销—-T线程已经退出同步代码块，或者已经不再存活，则直接撤销偏向锁，变成无锁状态—-该状态达到阈值 20 则执行批量重偏向</li><li>升级—-T线程还在同步代码块中，则将T线程的偏向锁升级为轻量级锁，当前线程执行轻量级锁状态下的锁获取步骤—-该状态达到阈值 40 则执行批量撤销</li></ol><p><strong>轻量级锁：</strong></p><p><strong>轻量级锁的获取：</strong></p><p><strong>1.</strong> 进行加锁操作时，jvm会判断是否已经时重量级锁，如果不是，则会在当前线程栈帧中划出一块空间，作为该锁的锁记录，并且将锁对象MarkWord复制到该锁记录中<br><strong>2.</strong> 复制成功之后，jvm使用CAS操作将对象头MarkWord更新为指向锁记录的指针，并将锁记录里的owner指针指向对象头的MarkWord。如果成功，则执行‘3’，否则执行‘4’<br><strong>3.</strong> 更新成功，则当前线程持有该对象锁，并且对象MarkWord锁标志设置为‘00’，即表示此对象处于轻量级锁状态<br><strong>4.</strong> 更新失败，jvm先检查对象MarkWord是否指向当前线程栈帧中的锁记录，如果是则执行‘5’，否则执行‘6’<br><strong>5.</strong> 表示锁重入；然后当前线程栈帧中增加一个锁记录第一部分（Displaced Mark Word）为null，并指向Mark Word的锁对象，起到一个重入计数器的作用。<br><strong>6.</strong> 表示该锁对象已经被其他线程抢占，则进行自旋等待（默认 10 次），等待次数达到阈值仍未获取到锁，则升级为重量级锁</p><p>大体上省简的升级过程：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904142059373.png" alt="image-20220904142059373"></p><p>完整的升级过程：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904142838070.png" alt="image-20220904142838070"></p><h2 id="说说synchronized和ReentrantLock的区别？"><a href="#说说synchronized和ReentrantLock的区别？" class="headerlink" title="说说synchronized和ReentrantLock的区别？"></a>说说synchronized和ReentrantLock的区别？</h2><p>可以从<strong>锁的实现、功能特点、性能</strong>等几个维度去回答这个问题：</p><ul><li><strong>锁的实现</strong>： synchronized是<strong>Java语言的关键字</strong>，基于<strong>JVM</strong>实现。而ReentrantLock是基于JDK的<strong>API层面</strong>实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）</li><li><strong>性能</strong>： 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。</li><li><strong>功能特点</strong>： ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。<ul><li>ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制</li><li>ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</li><li>synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接又与newCondition()方法实现。</li><li>ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。</li></ul></li></ul><p>下面的表格列出出了两种锁之间的区别：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904163310518.png" alt="image-20220904163310518"></p><h2 id="AQS了解多少？"><a href="#AQS了解多少？" class="headerlink" title="AQS了解多少？"></a>AQS了解多少？</h2><p>AbstractQueuedSynchronizer <strong>抽象同步队列</strong>，简称 AQS ，它是Java并发包的根基，并发包中的锁就是基于AQS实现的。</p><ul><li>AQS是基于一个<strong>FIFO的双向队列</strong>，其内部定义了一个节点类Node，Node 节点内部的SHARED 用来标记该线程是获取共享资源时被阻挂起后放入AQS 队列的， EXCLUSIVE用来标记线程是 取独占资源时被挂起后放入AQS 队列</li><li>AQS 使用一个 volatile 修饰的 int 类型的成员变量 state 来表示同步状态，修改同步状态成功即为获得锁，volatile 保证了变量在多线程之间的可见性，修改 State 值时通过 CAS 机制来保证修改的原子性</li><li>获取state的方式分为两种，独占方式和共享方式，一个线程使用独占方式获取了资源，其它线程就会在获取失败后被阻塞。一个线程使用共享方式获取了资源，另外一个线程还可以通过CAS的方式进行获取。</li><li>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS 中会将竞争共享资源失败的线程添加到一个变体的 CLH 队列中。</li></ul><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904165058873.png" alt="image-20220904165058873"></p><p>先简单了解一下CLH：Craig、Landin and Hagersten 队列，是 <strong>单向链表实现的队列</strong> 。申请线程只在本地变量上自旋， <strong>它不断轮询前驱的状态</strong> ，如果发现 <strong>前驱节点释放了锁就结束自旋</strong></p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904165133380.png" alt="image-20220904165133380"></p><p>AQS 中的队列是 CLH 变体的虚拟双向队列，通过将每条请求共享资源的线程封装成一个节点来实现锁的分配：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904165250668.png" alt="image-20220904165250668"></p><p>AQS 中的 CLH 变体等待队列拥有以下特性：</p><ul><li>AQS 中队列是个双向链表，也是 FIFO 先进先出的特性</li><li>通过 Head、Tail 头尾两个节点来组成队列结构，通过 volatile 修饰保证可见性</li><li>Head 指向节点为已获得锁的节点，是一个虚拟节点，节点本身不持有具体线程</li><li>获取不到同步状态，会将节点进行自旋获取锁，自旋一定次数失败后会将线程阻塞，相对于 CLH 队列性能较好</li></ul><h2 id="ReentrantLock实现原理？"><a href="#ReentrantLock实现原理？" class="headerlink" title="ReentrantLock实现原理？"></a>ReentrantLock实现原理？</h2><p>ReentrantLock 是可重入的独占锁，只能有一个线程可以获取该锁，其它获取该锁的线程会被阻塞而被放入该锁的阻塞队列里面。</p><p>看看ReentrantLock的加锁操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建非公平锁</span><br><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 获取锁操作</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 执行代码逻辑</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>    <span class="hljs-comment">// ...</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 解锁操作</span><br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>new ReentrantLock()构造函数默认创建的是非公平锁 NonfairSync。</p><h3 id="公平锁-FairSync"><a href="#公平锁-FairSync" class="headerlink" title="公平锁 FairSync"></a>公平锁 FairSync</h3><ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁</li><li>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞,CPU 唤醒阻塞线程的开销比非公平锁大</li></ul><h3 id="非公平锁-NonfairSync"><a href="#非公平锁-NonfairSync" class="headerlink" title="非公平锁 NonfairSync"></a><strong>非公平锁 NonfairSync</strong></h3><ul><li>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁</li><li>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</li></ul><p>默认创建的对象lock()的时候：</p><ul><li>如果锁当前没有被其它线程占用，并且当前线程之前没有获取过该锁，则当前线程会获取到该锁，然后设置当前锁的拥有者为当前线程，并设置 AQS 的状态值为 1 ，然后直接返回。</li><li>如果当前线程之前己经获取过该锁，则这次只是简单地把 AQS 的状态值加 1 后返回。如果该锁己经被其他线程持有，非公平锁会尝试去获取锁，获取失败的话，则调用该方法程会被放入 AQS 队列阻塞挂起。</li></ul><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904184232357.png"></p><h2 id="ReentrantLock怎么实现公平锁的？"><a href="#ReentrantLock怎么实现公平锁的？" class="headerlink" title="ReentrantLock怎么实现公平锁的？"></a>ReentrantLock怎么实现公平锁的？</h2><p>new ReentrantLock()构造函数默认创建的是非公平锁 NonfairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>同时也可以在创建锁构造函数中传入具体参数创建公平锁 FairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br>--- ReentrantLock<br><span class="hljs-comment">// true 代表公平锁，false 代表非公平锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>sync = fair? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>FairSync、NonfairSync 代表公平锁和非公平锁，两者都是 ReentrantLock 静态内部类，只不过实现不同锁语义。</p><p><strong>非公平锁和公平锁的两处不同：</strong></p><ul><li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li><li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 tryAcquire 方法，在 tryAcquire 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li></ul><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904184726138.png" alt="image-20220904184726138"></p><p>相对来说，非公平锁会有更好的性能，因为它的吞吐量比较大。当然，非公平锁让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</p><h2 id="CAS呢？CAS了解多少？"><a href="#CAS呢？CAS了解多少？" class="headerlink" title="CAS呢？CAS了解多少？"></a>CAS呢？CAS了解多少？</h2><p>CAS叫做<strong>CompareAndSwap</strong>，<strong>比较并交换</strong>，主要是通过处理器的指令来保证操作的原子性的。</p><p>CAS 指令包含 3 个参数：<strong>共享变量的内存地址 A、预期的值 B 和共享变量的新值 C</strong>。只有当内存中地址 A 处的值等于 B 时，才能将内存中地址 A 处的值更新为新值 C。作为一条CPU 指令，CAS 指令本身是能够保证原子性的 。</p><h2 id="CAS-有什么问题？如何解决？"><a href="#CAS-有什么问题？如何解决？" class="headerlink" title="CAS 有什么问题？如何解决？"></a>CAS 有什么问题？如何解决？</h2><p>CAS的经典三大问题：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904192625392.png" alt="image-20220904192625392"></p><h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。</p><h4 id="怎么解决ABA问题？"><a href="#怎么解决ABA问题？" class="headerlink" title="怎么解决ABA问题？"></a>怎么解决ABA问题？</h4><ul><li>加版本号</li></ul><p>每次修改变量，都在这个变量的版本号上加 1 ，这样，刚刚A-&gt;B-&gt;A，虽然A的值没变，但是它的版本号已经变了，再判断版本号就会发现此时的A已经被改过了。参考乐观锁的版本号，这种做法可以给数据带上了一种实效性的检验。</p><p>Java提供了AtomicStampReference类，它的compareAndSet方法首先检查当前的对象引用值是否等于预期引用，并且当前印戳（Stamp）标志是否等于预期标志，如果全部相等，则以原子方式将引用值和印戳标志的值更新为给定的更新值。</p><h3 id="循环性能开销"><a href="#循环性能开销" class="headerlink" title="循环性能开销"></a>循环性能开销</h3><p>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</p><h4 id="怎么解决循环性能开销问题？"><a href="#怎么解决循环性能开销问题？" class="headerlink" title="怎么解决循环性能开销问题？"></a>怎么解决循环性能开销问题？</h4><p>在Java中，很多使用自旋CAS的地方，会有一个自旋次数的限制，超过一定次数，就停止自旋。</p><h3 id="只能保证一个变量的原子操作"><a href="#只能保证一个变量的原子操作" class="headerlink" title="只能保证一个变量的原子操作"></a><strong>只能保证一个变量的原子操作</strong></h3><p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p><h4 id="怎么解决只能保证一个变量的原子操作问题？"><a href="#怎么解决只能保证一个变量的原子操作问题？" class="headerlink" title="怎么解决只能保证一个变量的原子操作问题？"></a>怎么解决只能保证一个变量的原子操作问题？</h4><ul><li>可以考虑改用锁来保证操作的原子性</li><li>可以考虑合并多个变量，将多个变量封装成一个对象，通过AtomicReference来保证原子性。</li></ul><h2 id="Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？"><a href="#Java有哪些保证原子性的方法？如何保证多线程下i-结果正确？" class="headerlink" title="Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？"></a>Java有哪些保证原子性的方法？如何保证多线程下i++ 结果正确？</h2><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904223156739.png"></p><ul><li>使用循环原子类，例如AtomicInteger，实现i++原子操作</li><li>使用juc包下的锁，如ReentrantLock ，对i++操作加锁lock.lock()来实现原子性</li><li>使用synchronized，对i++操作加锁</li></ul><h2 id="原子操作类了解多少？"><a href="#原子操作类了解多少？" class="headerlink" title="原子操作类了解多少？"></a>原子操作类了解多少？</h2><p>当程序更新一个变量时，如果多线程同时更新这个变量，可能得到期望之外的值，比如变量i=1，A线程更新i+1，B线程也更新i+1，经过两个线程操作之后可能i不等于 3 ，而是等于 2 。因为A和B线程在更新变量i的时候拿到的i都是 1 ，这就是线程不安全的更新操作，一般我们会使用synchronized来解决这个问题，synchronized会保证多线程不会同时更新变量i。</p><p>其实除此之外，还有更轻量级的选择，Java从JDK 1.5开始提供了java.util.concurrent.atomic包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p><p>因为变量的类型有很多种，所以在Atomic包里一共提供了 13 个类，属于 4 种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220904223443822.png" alt="image-20220904223443822"></p><p>Atomic包里的类基本都是使用Unsafe实现的包装类。</p><p>使用原子的方式更新基本类型，Atomic包提供了以下 3 个类：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">AtomicBoolean：原子更新布尔类型。<br>AtomicInteger：原子更新整型。<br>AtomicLong：原子更新长整型。<br></code></pre></td></tr></table></figure><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下 4 个类：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">AtomicIntegerArray：原子更新整型数组里的元素。<br>AtomicLongArray：原子更新长整型数组里的元素。<br>AtomicReferenceArray：原子更新引用类型数组里的元素。<br>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型<br></code></pre></td></tr></table></figure><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使<br>用这个原子更新引用类型提供的类。Atomic包提供了以下 3 个类：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">AtomicReference：原子更新引用类型。<br>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。<br>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型<br>的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，<span class="hljs-built_in">bool</span>ean<br>initialMark）。<br></code></pre></td></tr></table></figure><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以<br>下 3 个类进行原子字段更新：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。<br>AtomicLongFieldUpdater：原子更新长整型字段的更新器。<br>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起<br>来，可用于原子的更新数据和数据的版本号，可以解决使用<span class="hljs-built_in">CAS</span>进行原子更新时可能出现<br>的 ABA问题。<br></code></pre></td></tr></table></figure><h2 id="AtomicInteger-的原理？"><a href="#AtomicInteger-的原理？" class="headerlink" title="AtomicInteger 的原理？"></a>AtomicInteger 的原理？</h2><p><strong>一句话概括： 使用CAS实现 。</strong></p><p>以AtomicInteger的添加方法为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, <span class="hljs-number">1</span> );<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Unsafe类的实例来进行添加操作，来看看具体的CAS操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>    var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>&#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>compareAndSwapInt</strong> 是一个<strong>native</strong>方法，基于CAS来操作int类型变量。其它的原子操作类基本都是大同小异。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试-Mybatis</title>
    <link href="/weiblog/2022/08/31/%E9%9D%A2%E8%AF%95-Mybatis/"/>
    <url>/weiblog/2022/08/31/%E9%9D%A2%E8%AF%95-Mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="说说什么是MyBatis"><a href="#说说什么是MyBatis" class="headerlink" title="说说什么是MyBatis?"></a>说说什么是MyBatis?</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831124353772.png" alt="image-20220831124353772"></p><p>优点：<br>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><p>缺点：<br>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h3 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么?"></a>ORM是什么?</h3><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831124733088.png" alt="image-20220831124733088"></p><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单来说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><h3 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，被称之为半自动ORM映射工具。</p><h3 id="JDBC编程有哪些不足之处，MyBatis是如何解决的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决的？</h3><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831125002543.png" alt="image-20220831125002543"></p><p>1 、数据连接创建、释放频繁造成系统资源浪费从而影响系统性能<br><strong>解决：在mybatis-config.xml中配置数据链接池，使用连接池统一管理数据库连接。</strong><br>2 、sql语句写在代码中造成代码不易维护<br><strong>解决：将sql语句配置在XXXXmapper.xml文件中与java代码分离。</strong><br>3 、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<br><strong>解决： Mybatis自动将java对象映射至sql语句。</strong><br>4 、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<br><strong>解决：Mybatis自动将sql执行结果映射至java对象。</strong></p><h2 id="Hibernate-和-MyBatis-有什么区别？"><a href="#Hibernate-和-MyBatis-有什么区别？" class="headerlink" title="Hibernate 和 MyBatis 有什么区别？"></a>Hibernate 和 MyBatis 有什么区别？</h2><p><strong>相同点</strong></p><p>都是对jdbc的封装，都是应用于持久层的框架。</p><p><strong>不同点</strong></p><p><strong>映射关系</strong><br>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单<br>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</p><p><strong>SQL优化和移植性</strong><br>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。<br>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</p><h3 id="MyBatis和Hibernate的适用场景"><a href="#MyBatis和Hibernate的适用场景" class="headerlink" title="MyBatis和Hibernate的适用场景?"></a>MyBatis和Hibernate的适用场景?</h3><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831130749515.png" alt="image-20220831130749515"></p><ul><li>Hibernate 是标准的ORM框架，SQL编写量较少，但不够灵活，适合于需求相对稳定，中小型的软件项目，比如：办公自动化系统</li><li>MyBatis 是半ORM框架，需要编写较多SQL，但是比较灵活，适合于需求变化频繁，快速迭代的项目，比如：电商网站</li></ul><h2 id="MyBatis使用过程？生命周期？"><a href="#MyBatis使用过程？生命周期？" class="headerlink" title="MyBatis使用过程？生命周期？"></a>MyBatis使用过程？生命周期？</h2><p>MyBatis基本使用的过程大概可以分为这么几步：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831150538063.png" alt="image-20220831150538063"></p><p><strong>1 、 创建SqlSessionFactory</strong></p><ul><li>可以从配置或者直接编码来创建SqlSessionFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br><span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br></code></pre></td></tr></table></figure><p><strong>2 、 通过SqlSessionFactory创建SqlSession</strong></p><ul><li>SqlSession（会话）可以理解为程序和数据库之间的桥梁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br></code></pre></td></tr></table></figure><p><strong>3 、 通过sqlsession执行数据库操作</strong></p><ul><li>​    可以通过 SqlSession 实例来直接执行已映射的 SQL 语句：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span>(Blog)session.selectOne(<span class="hljs-string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>,<span class="hljs-number">101</span> );<br></code></pre></td></tr></table></figure><ul><li>​    更常用的方式是先获取Mapper(映射)，然后再执行SQL语句：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br><span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> mapper.selectBlog( <span class="hljs-number">101</span> );<br></code></pre></td></tr></table></figure><p><strong>4 、 调用session.commit()提交事务</strong></p><ul><li>如果是更新、删除语句，我们还需要提交一下事务。</li></ul><p><strong>5 、 调用session.close()关闭会话</strong></p><ul><li>最后一定要记得关闭会话。</li></ul><h3 id="MyBatis生命周期？"><a href="#MyBatis生命周期？" class="headerlink" title="MyBatis生命周期？"></a>MyBatis生命周期？</h3><p>上面提到了几个MyBatis的组件，一般说的MyBatis生命周期就是这些组件的生命周期。</p><ul><li><p><strong>SqlSessionFactoryBuilder</strong></p><ul><li>一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的生命周期只存在于方法的内部。</li></ul></li><li><p><strong>SqlSessionFactory</strong></p><ul><li>SqlSessionFactory 是用来创建SqlSession的，相当于一个数据库连接池，每次创建SqlSessionFactory都会使用数据库资源，多次创建和销毁是对资源的浪费。所以SqlSessionFactory是应用级的生命周期，而且应该是单例的。</li></ul></li><li><p><strong>SqlSession</strong></p><ul><li>SqlSession相当于JDBC中的Connection，SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的生命周期是一次请求或一个方法。</li></ul></li><li><p><strong>Mapper</strong></p><ul><li>映射器是一些绑定映射语句的接又。映射器接又的实例是从 SqlSession 中获得的，它的生命周期在sqlsession事务方法之内，一般会控制在方法级。</li></ul></li></ul><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831155449848.png" alt="image-20220831155449848"></p><p>当然，万物皆可集成Spring，MyBatis通常也是和Spring集成使用，Spring可以帮助我们创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到我们的 bean 中，我们不需要关心它们的创建过程和生命周期，那就是另外的故事了。</p><h2 id="在mapper中如何传递多个参数？"><a href="#在mapper中如何传递多个参数？" class="headerlink" title="在mapper中如何传递多个参数？"></a>在mapper中如何传递多个参数？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831155632178.png" alt="image-20220831155632178"></p><h3 id="方法-1-：顺序传参法"><a href="#方法-1-：顺序传参法" class="headerlink" title="方法 1 ：顺序传参法"></a>方法 1 ：顺序传参法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> deptId)</span>;<br><br>&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>select * from user<br><span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123; <span class="hljs-number">0</span> &#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123; <span class="hljs-number">1</span> &#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><ul><li>#{}里面的数字代表传入参数的顺序。</li><li>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</li></ul><h3 id="方法-2-：-Param注解传参法"><a href="#方法-2-：-Param注解传参法" class="headerlink" title="方法 2 ：@Param注解传参法"></a>方法 2 ：@Param注解传参法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userName&quot;)</span> String name, <span class="hljs-type">int</span> <span class="hljs-meta">@Param(&quot;deptId&quot;)</span> deptId)</span><br>    <br>&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>select * from user<br><span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;userName&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;deptId&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><ul><li>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</li><li>这种方法在参数不多的情况还是比较直观的，（推荐使用）。</li></ul><h3 id="方法-3-：Map传参法"><a href="#方法-3-：Map传参法" class="headerlink" title="方法 3 ：Map传参法"></a><strong>方法 3 ：Map传参法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(Map&lt;String, Object&gt; params)</span>;<br><br>&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>select * from user<br><span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;userName&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;deptId&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><ul><li>#{}里面的名称对应的是Map里面的key名称。</li><li>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</li></ul><h3 id="方法-4-：Java-Bean传参法"><a href="#方法-4-：Java-Bean传参法" class="headerlink" title="方法 4 ：Java Bean传参法"></a><strong>方法 4 ：Java Bean传参法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(User user)</span>;<br>&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> parameterType=<span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>select * from user<br><span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;userName&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;deptId&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><ul><li>#{}里面的名称对应的是User类里面的成员属性。</li><li>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。（推荐使用）。</li></ul><h2 id="实体类属性名和表中字段名不一样-，怎么办"><a href="#实体类属性名和表中字段名不一样-，怎么办" class="headerlink" title="实体类属性名和表中字段名不一样 ，怎么办?"></a>实体类属性名和表中字段名不一样 ，怎么办?</h2><ul><li>第 1 种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.Order&quot;</span>&gt;</span><br>    select order_id id, order_no orderno ,order_price price form<br>    orders where order_id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>第 2 种： 通过resultMap 中的<result>来映射字段名和实体类属性名的一一对应的关系。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;orderResultMap&quot;</span>&gt;</span><br>select * from orders where order_id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.jourwon.pojo.Order&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderResultMap&quot;</span>&gt;</span><br>&lt;!–用id属性来映射主键字段–&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span>&gt;</span><br>&lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span> =<span class="hljs-string">&quot;orderno&quot;</span> <span class="hljs-attr">column</span> =<span class="hljs-string">&quot;order_no&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_price&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">reslutMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a>Mybatis是否可以映射Enum枚举类？</h2><ul><li>Mybatis当然可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</li><li>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别?"></a>#{}和${}的区别?</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831165343833.png" alt="image-20220831165343833"></p><ul><li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li><li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li><li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li><li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li></ul><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> #&#123;userName&#125;；<br></code></pre></td></tr></table></figure><p>设userName=yuze</p><p>看日志我们可以看到解析时将#{userName}替换成了 <strong>？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p>然后再把yuze放进去，外面加上单引号</p><p>Mybatis在处理的 时 候 就 是 把 {}的时候就是把的时候就是把{}替换成变量的值，调用Statement来赋值<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> #&#123;userName&#125;；<br></code></pre></td></tr></table></figure><p>设userName=yuze</p><p>看日志可以发现就是直接把值拼接上去了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> yuze;<br></code></pre></td></tr></table></figure><p>这极有可能发生<a href="https://so.csdn.net/so/search?q=sql%E6%B3%A8%E5%85%A5&spm=1001.2101.3001.7020">sql注入</a>，下面举了一个简单的sql注入案例 </p><p>当用户登录，我们验证账号密码是否正确时用这个sql：</p><p>username=yyy;password=123</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span>$&#123;username&#125; <span class="hljs-keyword">and</span> password<span class="hljs-operator">=</span>$&#123;password&#125;<br></code></pre></td></tr></table></figure><p>显然这条sql没问题可以查出来，但是如果有人不知道密码但是想登录账号怎么办</p><p>我们不需要填写正确的密码：</p><p>密码输入1 or 1=1，sql执行的其实是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;yyy&#x27;</span> <span class="hljs-keyword">and</span> password<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>#{}的变量替换是在DBMS中、变量替换后，#{}对应的变量自动加上单引号</p><p>${}的变量替换是在DBMS外,变量替换后 ，{}的变量替换是在DBMS外、变量替换后，的变量替换是在DBMS外、变量替换后，{}对应的变量不会加上单引号</p><p>使用#{}可以有效的防止sql注入，提高系统的安全性</p><h2 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写?"></a>模糊查询like语句该怎么写?</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831172605851.png" alt="image-20220831172605851"></p><p>1 ’**%${question}%**’ 可能引起SQL注入，不推荐<br>2 “%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’’，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。<br>3 CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，（推荐✨）<br>4 使用bind标签（不推荐）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listUserLikeUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot;</span> /&gt;</span><br>select id,sex,age,username,password from person where username LIKE #<br>&#123;pattern&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis能执行一对一、一对多的关联查询吗？"><a href="#Mybatis能执行一对一、一对多的关联查询吗？" class="headerlink" title="Mybatis能执行一对一、一对多的关联查询吗？"></a>Mybatis能执行一对一、一对多的关联查询吗？</h2><p>当然可以，不止支持一对一、一对多的关联查询，还支持多对多、多对一的关联查询。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831172905299.png" alt="image-20220831172905299"></p><ul><li><p><strong>一对一<association></strong></p><p>比如订单和支付是一对一的关系，这种关联的实现：</p><p>实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br><span class="hljs-keyword">private</span> Integer orderId;<br><span class="hljs-keyword">private</span> String orderDesc;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 支付对象</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">private</span> Pay pay;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 订单resultMap --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;peopleResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.fighter3.entity.Order&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderDesc&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_desc&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--一对一结果映射--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pay&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;cn.fighter3.entity.Pay&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;payId&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pay_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;account&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>查询就是普通的关联查</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;getTeacherMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    select * from order o<br>    left join pay p on o.order_id=p.order_id<br>    where o.order_id=#&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>一对多<collection></strong><br>比如商品分类和商品，是一对多的关系。<br>实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Category</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> categoryId;<br>    <span class="hljs-keyword">private</span> String categoryName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 商品列表</span><br><span class="hljs-comment">    **/</span><br>    List&lt;Product&gt; products;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Category&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;categoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;categoryId&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;category_id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;categoryName&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;category_name&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 一对多的关系 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类</span><br><span class="hljs-comment">    型 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;products&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Product&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;product_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;productId&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;productName&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;productName&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;price&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>查询</p><p>查询就是一个普通的关联查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 关联查询分类和产品表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listCategory&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;categoryBean&quot;</span>&gt;</span><br>select c.*, p.* from category_ c left join product_ p<br>on c.id = p.cid<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="Mybatis是否支持延迟加载？原理？"><a href="#Mybatis是否支持延迟加载？原理？" class="headerlink" title="Mybatis是否支持延迟加载？原理？"></a>Mybatis是否支持延迟加载？原理？</h2><ul><li><p>Mybatis支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载<strong>lazyLoadingEnabled</strong>=true|false。</p></li><li><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p></li><li><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p></li></ul><h2 id="如何获取生成的主键"><a href="#如何获取生成的主键" class="headerlink" title="如何获取生成的主键?"></a>如何获取生成的主键?</h2><p>新增标签中添加：keyProperty=” ID “ 即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;userId&quot;</span> &gt;</span><br>    insert into user(<br>    user_name, user_password, create_time)<br>    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType=<br>    TIMESTAMP&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这时候就可以完成回填主键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mapper.insert(user);<br>user.getId;<br></code></pre></td></tr></table></figure><h2 id="MyBatis支持动态SQL吗？"><a href="#MyBatis支持动态SQL吗？" class="headerlink" title="MyBatis支持动态SQL吗？"></a>MyBatis支持动态SQL吗？</h2><p>MyBatis中有一些支持动态SQL的标签，它们的原理是使用OGNL从SQL参数对象中计算表达式的值，根据表达式的值动态拼接SQL，以此来完成动态SQL的功能。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831185515276.png" alt="image-20220831185515276"></p><ul><li><p>if</p><p>根据条件来组成where子句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogWithTitleLike&quot;</span><span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>    SELECT * FROM BLOG<br>    WHERE state = ‘ACTIVE’<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>    AND title like #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>choose (when, otherwise)</p><p>这个和Java 中的 switch 语句有点像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>SELECT * FROM BLOG WHERE state = ‘ACTIVE’<br>    <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>            AND title like #&#123;title&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>                AND author_name like #&#123;author.name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>            AND featured = 1<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>trim (where, set)</p><ul><li><p><where>可以用在所有的查询条件都是动态的情况</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>    SELECT * FROM BLOG<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;state != null&quot;</span>&gt;</span><br>        state = #&#123;state&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>        AND title like #&#123;title&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>        AND author_name like #&#123;author.name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><set> 可以用在动态更新的时候</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span><br>    update Author<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>foreach<br>看到名字就知道了，这个是用来循环的，可以对集合进行遍历</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPostIn&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;domain.blog.Post&quot;</span>&gt;</span><br>    SELECT *<br>    FROM POST P<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">open</span>=<span class="hljs-string">&quot;ID in (&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">nullable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>                #&#123;item&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="MyBatis如何执行批量操作？"><a href="#MyBatis如何执行批量操作？" class="headerlink" title="MyBatis如何执行批量操作？"></a>MyBatis如何执行批量操作？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831212914015.png" alt="image-20220831212914015"></p><p><strong>第一种方法：使用foreach标签</strong></p><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。</p><ul><li>item 表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li><li>index 指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li><li>open 表示该语句以什么开始，常用“(”；</li><li>separator 表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</li><li>close 表示以什么结束，常用“)”。</li></ul><p>在使用<strong>foreach</strong>的时候最关键的也是最容易出错的就是<strong>collection</strong>属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有以下 3 种情况：</p><p><strong>1.</strong> 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list<br><strong>2.</strong> 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array<br><strong>3.</strong> 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</p><p>看看批量保存的两种用法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt;</span> //推荐使用<br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmpsBatch&quot;</span>&gt;</span><br>    INSERT INTO emp(ename,gender,email,did)<br>    VALUES<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持</span><br><span class="hljs-comment">如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmpsBatch&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;;&quot;</span>&gt;</span><br>        INSERT INTO emp(ename,gender,email,did)<br>        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>第二种方法：使用ExecutorType.BATCH</strong></p><p>Mybatis内置的ExecutorType有 3 种，默认为simple，该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作<br>时，在事务没有提交之前，是没有办法获取到自增的id，在某些情况下不符合业务的需求。<br>具体用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//批量保存方法测试</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123;<br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> getSqlSessionFactory();<br><span class="hljs-comment">//可以执行批量操作的sqlSession</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">openSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);<br>    <span class="hljs-comment">//批量保存执行前时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">EmployeeMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> openSession.getMapper(EmployeeMapper.class);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ; i++) &#123;<br>            mapper.addEmp(<span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">Employee</span>(UUID.randomUUID().toString().substring( <span class="hljs-number">0</span> , <span class="hljs-number">5</span> ), <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>));<br>   &#125;<br>openSession.commit();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">//批量保存执行后的时间</span><br>    System.out.println(<span class="hljs-string">&quot;执行时⻓&quot;</span> + (end - start));<br>    <span class="hljs-comment">//批量 预编译sql一次==》设置参数==》 10000 次==》执行 1 次 677</span><br>    <span class="hljs-comment">//非批量 （预编译=设置参数=执行 ）==》 10000 次 1121</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>openSession.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>mapper和mapper.xml如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> &#123;<br><span class="hljs-comment">//批量保存员工</span><br>Long <span class="hljs-title function_">addEmp</span><span class="hljs-params">(Employee employee)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.jourwon.mapper.EmployeeMapper&quot;</span></span><br><span class="hljs-tag">    &lt;!<span class="hljs-attr">--批量保存员工</span> <span class="hljs-attr">--</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmp&quot;</span>&gt;</span><br>        insert into employee(lastName,email,gender)<br>        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="MyBatis中一级缓存和二级缓存详解"><a href="#MyBatis中一级缓存和二级缓存详解" class="headerlink" title="MyBatis中一级缓存和二级缓存详解"></a>MyBatis中一级缓存和二级缓存详解</h2><h3 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h3><p>首先缓存的合理使用是优化中最常见的，将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据的压力，同时提高系统性能。</p><h3 id="为什么需要缓存"><a href="#为什么需要缓存" class="headerlink" title="为什么需要缓存"></a>为什么需要缓存</h3><p>BS架构里面，用户的所有操作都是对数据库的增删改查，其中查询的操作是最多的，但如果用户想要某个数据时每次都去数据库查询，这无疑会增加数据库的压力，而且获取时间效率也会降低，所以为了解决这些问题，缓存应用而生，使用了缓存之后，服务器只需要查询一次数据库，然后将数据保存到服务器主机的内存中，以后读取时就直接取内存中的数据，而不需要每次都查数据库，这种方案除了降低数据库压力之外，还提高了响应速度，简直一箭双雕哇~</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存是<strong>SqlSession</strong>级别的缓存，在操作数据库时需要构造SqlSession对象，在对象中有一个数据结构用于存储缓存数据。不同的sqlSession之间的缓存数据区域是<strong>互相不影响</strong>的。也就是他只能作用在同一个<strong>sqlSession</strong>中，不同的<strong>sqlSession</strong>中的缓存是互相不能读取的。<br><strong>一级缓存的工作原理：</strong><br>一级缓存默认是开启的，它在一个sqlSession会话里面的所有查询操作都会保存到缓存中，一般来说一个请求中的所有增删改查操作都是在同一个sqlSession里面的，所以我们可以认为每个请求都有自己的一级缓存，如果同一个sqlSession会话中2 个查询中间有一个 insert 、update或delete 语句，那么之前查询的所有缓存都会清空；<br><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/c6d2a5c38b2e4e6fae3da740b37596f7.png" alt="在这里插入图片描述"></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/06ed9e43f8644ff7a40eca96c27f15c1.png" alt="在这里插入图片描述"></p><p>1、用户发起查询请求，查询某条数据，sqlSession先去缓存中查找，是否有该条数据，如果有，则读取并返回；如果没有，则需要从数据库中查询，并将查询到的数据放入到一级缓存区域，供下次查找使用。</p><p>2、sqlSession执行增删改操作并执行commit操作，则会清空缓存，这样做的<strong>目的是避免脏读</strong>。</p><p>3、如果commit不清空缓存，会有以下场景：A查询了某商品库存为10件，并将10件库存的数据存入缓存中，之后被客户买走了10件，数据被delete了，但是下次查询这件商品时，并不从数据库中查询，而是从缓存中查询，就会出现错误。</p><p>4、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br> <br>        <span class="hljs-comment">// 加载mybatis配置文件</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Resources.getResourceAsReader(<span class="hljs-string">&quot;config/configuration.xml&quot;</span>);<br>        <span class="hljs-comment">//创建数据工厂</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> builder.build(reader);<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br> <br> <br>        <span class="hljs-comment">// 获取mapper接口对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br> <br>        <span class="hljs-comment">// 查询第一次</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        <span class="hljs-comment">// 第二次查询</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;两个user对象是否相等：&quot;</span>+(user == user1));<br>        <span class="hljs-comment">//释放会话</span><br>        sqlSession.clearCache();<br>        sqlSession.close();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/f954119fbd3944ebbeccba11d8ee1ad9.png" alt="在这里插入图片描述"></p><p><strong>根据结果可以看到，代码中执行了2次查询， 但实际运行时只查询了一次数据库，第二次获取数据时直接从缓存中读取，并且2次读取的数据都是一样的，到这里，一级缓存就已经生效了；</strong><br>接下来我们来测试第二种情况 ：<strong>查询 -&gt; 修改 -&gt; 查询</strong><br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br> <br>        <span class="hljs-comment">// 加载mybatis配置文件</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Resources.getResourceAsReader(<span class="hljs-string">&quot;config/configuration.xml&quot;</span>);<br>        <span class="hljs-comment">//创建数据工厂</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> builder.build(reader);<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br> <br> <br>        <span class="hljs-comment">// 获取mapper接口对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-comment">// 查询第一次</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        <span class="hljs-comment">// 修改</span><br>        mapper.updateByPrimaryKey(user);<br>        <span class="hljs-comment">// 第二次查询</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;两个user对象是否相等：&quot;</span>+(user == user1));<br>        <span class="hljs-comment">//释放会话</span><br>        sqlSession.clearCache();<br>        sqlSession.close();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/cc432713b29a465babe833106535ffe9.png" alt="在这里插入图片描述"></p><p>控制台打印了三次sql,其中第一个查询和第三个查询是一样的，但是并没有使用缓存<strong>，是因为每次增删改操作都有可能会改变原来的数据，所以必须刷新缓存</strong>。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p><strong>二级缓存是mapper级别的缓存</strong>，多个SqlSession去操作同一个Mapper的sql语句，<strong>多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。二级缓存的作用范围更大</strong>。</p><p>二级缓存流程图：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/57ebea0ab2e34e3fb6a15c8916b65100.png" alt="在这里插入图片描述"></p><p>第一种配置方式</p><p>单个mapper配置，主需要在需要开启二级缓存的mapper.xml文件中加入以下配置即可开启。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启单个mapper的二级缓存，也叫全局缓存--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>注意一定要加到xxMapper.xml的文件内，千万不要加到[mybatis] 的主配置文件里面了，会报错的。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/dae47bea7d764a45809d612ac0a62b71.png" alt="在这里插入图片描述"></p><p>第二种配置方式</p><p>所有的mapper都开启二级缓存，在mybatis.xml主配置文件中加入以下配置即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--  开启所有mapper的二级缓存 --&gt;</span><br>     <span class="hljs-comment">&lt;!--&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/3c6f0b1fb377457c867002bbf8546a40.png" alt="在这里插入图片描述"></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">    <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 加载mybatis配置文件</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Resources.getResourceAsReader(<span class="hljs-string">&quot;config/configuration.xml&quot;</span>);<br>        <span class="hljs-comment">//创建数据工厂</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> builder.build(reader);<br>        <span class="hljs-comment">// 第一个会话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 获取会话一的mapper接口对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-comment">// 第一次查询</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        <span class="hljs-comment">//释放第一个会话</span><br>        sqlSession.clearCache();<br>        sqlSession.close();<br>        <span class="hljs-comment">// 第二个会话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession2</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 获取会话二的mapper接口对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> sqlSession2.getMapper(UserMapper.class);<br>        <span class="hljs-comment">// 第二次查询</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper2.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        <span class="hljs-comment">// 释放第二个会话</span><br>        sqlSession2.clearCache();<br>        sqlSession2.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/d52366f288e940b2afbf51d5035db571.png" alt="在这里插入图片描述"></p><p><strong>打印结果很明显，2次查询，但是日志显示只查询了一次数据库， 第二次是从缓存中获取的数据，至此，二级缓存已开启！</strong></p><p>总结：</p><p><strong>1.</strong> 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为SqlSession，各个SqlSession之间的缓存相互隔离，当Session flush 或 close 之后，该 SqlSession 中的所有Cache 就将清空，MyBatis默认打开一级缓存。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901114614900.png" alt="image-20220901114614900"></p><p><strong>2.</strong> 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同之处在于其存储作用域为 Mapper(Namespace)，可以在多个SqlSession之间共享，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接又(可用来保存对象的状态),可在它的映射文件中配置。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901114627565.png" alt="image-20220901114627565"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="能说说MyBatis的工作原理吗？"><a href="#能说说MyBatis的工作原理吗？" class="headerlink" title="能说说MyBatis的工作原理吗？"></a>能说说MyBatis的工作原理吗？</h2><p>我们已经大概知道了MyBatis的工作流程，按工作原理，可以分为两大步：<strong>生成会话工厂、会话运行</strong>。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901123812730.png" alt="image-20220901123812730"></p><p>MyBatis是一个成熟的框架，篇幅限制，这里抓大放小，来看看它的主要工作流程。</p><h3 id="构建会话工厂"><a href="#构建会话工厂" class="headerlink" title="构建会话工厂"></a>构建会话工厂</h3><p>构造会话工厂也可以分为两步：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901130322195.png" alt="image-20220901130322195"></p><ul><li>获取配置</li></ul><p>获取配置这一步经过了几步转化，最终由生成了一个配置类<strong>Configuration</strong>实例，这个配置类实例非常重要，主要作用包括：</p><ul><li>​    读取配置文件，包括<strong>基础配置文件和映射文件</strong></li><li>​    初始化基础配置，比如MyBatis的别名，还有其它的一些重要的<strong>类对象，像插件、映射器、ObjectFactory</strong>等等</li><li>​    提供一个单例，作为会话工厂构建的重要参数</li><li>​    它的构建过程也会初始化一些环境变量，比如数据源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">build</span><span class="hljs-params">(Reader reader, String environment,Properties properties)</span> &#123;<br>    SqlSessionFactory var5;<br>    <span class="hljs-comment">//省略异常处理</span><br>    <span class="hljs-comment">//xml配置构建器</span><br>    <span class="hljs-type">XMLConfigBuilder</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLConfigBuilder</span>(reader,environment, properties);<br>    <span class="hljs-comment">//通过转化的Configuration构建SqlSessionFactory</span><br>    var5 = <span class="hljs-built_in">this</span>.build(parser.parse());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>构建SqlSessionFactory</p><p>SqlSessionFactory只是一个接又，构建出来的实际上是它的实现类的实例，一般我们用的都是它的实现类DefaultSqlSessionFactory，</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">build</span><span class="hljs-params">(Configuration config)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSessionFactory</span>(config);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="会话运行"><a href="#会话运行" class="headerlink" title="会话运行"></a>会话运行</h3><p>会话运行是MyBatis最复杂的部分，它的运行离不开四大组件的配合：<img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901145328294.png" alt="image-20220901145328294"></p><ul><li><strong>Executor（执行器）</strong><br>Executor起到了至关重要的作用，SqlSession只是一个门面，相当于客服，真正干活的是是Executor，就像是默默无闻的工程师。它提供了相应的查询和更新方法，以及事务方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Environment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.configuration.getEnvironment();<br><span class="hljs-type">TransactionFactory</span> <span class="hljs-variable">transactionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getTransactionFactoryFromEnvironment(environment);<br>tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);<br><span class="hljs-comment">//通过Configuration创建executor</span><br><span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.configuration.newExecutor(tx,execType);<br>var8 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSession</span>(<span class="hljs-built_in">this</span>.configuration, executor,autoCommit);<br></code></pre></td></tr></table></figure><ul><li>StatementHandler（数据库会话器）<br>StatementHandler，顾名思义，处理数据库会话的。我们以SimpleExecutor为例，看一下它的查询方法，先生成了一个StatementHandler实例，再拿这个handler去执行query。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameter,</span><br><span class="hljs-params">RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span><span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>List var9;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> ms.getConfiguration();<br>        <span class="hljs-type">StatementHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> configuration.newStatementHandler(<span class="hljs-built_in">this</span>.wrapper, ms, parameter,rowBounds,<br>        resultHandler, boundSql);<br>        stmt = <span class="hljs-built_in">this</span>.prepareStatement(handler,ms.getStatementLog());<br>        var9 = handler.query(stmt, resultHandler);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">this</span>.closeStatement(stmt);<br>    &#125;<br><span class="hljs-keyword">return</span> var9;<br>&#125;<br></code></pre></td></tr></table></figure><p>再以最常用的PreparedStatementHandler看一下它的query方法，其实在上面的prepareStatement已经对参数进行了预编译处理，到了这里，就直接执行sql，使用ResultHandler处理返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(Statement statement, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> (PreparedStatement)statement;<br>    ps.execute();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.resultSetHandler.handleResultSets(ps);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ParameterHandler （参数处理器）<br>PreparedStatementHandler里对sql进行了预编译处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parameterize</span><span class="hljs-params">(Statement statement)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-built_in">this</span>.parameterHandler.setParameters((PreparedStatement)statement);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用的就是ParameterHandler，setParameters的作用就是设置预编译SQL语句的参数。里面还会用到typeHandler类型处理器，对类型进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ParameterHandler</span> &#123;<br>    Object <span class="hljs-title function_">getParameterObject</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParameters</span><span class="hljs-params">(PreparedStatement var1)</span> <span class="hljs-keyword">throws</span> SQLException;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>ResultSetHandler（结果处理器）</p><p>我们前面也看到了，最后的结果要通过ResultSetHandler来进行处理，handleResultSets这个方法就是用来包装结果集的。Mybatis为我们提供了一个DefaultResultSetHandler，通常都是用这个实现类去进行结果的处理的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResultSetHandler</span> &#123;<br>    &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">handleResultSets</span><span class="hljs-params">(Statement var1)</span> <span class="hljs-keyword">throws</span> SQLException;<br>    <br>    &lt;E&gt; Cursor&lt;E&gt; <span class="hljs-title function_">handleCursorResultSets</span><span class="hljs-params">(Statement var1)</span> <span class="hljs-keyword">throws</span> SQLException;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOutputParameters</span><span class="hljs-params">(CallableStatement var1)</span> <span class="hljs-keyword">throws</span> SQLException;<br>&#125;<br></code></pre></td></tr></table></figure><p>它会使用typeHandle处理类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。</p><p>整体上总结一下会话运行：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901153231196.png" alt="image-20220901153231196"></p><p>把整个的⼯作流程串联起来，简单总结⼀下：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901153540814.png" alt="image-20220901153540814"></p><p><strong>1.</strong> 读取 MyBatis 配置文件——<strong>mybatis-config.xml 、加载映射文件</strong>——映射文件即 SQL 映射文件，文件中配置了操作数据库的 SQL 语句。最后生成一个<strong>配置对象</strong>。<br><strong>2.</strong> 构造会话工厂：通过 MyBatis 的环境等配置信息构建<strong>会话工厂 SqlSessionFactory</strong>。<br><strong>3.</strong> 创建会话对象：由会话工厂<strong>创建 SqlSession 对象</strong>，该对象中包含了执行 SQL 语句的所有方法。<br><strong>4.</strong> Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。<br><strong>5.</strong> <strong>StatementHandler</strong>：数据库会话器，串联起参数映射的处理和运行结果映射的处理。<br>**6.**参数处理：对输入参数的类型进行处理，并预编译<br>**7.**结果处理：对返回结果的类型进行处理，根据对象映射规则，返回相应的对象。</p><h2 id="MyBatis的功能架构是什么样的？"><a href="#MyBatis的功能架构是什么样的？" class="headerlink" title="MyBatis的功能架构是什么样的？"></a>MyBatis的功能架构是什么样的？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901154447146.png" alt="image-20220901154447146"></p><p>我们一般把Mybatis的功能架构分为三层：</p><ul><li><strong>API接口层</strong>：提供给外部使用的接又API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li><strong>数据处理层</strong>：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li><strong>基础支撑层</strong>：负责最基础的功能支撑，包括<strong>连接管理、事务管理、配置加载和缓存处理</strong>，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ul><h2 id="为什么Mapper接又不需要实现类？"><a href="#为什么Mapper接又不需要实现类？" class="headerlink" title="为什么Mapper接又不需要实现类？"></a>为什么Mapper接又不需要实现类？</h2><p>四个字回答： <strong>动态代理</strong> ，我们来看一下获取Mapper的过程：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901155803040.png" alt="image-20220901155803040"></p><ul><li><p>获取Mapper<br>我们都知道定义的Mapper接口是没有实现类的，Mapper映射其实是通过 动态代理 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br></code></pre></td></tr></table></figure><p>七拐八绕地进去看一下，发现获取Mapper的过程，需要先获取<strong>MapperProxyFactory</strong>——Mapper代理工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;<br>    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="hljs-built_in">this</span>.knownMappers.get(type);<br>    <span class="hljs-keyword">if</span> (mapperProxyFactory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is not known</span><br><span class="hljs-string">        to the MapperRegistry.&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var5) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Error getting mapper</span><br><span class="hljs-string">        instance. Cause: &quot;</span> + var5, var5);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>MapperProxyFactory<br>MapperProxyFactory的作用是生成MapperProxy（Mapper代理对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;<br>    ......<br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;<br>    <span class="hljs-keyword">return</span><br>    Proxy.newProxyInstance(<span class="hljs-built_in">this</span>.mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;<span class="hljs-built_in">this</span>.mapperInterface&#125;, mapperProxy);<br>&#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> &#123;<br>        MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>(sqlSession,<br>        <span class="hljs-built_in">this</span>.mapperInterface, <span class="hljs-built_in">this</span>.methodCache);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.newInstance(mapperProxy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到动态代理对接又的绑定，它的作用就是生成动态代理对象（占位），而代理的方法被放到了MapperProxy中。</p><ul><li>MapperProxy</li></ul></li></ul><p>​        MapperProxy里，通常会生成一个<strong>MapperMethod</strong>对象，它是通过cachedMapperMethod方法对其进行初始化的，然后执行excute方        法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> Object.class.equals(method.getDeclaringClass())?<br>        method.invoke(<span class="hljs-built_in">this</span>, args) : <span class="hljs-built_in">this</span>.cachedInvoker(method).invoke(proxy,<br>        method, args, <span class="hljs-built_in">this</span>.sqlSession);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var5) &#123;<br>        <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>MapperMethod<br>MapperMethod里的excute方法，会真正去执行sql。这里用到了命令模式，其实绕一圈，最终它还是通过<strong>SqlSession</strong>的实例去运行对象的sql。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(SqlSession sqlSession, Object[] args)</span> &#123;<br>    Object result;<br>    Object param;<br>    ......<br>    <span class="hljs-keyword">case</span> SELECT:<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsVoid() &amp;&amp;<br>    <span class="hljs-built_in">this</span>.method.hasResultHandler()) &#123;<br>    <span class="hljs-built_in">this</span>.executeWithResultHandler(sqlSession, args);<br>    result = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsMany()) &#123;<br>    result = <span class="hljs-built_in">this</span>.executeForMany(sqlSession, args);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsMap()) &#123;<br>    result = <span class="hljs-built_in">this</span>.executeForMap(sqlSession, args);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsCursor()) &#123;<br>    result = <span class="hljs-built_in">this</span>.executeForCursor(sqlSession, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    param =<br>    <span class="hljs-built_in">this</span>.method.convertArgsToSqlCommandParam(args);<br>    result =<br>    sqlSession.selectOne(<span class="hljs-built_in">this</span>.command.getName(), param);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsOptional() &amp;&amp; (result == <span class="hljs-literal">null</span><br>    || !<span class="hljs-built_in">this</span>.method.getReturnType().equals(result.getClass()))) &#123;<br>    result = Optional.ofNullable(result);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mybatis都有哪些Executor执行器？"><a href="#Mybatis都有哪些Executor执行器？" class="headerlink" title="Mybatis都有哪些Executor执行器？"></a>Mybatis都有哪些Executor执行器？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901162602848.png" alt="image-20220901162602848"></p><p>Mybatis有三种基本的Executor执行器，<strong>SimpleExecutor、ReuseExecutor、BatchExecutor</strong>。</p><ul><li><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li><li><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><h3 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h3><ul><li>在Mybatis配置文件中，在设置（settings）可以指定默认的<strong>ExecutorType</strong>执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递<strong>ExecutorType类型参数</strong>，如SqlSession openSession(ExecutorType execType)。</li><li>配置默认的执行器。<strong>SIMPLE</strong> 就是普通的执行器；<strong>REUSE</strong> 执行器会重用预处理语句（prepared statements）； <strong>BATCH</strong> 执行器将重用语句并执行批量更新。</li></ul><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="说说Mybatis的插件运行原理，如何编写一个插件？"><a href="#说说Mybatis的插件运行原理，如何编写一个插件？" class="headerlink" title="说说Mybatis的插件运行原理，如何编写一个插件？"></a>说说Mybatis的插件运行原理，如何编写一个插件？</h2><h3 id="插件的运行原理？"><a href="#插件的运行原理？" class="headerlink" title="插件的运行原理？"></a>插件的运行原理？</h3><p>Mybatis会话的运行需要ParameterHandler、ResultSetHandler、StatementHandler、Executor这四大对象的配合，插件的原理就是在这四大对象调度的时候，插入一些我我们自己的代码。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901163556036.png" alt="image-20220901163556036"></p><p>Mybatis使用JDK的动态代理，为目标对象生成代理对象。它提供了一个工具类<strong>Plugin</strong>，实现了<strong>InvocationHandler</strong>接口。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901163645793.png" alt="image-20220901163645793"></p><p>使用Plugin生成代理对象，代理对象在调用方法的时候，就会进入invoke方法，在invoke方法中，如果存在签名的拦截方法，插件的intercept方法就会在这里被我们调用，然后就返回结果。如果不存在签名方法，那么将直接反射调用我们要执行的方法。</p><h3 id="如何编写一个插件？"><a href="#如何编写一个插件？" class="headerlink" title="如何编写一个插件？"></a>如何编写一个插件？</h3><p>我们自己编写MyBatis 插件，只需要实现拦截器接又 Interceptor (org.apache.ibatis. pluginInterceptor ），在实现类中对拦截对象和方法进行处理。</p><ul><li>实现Mybatis的Interceptor接又并重写intercept()方法这里我们只是在目标对象执行目标方法的前后进行了打印；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    Properties props=<span class="hljs-literal">null</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;before......&quot;</span>);<br>        <span class="hljs-comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span><br>        <span class="hljs-comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span><br>        Object obj=invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;after......&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>然后再给插件编写注解，确定要拦截的对象，要拦截的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(</span><br><span class="hljs-meta">type = Executor.class, //确定要拦截的对象</span><br><span class="hljs-meta">method = &quot;update&quot;, //确定要拦截的方法</span><br><span class="hljs-meta">args = &#123;MappedStatement.class,Object.class&#125; //拦截方法的参数</span><br><span class="hljs-meta">)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    Properties props=<span class="hljs-literal">null</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;before......&quot;</span>);<br>        <span class="hljs-comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span><br>        <span class="hljs-comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span><br>        Object obj=invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;after......&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在MyBatis配置文件里面配置插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;xxx.MyPlugin&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dbType&quot;</span>,<span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis-分页插件"><a href="#Mybatis-分页插件" class="headerlink" title="Mybatis-分页插件"></a>Mybatis-分页插件</h2><p><strong>分页插件：</strong></p><p><strong>1.添加依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.在mybatis主配置文件中配置分页插件：</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/2600280-20220303161626997-395362475.png" alt="img"></p><p><strong>分页插件使用：</strong></p><p>　　使用mybatis的分页插件实现分页功能：</p><p>　　　　1.需要在查询功能之前开启分页</p><p>　　　　 PageHelper.startPage(2【从第几页开始】,4【每页显示的数据】);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * limit,index,pageSize</span><br><span class="hljs-comment">     * index:当前页的起始索引</span><br><span class="hljs-comment">     * pageSize：每页显示的信息条数</span><br><span class="hljs-comment">     * pageNum：当前的页码</span><br><span class="hljs-comment">     * index=（pageNum-1）*pageSixe</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHelpPage</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;Mybatis.xml&quot;</span>);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(in);<br>            <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(EmpMapper.class);<br>            PageHelper.startPage(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>            List&lt;Emp&gt; emps = mapper.selectByExample(<span class="hljs-literal">null</span>);<br>            PageInfo&lt;Emp&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(emps,<span class="hljs-number">5</span>);<br>            System.out.println(page);<br>            emps.forEach(emp -&gt; System.out.println(emp));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>2.在查询功能结束后获取分页相关信息</p><p>​        PageInfo<Emp> page = new PageInfo&lt;&gt;(emps,5);进行导航分页</p><p>　　emps：表示分页数据</p><p>　　5：表示当前导航分页的数量</p><p>​        运行结果：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/2600280-20220303163713816-2112457012.png" alt="img"></p><p>显示第二页，一页4条数据</p><p>结果具体分析：</p><p>PageInfo{pageNum=2, pageSize=4, size=4, startRow=5, endRow=8, total=11, pages=3, list=Page{count=true, pageNum=2, pageSize=4, startRow=4, endRow=8, total=11, pages=3, reasonable=false, pageSizeZero=false}prePage=1, nextPage=3, isFirstPage=false, isLastPage=false, hasPreviousPage=true, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=3, navigatepageNums=[1, 2, 3]}</p><table><thead><tr><th align="left"><strong>pageNum=2表示当前页码数</strong></th></tr></thead><tbody><tr><td align="left"><strong>pageSize=4：表示一页的数据</strong></td></tr><tr><td align="left"><strong>size=4：这第二页的真实数据个数</strong></td></tr><tr><td align="left"><strong>startRow=5：第二页四个数据从数据库表单中第5个数据开始</strong></td></tr><tr><td align="left"><strong>endRow=8：第二页四个数据从数据库表单中第8个数据结束</strong></td></tr><tr><td align="left"><strong>total=11：数据库表单总数据条数</strong></td></tr><tr><td align="left"><strong>pages=3：总页数</strong></td></tr><tr><td align="left"><strong>prePage=1：这页的上一页</strong></td></tr><tr><td align="left"><strong>nextPage=3：这页的下一页</strong></td></tr><tr><td align="left"><strong>isFirstPage=false：判断是否是第一页</strong></td></tr><tr><td align="left"><strong>isLastPage=false：判断是否是最后一页</strong></td></tr><tr><td align="left"><strong>hasPreviousPage=true：是否有上一页</strong></td></tr><tr><td align="left"><strong>hasNextPage=true：是否有下一页</strong></td></tr><tr><td align="left"><strong>navigatePages=5：这个就是我们在方法中输入的参数（PageInfo<Emp> page = new PageInfo&lt;&gt;(emps,5);）</strong></td></tr><tr><td align="left"><strong><em>navigateFirstPage=1：导航分页从第1页开始</em></strong></td></tr><tr><td align="left"><strong><em>navigateLastPage=3：导航分页从第3页结束</em></strong></td></tr><tr><td align="left"><strong><em>navigatepageNums=[1, 2, 3]：进行底层运算，计算出导航分页页码</em></strong></td></tr></tbody></table><p><strong>总结:</strong></p><p>　　<strong>a&gt;在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能</strong></p><p>　　　　pageNum：当前页的页码        pageSize：每页显示的条数</p><p>　　<strong>b&gt;在查询获取list集合之后，使用PageInfo pageInfo = new PageInfo&lt;&gt;(List list, int navigatePages)获取分页相关数据</strong></p><p>　　　　 list：分页之后的数据         navigatePages：导航分页的页码数</p><p>　　<strong>c&gt;分页相关数据</strong></p><p>　　　　PageInfo{ pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8, list=Page{count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30, pages=8, reasonable=false, pageSizeZero=false}, prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true, hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8, navigatepageNums=[4, 5, 6, 7, 8] }*</p><h3 id="MyBatis是如何分页的？"><a href="#MyBatis是如何分页的？" class="headerlink" title="MyBatis是如何分页的？"></a>MyBatis是如何分页的？</h3><p>MyBatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><h3 id="分页插件的原理是什么？"><a href="#分页插件的原理是什么？" class="headerlink" title="分页插件的原理是什么？"></a>分页插件的原理是什么？</h3><ul><li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，拦截Executor的query方法</li><li>在执行查询的时候，拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</li><li>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑马程序员-SpringBoot2-基础</title>
    <link href="/weiblog/2022/08/26/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/"/>
    <url>/weiblog/2022/08/26/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a><strong>开发环境</strong></h1><p>学习要求</p><p>熟悉Spring基础<br>熟悉Maven使用<br>环境要求</p><p>Java8及以上<br>Maven 3.5及以上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-system-requirements">https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-system-requirements</a><br>学习资料</p><p>Spring Boot官网：<a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p><p>Spring Boot 官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">https://docs.spring.io/spring-boot/docs/current/reference/html/</a></p><p>Spring Boot 中文文档：<a href="http://felord.cn/_doc/_springboot/2.1.5.RELEASE/_book/">http://felord.cn/_doc/_springboot/2.1.5.RELEASE/_book/</a></p><p>视频地址：<a href="https://www.bilibili.com/video/BV15b4y1a7yG?p=24&amp;share_source=copy_web">https://www.bilibili.com/video/BV15b4y1a7yG?p=24&amp;share_source=copy_web</a></p><p>源码地址：GitHub Gitee</p><h1 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a><strong>内容介绍</strong></h1><p>Java基础语法<br><strong>Spring与SpringMVC</strong><br>    知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能<br><strong>Mybatis与Mybatis-Plus</strong><br>    基于Mybatis和MybatisPlus能够开发出包含基础CRUD功能的标准Dao模块<br><strong>数据库MySQL</strong><br>    能够读懂基础CRUD功能的SQL语句<br><strong>服务器</strong><br>    知道服务器与web工程的关系，熟悉web服务器的基础配置<br><strong>maven</strong><br>    知道maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承<br><strong>web技术（含vue，ElementUI)</strong><br>    知道vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定</p><h1 id="SpringBoot框架搭建"><a href="#SpringBoot框架搭建" class="headerlink" title="SpringBoot框架搭建"></a><strong>SpringBoot框架搭建</strong></h1><h2 id="SpringBoot入门案例（Idea联网版）"><a href="#SpringBoot入门案例（Idea联网版）" class="headerlink" title="SpringBoot入门案例（Idea联网版）"></a>SpringBoot入门案例（Idea联网版）</h2><ul><li>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程</li></ul><p>①：创建新模块，选择Spring Initializr，并配置模块相关基础信息</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>②：选择当前模块需要使用的技术集</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-16615262798512.png" alt="img"></p><p>③：开发控制器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Rest 模式</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getById</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;springboot is running...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;springboot is running...&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>④：运行自动生成的Application类</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-16615263437584.png" alt="img"></p><p>⑤：打开浏览器访问url地址为：<a href="http://localhost:8080/books">http://localhost:8080/books</a></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-16615263693396.png" alt="img"></p><p>最简SpringBoot程序所包含的基础文件 (pom.xml文件 和 Application类 )</p><ul><li>pom.xml文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-01-quickstart<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>Application类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot0101QuickstartApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Springboot0101QuickstartApplication.class, args);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Spring程序与SpringBoot程序对比</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-16615265960678.png" alt="img"></p><p><strong>注意: 基于idea开发SpringBoot程序需要确保联网且能够加载到程序框架结构</strong></p><p>小结:</p><ol><li>开发SpringBoot程序可以根据向导进行联网快速制作</li><li>SpringBoot程序需要基于JDK8进行制作</li><li>SpringBoot程序中需要使用何种功能通过勾选选择技术</li><li>运行SpringBoot程序通过运行Application程序入口进行</li></ol><h2 id="SpringBoot入门案例（官网创建版）"><a href="#SpringBoot入门案例（官网创建版）" class="headerlink" title="SpringBoot入门案例（官网创建版）"></a>SpringBoot入门案例（官网创建版）</h2><p>基于SpringBoot官网创建项目，地址：<a href="https://start.spring.io/">https://start.spring.io/</a></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152670467010.png" alt="img"></p><p>小结:</p><ol><li>打开SpringBoot官网，选择Quickstart Your Project</li><li>创建工程，并保存项目</li><li>解压项目，通过IDE导入项目</li></ol><h2 id="SpringBoot入门案例（阿里云版）"><a href="#SpringBoot入门案例（阿里云版）" class="headerlink" title="SpringBoot入门案例（阿里云版）"></a>SpringBoot入门案例（阿里云版）</h2><p>基于阿里云创建项目，地址：<a href="https://start.aliyun.com/">https://start.aliyun.com</a></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152678068812.png" alt="img"></p><p>注意事项:</p><ul><li>阿里云提供的坐标版本较低，如果需要使用高版本，进入工程后手工切换SpringBoot版本</li><li>阿里云提供的工程模板与Spring官网提供的工程模板略有不同</li></ul><p>小结:</p><ol><li>选择start来源为自定义URL</li><li>输入阿里云start地址</li><li>创建项目</li></ol><h2 id="SpringBoot入门案例（手工制作版）"><a href="#SpringBoot入门案例（手工制作版）" class="headerlink" title="SpringBoot入门案例（手工制作版）"></a>SpringBoot入门案例（手工制作版）</h2><p>手工创建项目（手工导入坐标）</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152684169214.png" alt="img"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_01_04_quickstart<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>手工创建项目（手工制作引导类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>小结:</p><ol><li>创建普通Maven工程</li><li>继承spring-boot-starter-parent</li><li>添加依赖spring-boot-starter-web</li><li>制作引导类Application</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>创建SpringBoot工程的四种方式</strong><br><strong>基于Idea创建SpringBoot工程</strong><br><strong>基于官网创建SpringBoot工程</strong><br><strong>基于阿里云创建SpringBoot工程</strong><br><strong>手工创建Maven工程修改为SpringBoot工程</strong></p><h1 id="隐藏文件或文件夹"><a href="#隐藏文件或文件夹" class="headerlink" title="隐藏文件或文件夹"></a><strong>隐藏文件或文件夹</strong></h1><p>.mvn;.gitignore;HELP.md;mvnw;mvnw.cmd;*.iml;</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152716936616.png" alt="img"></p><p>2018版的做法:</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152718849418.png" alt="img"></p><p>较新版本的做法 :</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152720975220.png" alt="img"></p><p>小结:</p><p>Idea中隐藏指定文件或指定类型文件<br>Setting → File Types → Ignored Files and Folders<br>输入要隐藏的文件名，支持*<strong>号通配符</strong><br>回车确认添加</p><h1 id="入门案例解析"><a href="#入门案例解析" class="headerlink" title="入门案例解析"></a><strong>入门案例解析</strong></h1><h2 id="parent"><a href="#parent" class="headerlink" title="parent"></a><strong>parent</strong></h2><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152899995522.png" alt="img"></p><ul><li>parent</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-01-quickstart<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activemq.version</span>&gt;</span>5.15.3<span class="hljs-tag">&lt;/<span class="hljs-name">activemq.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">antlr2.version</span>&gt;</span>2.7.7<span class="hljs-tag">&lt;/<span class="hljs-name">antlr2.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appengine-sdk.version</span>&gt;</span>1.9.63<span class="hljs-tag">&lt;/<span class="hljs-name">appengine-sdk.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artemis.version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">artemis.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aspectj.version</span>&gt;</span>1.8.13<span class="hljs-tag">&lt;/<span class="hljs-name">aspectj.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">assertj.version</span>&gt;</span>3.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">assertj.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">atomikos.version</span>&gt;</span>4.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">atomikos.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bitronix.version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">bitronix.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build-helper-maven-plugin.version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">build-helper-maven-plugin.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">byte-buddy.version</span>&gt;</span>1.7.11<span class="hljs-tag">&lt;/<span class="hljs-name">byte-buddy.version</span>&gt;</span><br>  ... ... ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      ... ... ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kotlin-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;kotlin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jooq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jooq.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>          ... ... ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。</p><p>小结:</p><ul><li>开发SpringBoot程序要继承spring-boot-starter-parent</li><li>spring-boot-starter-parent中定义了若干个依赖管理</li><li>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突</li><li>继承parent的形式也可以采用引入依赖的形式实现效果</li></ul><h2 id="starter"><a href="#starter" class="headerlink" title="starter"></a><strong>starter</strong></h2><ul><li>spring-boot-starter-web.pom<br>按住Ctrl点击pom.xml中的<strong>spring-boot-starter-web</strong>，跳转到了spring-boot-starter-web的pom.xml，xml配置如下（只摘抄了部分重点配置）：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starters<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Boot Web Starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.9.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。<br><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152990382124.png" alt="img"></p><p><strong>starter</strong><br>SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的<br><strong>parent</strong><br>所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的<br>spring-boot-starter-parent各版本间存在着诸多坐标版本不同<br><strong>实际开发</strong><br>使用任意坐标时，仅书写GAV(groupId, artifactId, version)中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V<br>如发生坐标错误，再指定Version（要小心版本冲突）</p><p>小结:</p><ol><li>开发SpringBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到简化配置的目的</li></ol><h2 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h2><ul><li>启动方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot0101QuickstartApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> SpringApplication.run(Springboot0101QuickstartApplication.class, args);<br>        <span class="hljs-comment">//获取bean对象</span><br>        <span class="hljs-type">BookController</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> ctx.getBean(BookController.class);<br>        System.out.println(<span class="hljs-string">&quot;bean======&gt;&quot;</span> + bean);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目</li><li>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</li></ul><p>小结:</p><ol><li>SpringBoot工程提供引导类用来启动程序</li><li>SpringBoot工程启动后创建并初始化Spring容器</li></ol><h2 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h2><p>辅助功能 内嵌tomcat</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><ul><li>使用maven依赖管理变更起步依赖项</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--web 起步依赖环境中，排除 Tomcat 起步依赖 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加 Jetty 起步依赖，版本由 SpringBoot 的 starter 控制 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>Jetty比Tomcat更轻量级，可扩展性更强（相较于Tomcat），谷歌应用引擎（GAE）已经全面切换为Jetty</li><li>内置服务器<ul><li>tomcat(默认) apache出品，粉丝多，应用面广，负载了若干较重的组件</li><li>jetty 更轻量级，负载性能远不及tomcat</li><li>undertow undertow，负载性能勉强跑赢tomcat</li></ul></li></ul><p>小结:</p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><p>总结:</p><ol><li>入门案例（4种方式）</li><li>SpringBoot概述<br>parent<br>starter<br>引导类<br>辅助功能（内嵌tomcat）</li></ol><h1 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a><strong>REST风格</strong></h1><h2 id="REST风格简介"><a href="#REST风格简介" class="headerlink" title="REST风格简介"></a>REST风格简介</h2><p><strong>什么是 rest ：</strong></p><p>REST（Representational State Transfer）表现形式状态转换</p><p>传统风格资源描述形式<br><a href="http://localhost/user/getById?id=1">http://localhost/user/getById?id=1</a> (得到id为1的用户)<br><a href="http://localhost/user/saveUser">http://localhost/user/saveUser</a> (保存用户)</p><p>REST风格描述形式<br><a href="http://localhost/user/1">http://localhost/user/1</a> (得到id为1的用户)<br><a href="http://localhost/user">http://localhost/user</a> (保存用户)</p><p><strong>优点:</strong></p><ul><li>隐藏资源的访问行为， 无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul><p>按照REST风格访问资源时使用<strong>行为动作</strong>区分对资源进行了何种操作</p><p><strong>GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://localhost/users 查询全部用户信息 GET (查询)<br>http://localhost/users/1 查询指定用户信息 GET (查询)<br>http://localhost/users 添加用户信息 POST (新增/保存)<br>http://localhost/users 修改用户信息 PUT (修改/更新)<br>http://localhost/users/1 删除用户信息 DELETE (删除)<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范<br>描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源,而非单个资源，例如: users、 books、 accounts…</p><p>根据REST风格对资源进行访问称为<strong>RESTful</strong></p><p>小结：</p><ol><li>REST</li><li>动作4个</li><li>RESTful</li></ol><h2 id="RESTful入门案例"><a href="#RESTful入门案例" class="headerlink" title="RESTful入门案例"></a><strong>RESTful入门案例</strong></h2><p>步骤:</p><p>①:设定http请求动作(动词)</p><p>使用 @RequestMapping 注解的 method 属性声明请求的方式</p><p>使用 @RequestBody 注解 获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。get 请求方式不适用。</p><p>使用@ResponseBody 注解实现将 controller 方法返回对象转换为 json 响应给客户端。</p><p>@RequestMapping(value=”/users”,method=RequestMethod.POST)</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/8fc4afea23a513d605b885db910e2ac8.png" alt="image-20220111162324969"></p><p>②:设定请求参数(路径变量)</p><p>使用<code>@PathVariable</code> 用于绑定 url 中的占位符。例如：请求 url 中 /delete/<code>&#123;id&#125;</code>，这个<code>&#123;id&#125;</code>就是 url 占位符。</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/d35b1e484bae94e8f5b5c5804610afbe.png" alt="image-20220111163317065"></p><ul><li>@RequestMapping</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/1b6cff3e21c9f8f39d03609ca5549dc5.png" alt="image-20220111163720579"></p><ul><li>@PathVariable</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/70f82ea4f1c61a34eb68fda48cc9ada3.png" alt="image-20220111163858308"></p><ul><li>@RequestBody @RequestParam @PathVariable</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/9b9324456b495d978751d23ce868c101.png" alt="image-20220111164352046"></p><h2 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a><strong>RESTful快速开发</strong></h2><ul><li>使用 <strong>@RestController</strong> 注解开发 RESTful 风格</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/image-20220828011434213.png" alt="image-20220828011434213"></p><ul><li>使用 <strong>@GetMapping @PostMapping @PutMapping @DeleteMapping</strong> 简化 <strong>@RequestMapping</strong> 注解开发</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/image-20220828011609581.png" alt="image-20220828011609581"></p><h1 id="复制模块"><a href="#复制模块" class="headerlink" title="复制模块"></a><strong>复制模块</strong></h1><p>原则<br>保留工程基础结构<br>抹掉原始工程痕迹</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/b0eba06b936d4243b47b6faaf3842e95.png" alt="在这里插入图片描述"></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/5f36f2235926f2a2a7aa521a850a7109.png" alt="img"></p><p>在IDEA 中点击模块管理添加模块</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/image-20220828223123256.png" alt="image-20220828223123256"></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/image-20220828223205172.png" alt="image-20220828223205172"></p><p>小结:</p><ol><li>在工作空间中复制对应工程，并修改工程名称</li><li>删除与Idea相关配置文件，仅保留src目录与pom.xml文件</li><li>修改pom.xml文件中的artifactId与新工程/模块名相同</li><li>删除name标签（可选）</li><li>保留备份工程供后期使用</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
