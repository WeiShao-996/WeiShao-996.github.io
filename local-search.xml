<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试-Java并发编程</title>
    <link href="/weiblog/2022/09/02/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/weiblog/2022/09/02/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h2><p>先从总体上来说：</p><ul><li><p><strong>从计算机底层来说：</strong> 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</p></li><li><p><strong>从当代互联网发展趋势来说：</strong> 现在的系统动不动就要求百万级甚至千万级的并发量，而<strong>多线程并发编程</strong>正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p></li></ul><p>再深入到计算机底层来探讨：</p><ul><li><p><strong>单核时代</strong>： 在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。</p></li><li><p><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间/CPU 核心数）。</p></li></ul><h2 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h2><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。</p><h2 id="并行跟并发有什么区别？"><a href="#并行跟并发有什么区别？" class="headerlink" title="并行跟并发有什么区别？"></a>并行跟并发有什么区别？</h2><p>从操作系统的角度来看，线程是CPU分配的最小单位。</p><ul><li>并行就是同一时刻，两个线程都在执行。这就要求有两个CPU去分别执行两个线程。</li><li>并发就是同一时刻，只有一个执行，但是一个时间段内，两个线程都执行了。并发的实现依赖于CPU切换线程，因为切换的时间特别短，所以基本对于用户是无感知的。</li></ul><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114109343.png" alt="image-20220902114109343"></p><p>就好像我们去食堂打饭，并行就是我们在多个窗又排队，几个阿姨同时打菜；并发就是我们挤在一个窗又，阿姨给这个打一勺，又手忙脚乱地给那个打一勺。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902114143558.png" alt="image-20220902114143558"></p><h2 id="说说什么是进程和线程？"><a href="#说说什么是进程和线程？" class="headerlink" title="说说什么是进程和线程？"></a>说说什么是进程和线程？</h2><p>要说线程，必须得先说说进程。</p><ul><li>进程：进程是代码在数据集合上的一次运行活动，是<strong>系统进行资源分配和调度的基本单位</strong>。</li><li>线程：线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</li></ul><p>操作系统在分配资源时是把资源分配给进程的， 但是 CPU 资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以也说线程是 CPU分配的基本单位。</p><p>比如在Java中，当我们启动 main 函数其实就启动了一个JVM进程，而 main 函数在的线程就是这个进程中的一个线程，也称主线程。</p><p>一个进程中有多个线程，多个线程共用进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140118921.png" alt="image-20220902140118921"></p><h2 id="说说线程有几种创建方式"><a href="#说说线程有几种创建方式" class="headerlink" title="说说线程有几种创建方式"></a>说说线程有几种创建方式</h2><p>Java中创建线程主要有三种方式，分别为继承<strong>Thread</strong>类、实现<strong>Runnable</strong>接口、实现<strong>Callable</strong>接口。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902140459345.png" alt="image-20220902140459345"></p><ul><li><h3 id="继承Thread类，重写run-方法，调用start-方法启动线程"><a href="#继承Thread类，重写run-方法，调用start-方法启动线程" class="headerlink" title="继承Thread类，重写run()方法，调用start()方法启动线程"></a>继承Thread类，重写run()方法，调用start()方法启动线程</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    继承Thread类</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;This is child thread&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h3 id="实现-Runnable-接口，重写run-方法"><a href="#实现-Runnable-接口，重写run-方法" class="headerlink" title="实现 Runnable 接口，重写run()方法"></a>实现 Runnable 接口，重写run()方法</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Runnable!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RunnableTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableTask</span>();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面两种都是没有返回值的，但是如果我们需要获取线程的执行结果，该怎么办呢？</p><ul><li><h3 id="实现Callable接又，重写call-方法，这种方式可以通过FutureTask获取任务执行的返回值"><a href="#实现Callable接又，重写call-方法，这种方式可以通过FutureTask获取任务执行的返回值" class="headerlink" title="实现Callable接又，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值"></a>实现Callable接又，重写call()方法，这种方式可以通过FutureTask获取任务执行的返回值</h3></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,i am running!&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>                <span class="hljs-comment">//创建异步任务</span><br>                FutureTask&lt;String&gt; task=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallerTask</span>());<br>                <span class="hljs-comment">//启动线程</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//等待执行完成，并获取返回结果</span><br>                String result=task.get();<br>                System.out.println(result);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？"><a href="#为什么调用start-方法时会执行run-方法，那怎么不直接调用run-方法？" class="headerlink" title="为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？"></a>为什么调用start()方法时会执行run()方法，那怎么不直接调用run()方法？</h2><p>JVM执行start方法，会先创建一条线程，由创建出来的新线程去执行thread的run方法，这才起到多线程的效果。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141434005.png" alt="image-20220902141434005"></p><p><strong>为什么我们不能直接调用run()方法？</strong> 也很清楚， 如果直接调用Thread的run()方法，那么run方法还是运行在主线程中，相当于顺序执行，就起不到多线程的效果。</p><h2 id="线程有哪些常用的调度方法？"><a href="#线程有哪些常用的调度方法？" class="headerlink" title="线程有哪些常用的调度方法？"></a>线程有哪些常用的调度方法？</h2><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902141608203.png" alt="image-20220902141608203"></p><h3 id="线程等待与通知"><a href="#线程等待与通知" class="headerlink" title="线程等待与通知"></a>线程等待与通知</h3><p>在Object类中有一些函数可以用于线程的等待与通知。</p><ul><li><p>**wait()**：当一个线程A调用一个共享变量的 wait()方法时， 线程A会被阻塞挂起， 发生下面几种情况才会返回 ：</p><ul><li><p>（ 1 ） 线程A调用了共享对象 notify()或者 notifyAll()方法；</p></li><li><p>（ 2 ）其他线程调用了线程A的 interrupt() 方法，线程A抛出InterruptedException异常返回。</p></li></ul></li><li><p><strong>wait(long timeout)</strong> ：这个方法相比 wait() 方法多了一个超时参数，它的不同之处在于，如果线程A调用共享对象的wait(long timeout)方法后，没有在指定的 timeout ms时间内被其它线程唤醒，那么这个方法还是会因为超时而返回。</p></li><li><p>**wait(long timeout, int nanos)**，其内部调用的是 wait(long timout）函数。</p></li></ul><p>上面是线程等待的方法，而唤醒线程主要是下面两个方法：</p><ul><li><strong>notify()</strong> : 一个线程A调用共享对象的 notify() 方法后，会唤醒一个在这个共享变量上调用wait 系列方法后被挂起的线程。 一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。</li><li><strong>notifyAll()</strong> ：不同于在共享变量上调用 notify() 函数会唤醒被阻塞到该共享变量上的一个线程，notifyAll()方法则会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。</li></ul><p>Thread类也提供了一个方法用于等待的方法：</p><ul><li>**join()**：如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。</li></ul><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><ul><li><strong>sleep(long millis)</strong> :Thread类中的静态方法，当一个执行中的线程A调用了Thread 的sleep方法后，线程A会暂时让出指定时间的执行权，但是线程A所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，接着参与 CPU 的调度，获取到 CPU 资源后就可以继续运行。</li></ul><h3 id="让出优先权"><a href="#让出优先权" class="headerlink" title="让出优先权"></a>让出优先权</h3><ul><li><strong>yield()</strong> ：Thread类中的静态方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU ，但是线程调度器可以无条件忽略这个暗示。</li></ul><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。</p><ul><li><strong>void interrupt()</strong> ：中断线程，例如，当线程A运行时，线程B可以调用钱程interrupt() 方法来设置线程的中断标志为true 并立即返回。设置标志仅仅是设置标志, 线程A实际并没有被中断， 会继续往下执行。</li><li><strong>boolean isInterrupted() 方法</strong>： 检测当前线程是否被中断。</li><li><strong>boolean interrupted() 方法</strong>： 检测当前线程是否被中断，与 <strong>isInterrupted</strong> 不同的是，该方法如果发现当前线程被中断，则会清除中断标志。</li></ul><h2 id="线程有几种状态？"><a href="#线程有几种状态？" class="headerlink" title="线程有几种状态？"></a>线程有几种状态？</h2><p>在Java中，线程共有六种状态：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902145605462.png" alt="image-20220902145605462"></p><p>线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160048587.png" alt="image-20220902160048587"></p><h2 id="什么是线程上下文切换？"><a href="#什么是线程上下文切换？" class="headerlink" title="什么是线程上下文切换？"></a>什么是线程上下文切换？</h2><p>使用多线程的目的是为了充分利用CPU，但是我们知道，并发其实是一个CPU来应付多个线程。<img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160358011.png" alt="image-20220902160358011"></p><p>为了让用户感觉多个线程是在同时执行的， CPU 资源的分配采用了时间片轮转也就是给每个线程分配一个时间片，线程在时间片内占用 CPU 执行任务。当线程使用完时间片后，就会处于就绪状态并让出 CPU 让其他线程占用，这就是上下文切换。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160517970.png" alt="image-20220902160517970"></p><h2 id="守护线程了解吗？"><a href="#守护线程了解吗？" class="headerlink" title="守护线程了解吗？"></a>守护线程了解吗？</h2><ul><li>Java中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。</li><li>在JVM 启动时会调用 main 函数，main函数所在的钱程就是一个用户线程。其实在 JVM 内部同时还启动了很多守护线程， 比如垃圾回收线程。</li><li>那么守护线程和用户线程有什么区别呢？区别之一是当最后一个非守护线程束时， JVM会正常退出，而不管当前是否存在守护线程，也就是说守护线程是否结束并不影响 JVM退出。换而言之，只要有一个用户线程还没结束，正常情况下JVM就不会退出。</li></ul><h2 id="线程间有哪些通信方式？"><a href="#线程间有哪些通信方式？" class="headerlink" title="线程间有哪些通信方式？"></a>线程间有哪些通信方式？</h2><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902160908374.png" alt="image-20220902160908374"></p><h3 id="volatile和synchronized关键字"><a href="#volatile和synchronized关键字" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h3><ul><li><p>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</p></li><li><p>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p></li></ul><h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a><strong>等待/通知机制</strong></h3><ul><li>可以通过Java内置的等待/通知机制（wait()/notify()）实现一个线程修改一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。</li></ul><h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a><strong>管道输入/输出流</strong></h3><ul><li><p><strong>管道输入/输出流</strong>和<strong>普通的文件输入/输出流</strong>或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</p></li><li><p>管道输入/输出流主要包括了如下 4 种具体实现：<strong>PipedOutputStream、PipedInputStream、PipedReader和PipedWriter</strong>，前两种面向字节，而后两种面向字符。</p></li></ul><h3 id="使用Thread-join"><a href="#使用Thread-join" class="headerlink" title="使用Thread.join()"></a>使用Thread.join()</h3><ul><li>如果一个线程A执行了<strong>thread.join()**语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了</strong>join(long millis)<strong>和</strong>join(long millis,int nanos)**两个具备超时特性的方法。</li></ul><h3 id="使用ThreadLocal"><a href="#使用ThreadLocal" class="headerlink" title="使用ThreadLocal"></a>使用ThreadLocal</h3><ul><li><p><strong>ThreadLocal</strong>，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</p></li><li><p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p></li></ul><h2 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul><li><p>两者最主要的区别在于：<strong>sleep() 方法没有释放锁，而 wait() 方法释放了锁</strong> 。</p></li><li><p>两者都可以<strong>暂停线程</strong>的执行。</p></li><li><p><strong>wait()</strong> 通常被用于线程间交互/通信，<strong>sleep()</strong> 通常被用于暂停执行。</p></li><li><p><strong>wait()</strong> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <strong>notify()</strong> 或者 <strong>notifyAll()</strong> 方法。<strong>sleep()</strong> 方法执行完成后，线程会自动苏醒。或者可以使用 <strong>wait(long timeout)</strong> 超时后线程会自动苏醒。</p></li></ul><h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用：</p><p>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。<br>在多线程的情况下，<strong>程序计数器用于记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>需要注意的是，如果执行的是 <strong>native</strong> 方法，那么程序计数器记录的是 <strong>undefined</strong> 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，<strong>程序计数器私有主要是为了线程切换后能恢复到正确的执行位置</strong>。</p><h2 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h2><ul><li><strong>虚拟机栈：</strong> 每个 Java 方法在执行的同时会创建一个<strong>栈帧</strong>用于存储<strong>局部变量表、操作数栈、常量池</strong>引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong> 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是<strong>线程私有的</strong>。</p><h2 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h2><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/2019-4%E6%AD%BB%E9%94%811.png" alt="线程死锁示意图 "></p><p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//资源 2</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource1<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource2<br>Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource2<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource1<br></code></pre></td></tr></table></figure><p>线程 A 通过 <code>synchronized (resource1)</code> 获得 <code>resource1</code> 的监视器锁，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p>上面的例子符合产生死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="如何预防和避免线程死锁"><a href="#如何预防和避免线程死锁" class="headerlink" title="如何预防和避免线程死锁?"></a>如何预防和避免线程死锁?</h3><p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p><ol><li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li><li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li></ol><p><strong>如何避免死锁？</strong></p><p>避免死锁就是在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><blockquote><p><strong>安全状态</strong> 指的是系统能够按照某种线程推进顺序（P1、P2、P3…..Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 <code>&lt;P1、P2、P3.....Pn&gt;</code> 序列为安全序列。</p></blockquote><p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;waiting get resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread() + <span class="hljs-string">&quot;get resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;线程 2&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource1<br>Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]waiting get resource2<br>Thread[线程 <span class="hljs-number">1</span>,<span class="hljs-number">5</span>,main]get resource2<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource1<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]waiting get resource2<br>Thread[线程 <span class="hljs-number">2</span>,<span class="hljs-number">5</span>,main]get resource2<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们分析一下上面的代码为什么避免了死锁的发生?</p><p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>ThreadLocal，也就是线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902163020732.png" alt="image-20220902163020732"></p><ul><li><p>创建</p><p>创建了一个<strong>ThreadLocal</strong>变量<strong>localVariable</strong>，任何一个线程都能并发访问<strong>localVariable</strong>。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建一个ThreadLocal变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li><p>写入</p><p>线程可以在任何地方使用<strong>localVariable</strong>，写入变量。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">localVariable.set(<span class="hljs-string">&quot;鄙人三某”);</span><br></code></pre></td></tr></table></figure><ul><li>读取<br>线程在任何地方读取的都是它写入的变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">localVariable.get();<br></code></pre></td></tr></table></figure><h2 id="你在工作中用到过ThreadLocal吗？"><a href="#你在工作中用到过ThreadLocal吗？" class="headerlink" title="你在工作中用到过ThreadLocal吗？"></a>你在工作中用到过ThreadLocal吗？</h2><p>有用到过的，用来做用户信息上下文的存储。</p><p>我们的系统应用是一个典型的MVC架构，登录后的用户每次访问接又，都会在请求头中携带</p><p>一个token，在控制层可以根据这个token，解析出用户的基本信息。那么问题来了，假如在服务层和持久层都要用到用户信息，比如rpc调用、更新用户获取等等，那应该怎么办呢？</p><p>一种办法是显式定义用户相关的参数，比如账号、用户名……这样一来，我们可能需要大面积地修改代码，多少有点瓜皮，那该怎么办呢？</p><p>这时候我们就可以用到ThreadLocal，在控制层拦截请求把用户信息存入ThreadLocal，这样我们在任何一个地方，都可以取ThreadLocal中存的用户数据。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902170811800.png" alt="image-20220902170811800"></p><p>很多其它场景的cookie、session等等数据隔离也都可以通过ThreadLocal去实现。</p><p>我们常用的数据库连接池也用到了ThreadLocal：</p><ul><li>数据库连接池的连接交给ThreadLoca进行管理，保证当前线程的操作都是同一个Connnection。</li></ul><h2 id="ThreadLocal怎么实现的呢？"><a href="#ThreadLocal怎么实现的呢？" class="headerlink" title="ThreadLocal怎么实现的呢？"></a>ThreadLocal怎么实现的呢？</h2><p>我们看一下ThreadLocal的set(T)方法，发现先获取到当前线程，再获取ThreadLocalMap，然后把元素存到这个map中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">//获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">//获取ThreadLocalMap</span><br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-comment">//讲当前元素存入map</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>    map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>    createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>ThreadLocal</strong>实现的秘密都在这个<strong>ThreadLocalMap</strong>了，Thread类中定义了一个类型为<strong>ThreadLocal.ThreadLocalMap</strong>的成员变量<strong>threadLocals</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">//ThreadLocal.ThreadLocalMap是Thread的属性</span><br>    ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThreadLocalMap既然被称为Map，那么毫无疑问它是&lt;key,value&gt;型的数据结构。我们都知道map的本质是一个个&lt;key,value&gt;形式的节点组成的数组，那ThreadLocalMap的节点是什么样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br>    <span class="hljs-comment">//节点类</span><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-comment">//key赋值</span><br>        <span class="hljs-built_in">super</span>(k);<br>        <span class="hljs-comment">//value赋值</span><br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的节点，key可以简单低视作ThreadLocal，value为代码中放入的值，当然实际上key并不是ThreadLocal本身，而是它的一个 <strong>弱引用</strong> ，可以看到Entry的key继承了 WeakReference（弱引用），再来看一下key怎么赋值的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">WeakReference</span><span class="hljs-params">(T referent)</span> &#123;<br><span class="hljs-built_in">super</span>(referent);<br>&#125;<br></code></pre></td></tr></table></figure><p>key的赋值，使用的是WeakReference的赋值。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902173027266.png" alt="image-20220902173027266"></p><p>所以，怎么回答ThreadLocal原理？要答出这几个点：</p><ul><li>Thread类有一个类型为<strong>ThreadLocal.ThreadLocalMap</strong>的实例变量<strong>threadLocals</strong>，每个线程都有一个属于自己的<strong>ThreadLocalMap</strong>。</li><li><strong>ThreadLocalMap</strong>内部维护着Entry数组，每个Entry代表一个完整的对象，key是<strong>ThreadLocal的弱引用</strong>，value是<strong>ThreadLocal的泛型值</strong>。</li><li>每个线程在往<strong>ThreadLocal</strong>里设置值的时候，都是往自己的<strong>ThreadLocalMap</strong>里存，读也是以某个<strong>ThreadLocal</strong>作为引用，在自己的map里找对应的key，从而实现了线程隔离。</li><li>ThreadLocal本身不存储值，它只是作为一个<strong>key</strong>来让线程往<strong>ThreadLocalMap</strong>里存取值。</li></ul><h2 id="ThreadLocal-内存泄露是怎么回事？"><a href="#ThreadLocal-内存泄露是怎么回事？" class="headerlink" title="ThreadLocal 内存泄露是怎么回事？"></a>ThreadLocal 内存泄露是怎么回事？</h2><p>我们先来分析一下使用<strong>ThreadLocal</strong>时的内存，我们都知道，在<strong>JVM</strong>中，<strong>栈内存线程私有</strong>，存储了对象的引用，<strong>堆内存线程共享</strong>，存储了对象实例。</p><p>所以呢，栈中存储了ThreadLocal、Thread的引用，堆中存储了它们的具体实例。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902193325147.png" alt="image-20220902193325147"></p><p><strong>ThreadLocalMap</strong>中使用的 key 为 <strong>ThreadLocal</strong> 的弱引用。</p><p><em>“弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。”</em></p><p>那么现在问题就来了，弱引用很容易被回收，如果<strong>ThreadLocal（ThreadLocalMap的Key）</strong>被垃圾回收器回收了，但是<strong>ThreadLocalMap</strong>生命周期和<strong>Thread</strong>是一样的，它这时候如果不被回收，就会出现这种情况：<strong>ThreadLocalMap</strong>的<strong>key</strong>没了，<strong>value</strong>还在，这就会 <strong>造成了内存泄漏问题</strong> 。</p><h2 id="那怎么解决内存泄漏问题呢？"><a href="#那怎么解决内存泄漏问题呢？" class="headerlink" title="那怎么解决内存泄漏问题呢？"></a>那怎么解决内存泄漏问题呢？</h2><p>很简单，使用完<strong>ThreadLocal</strong>后，及时调用<strong>remove</strong>()方法释放内存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; localVariable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>    localVariable.set(<span class="hljs-string">&quot;鄙人三某”);</span><br><span class="hljs-string">    ......</span><br><span class="hljs-string">    &#125; finally &#123;</span><br><span class="hljs-string">    localVariable.remove();</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>那为什么key还要设计成弱引用？</p><p>key设计成弱引用同样是为了防止内存泄漏。</p><p>假如key被设计成强引用，如果ThreadLocal Reference被销毁，此时它指向ThreadLoca的强引用就没有了，但是此时key还强引用指向ThreadLoca，就会导致ThreadLocal不能被回收，这时候就发生了内存泄漏的问题。</p><h2 id="ThreadLocalMap的结构了解吗？"><a href="#ThreadLocalMap的结构了解吗？" class="headerlink" title="ThreadLocalMap的结构了解吗？"></a>ThreadLocalMap的结构了解吗？</h2><p>ThreadLocalMap虽然被叫做Map，其实它是没有实现Map接又的，但是结构还是和HashMap比较类似的，主要关注的是两个要素：<strong>元素数组和散列方法。</strong></p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902194739313.png" alt="image-20220902194739313"></p><p><strong>元素数组</strong></p><p>一个table数组，存储Entry类型的元素，Entry是ThreaLocal弱引用作为key，Object作为value的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Entry[] table;<br></code></pre></td></tr></table></figure><p><strong>散列方法</strong></p><p>散列方法就是怎么把对应的key映射到table数组的相应下标，ThreadLocalMap用的是哈希取余法，取出key的threadLocalHashCode，然后和table数组长度减一&amp;运算（相当于取余）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="hljs-number">1</span> );<br></code></pre></td></tr></table></figure><p>这里的<strong>threadLocalHashCode</strong>计算有点东西，每创建一个<strong>ThreadLocal</strong>对象，它就会新增<strong>0x61c88647</strong>，这个值很特殊，它是 <strong>斐波那契数</strong> 也叫 <strong>黄金分割数</strong> 。hash增量为 这个数字，带来的好处就是 hash <strong>分布非常均匀</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HASH_INCREMENT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x61c88647</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextHashCode</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadLocalMap怎么解决Hash冲突的？"><a href="#ThreadLocalMap怎么解决Hash冲突的？" class="headerlink" title="ThreadLocalMap怎么解决Hash冲突的？"></a>ThreadLocalMap怎么解决Hash冲突的？</h2><p>我们可能都知道<strong>HashMap</strong>使用了链表来解决冲突，也就是所谓的链地址法。</p><p><strong>ThreadLocalMap</strong>没有使用链表，自然也不是用链地址法来解决冲突了，它用的是另外一种方式—— <strong>开放定址法</strong> 。开放定址法是什么意思呢？简单来说，就是这个坑被人占了，那就接着去找空着的坑。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902212750305.png" alt="image-20220902212750305"></p><p>如上图所示，如果我们插入一个value=27的数据，通过 hash计算后应该落入第 4 个槽位中，而槽位 4 已经有了 Entry数据，而且Entry数据的key和当前不相等。此时就会线性向后查找，一直找到 Entry为 null的槽位才会停止查找，把元素放到空的槽中。</p><p>在get的时候，也会根据ThreadLocal对象的hash值，定位到table中的位置，然后判断该槽位Entry对象中的key是否和get的key一致，如果不一致，就判断下一个位置。</p><h2 id="ThreadLocalMap扩容机制了解吗？"><a href="#ThreadLocalMap扩容机制了解吗？" class="headerlink" title="ThreadLocalMap扩容机制了解吗？"></a>ThreadLocalMap扩容机制了解吗？</h2><p>在<strong>ThreadLocalMap.set()**方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中</strong>Entry<strong>的数量已经达到了列表的扩容阈值</strong>(len*2/3)<strong>，就开始执行</strong>rehash()**逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>rehash();<br></code></pre></td></tr></table></figure><p>再着看<strong>rehash</strong>()具体实现：这里会先去清理过期的<strong>Entry</strong>，然后还要根据条件判断<strong>size &gt;=threshold - threshold / 4</strong> 也就是*<em>size &gt;= threshold</em> 3/4**来决定是否需要扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)<br>    rehash();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rehash</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//清理过期Entry</span><br>        expungeStaleEntries();<br>        <span class="hljs-comment">//扩容</span><br>        <span class="hljs-keyword">if</span> (size &gt;= threshold - threshold / <span class="hljs-number">4</span> )<br>        resize();<br>    &#125;<br>    <span class="hljs-comment">//清理过期Entry</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">expungeStaleEntries</span><span class="hljs-params">()</span> &#123;<br>        Entry[] tab = table;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> tab.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; j &lt; len; j++) &#123;<br>        <span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> tab[j];<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span> &amp;&amp; e.get() == <span class="hljs-literal">null</span>)<br>        expungeStaleEntry(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着看看具体的<strong>resize</strong>()方法，扩容后的<strong>newTab</strong>的大小为老数组的两倍，然后遍历老的table数组，散列方法重新计算位置，开放地址解决冲突，然后放到新的newTab，遍历完成之后，<strong>oldTab</strong>中所有的<strong>entry</strong>数据都已经放入到<strong>newTab</strong>中了，然后table引用指向<strong>newTab</strong></p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213343066.png" alt="image-20220902213343066"></p><p>具体代码：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220902213432939.png" alt="image-20220902213432939"></p><h2 id="父子线程怎么共享数据"><a href="#父子线程怎么共享数据" class="headerlink" title="父子线程怎么共享数据"></a>父子线程怎么共享数据</h2><p>父线程能用ThreadLocal来给子线程传值吗？毫无疑问，不能。那该怎么办？</p><p>这时候可以用到另外一个类——<strong>InheritableThreadLocal</strong>。</p><p>使用起来很简单，在主线程的<strong>InheritableThreadLocal</strong>实例设置值，在子线程中就可以拿到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InheritableThreadLocalTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">threadLocal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>();<br>            <span class="hljs-comment">// 主线程</span><br>            threadLocal.set(<span class="hljs-string">&quot;不擅技术&quot;</span>);<br>            <span class="hljs-comment">//子线程</span><br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">super</span>.run();<br>            System.out.println(<span class="hljs-string">&quot;鄙人三某 ，&quot;</span> + threadLocal.get());<br>            &#125;<br>        &#125;;<br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="那原理是什么呢？"><a href="#那原理是什么呢？" class="headerlink" title="那原理是什么呢？"></a>那原理是什么呢？</h4><p>原理很简单，在Thread类里还有另外一个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">inheritableThreadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>在<strong>Thread.init</strong>的时候，如果父线程的<strong>inheritableThreadLocals</strong>不为空，就把它赋给当前线程（子线程）的<strong>inheritableThreadLocals</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-literal">null</span>)<br><span class="hljs-built_in">this</span>.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br></code></pre></td></tr></table></figure><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="说一下你对Java内存模型（JMM）的理解？"><a href="#说一下你对Java内存模型（JMM）的理解？" class="headerlink" title="说一下你对Java内存模型（JMM）的理解？"></a>说一下你对Java内存模型（JMM）的理解？</h2><p>Java内存模型（<strong>Java Memory Model</strong>，JMM），是一种<strong>抽象的模型</strong>，被定义出来屏蔽各种硬件和操作系统的<strong>内存访问差异</strong>。</p><p>JMM定义了<strong>线程和主内存</strong>之间的抽象关系：线程之间的<strong>共享变量</strong>存储在主内存（<strong>Main Memory</strong>）中，每个线程都有一个私有的本地内存（<strong>Local Memory</strong>），本地内存中存储了该线程<strong>以读/写共享变量的副本</strong>。</p><p>Java内存模型的抽象图：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114356751.png" alt="image-20220903114356751"></p><p>本地内存是JMM的 一个抽象概念，并不真实存在。它其实涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903114449779.png" alt="image-20220903114449779"></p><p>图里面的是一个<strong>双核 CPU 系统架构</strong> ，每个核有自己的<strong>控制器和运算器</strong>，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的<strong>一级缓存</strong>，在有些架构里面还有一个<strong>所有 CPU 共享的二级缓存</strong>。 那么 Java 内存模型里面的工作内存，就对应这里的 Ll 缓存或者 L2 缓存或者 CPU 寄存器。</p><h2 id="说说你对原子性、可见性、有序性的理解"><a href="#说说你对原子性、可见性、有序性的理解" class="headerlink" title="说说你对原子性、可见性、有序性的理解"></a>说说你对原子性、可见性、有序性的理解</h2><p>原子性、有序性、可见性是并发编程中非常重要的基础概念，JMM的很多技术都是围绕着这三大特性展开。</p><ul><li><strong>原子性</strong>：原子性指的是一个操作是不可分割、不可中断的，要么全部执行并且执行的过程不会被任何因素打断，要么就全不执行。</li><li><strong>可见性</strong>：可见性指的是一个线程修改了某一个共享变量的值时，其它线程能够立即知道这个修改。</li><li><strong>有序性</strong>：有序性指的是对于一个线程的执行代码，从前往后依次执行，单线程下可以认为程序是有序的，但是并发时有可能会发生指令重排。</li></ul><h3 id="分析下面几行代码的原子性？"><a href="#分析下面几行代码的原子性？" class="headerlink" title="分析下面几行代码的原子性？"></a>分析下面几行代码的原子性？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> ;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>i++;<br>i = i + <span class="hljs-number">1</span> ;<br></code></pre></td></tr></table></figure><ul><li>第 1 句是基本类型赋值，是原子性操作。</li><li>第 2 句先读i的值，再赋值到j，两步操作，不能保证原子性。</li><li>第 3 和第 4 句其实是等效的，先读取i的值，再+1，最后赋值到i，三步操作了，不能保证原子性。</li></ul><h3 id="原子性、可见性、有序性都应该怎么保证呢？"><a href="#原子性、可见性、有序性都应该怎么保证呢？" class="headerlink" title="原子性、可见性、有序性都应该怎么保证呢？"></a>原子性、可见性、有序性都应该怎么保证呢？</h3><ul><li><strong>原子性</strong>：JMM只能保证基本的原子性，如果要保证一个代码块的原子性，需要使用<strong>synchronized</strong> 。</li><li><strong>可见性</strong>：Java是利用<strong>volatile</strong> 关键字来保证可见性的，除此之外，<strong>final</strong> 和<strong>synchronized</strong> 也能保证可见性。</li><li><strong>有序性</strong>：<strong>synchronized</strong> 或者<strong>volatile</strong> 都可以保证多线程之间操作的有序性。</li></ul><h2 id="那说说什么是指令重排？"><a href="#那说说什么是指令重排？" class="headerlink" title="那说说什么是指令重排？"></a>那说说什么是指令重排？</h2><p>在执行程序时，为了提高性能，<strong>编译器和处理器</strong>常常会对指令做重排序。重排序分 3 种类型。</p><ol><li><p><strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p></li><li><p><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应 机器指令的执行顺序。</p></li><li><p><strong>内存系统的重排序</strong>。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p></li></ol><p>从Java源代码到最终实际执行的指令序列，会分别经历下面 3 种重排序，如图：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903115952545.png" alt="image-20220903115952545"></p><p>我们比较熟悉的<strong>双重校验单例模式</strong>就是一个经典的指令重排的例子，<strong>Singleton instance=new Singleton()；</strong>对应的JVM指令分为三步：<strong>分配内存空间–&gt;初始化对象—&gt;对象指向分配的内存空间</strong>，但是经过了编译器的指令重排序，第二步和第三步就可能会重排序。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133213700.png" alt="image-20220903133213700"></p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h2 id="指令重排有限制吗？happens-before了解吗？"><a href="#指令重排有限制吗？happens-before了解吗？" class="headerlink" title="指令重排有限制吗？happens-before了解吗？"></a>指令重排有限制吗？happens-before了解吗？</h2><p>指令重排也是有一些限制的，有两个规则<strong>happens-before和as-if-serial</strong>来约束。</p><p><strong>happens-before</strong>的定义：</p><ul><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><p>happens-before和我们息息相关的有<strong>六大规则</strong>：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903133644636.png" alt="image-20220903133644636"></p><ul><li><strong>程序顺序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li><li><strong>监视器锁规则</strong>：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li><li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li><li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。</li><li><strong>start()规则</strong>：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li><li><strong>join()规则</strong>：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li></ul><h2 id="as-if-serial又是什么？单线程的程序一定是顺序的吗"><a href="#as-if-serial又是什么？单线程的程序一定是顺序的吗" class="headerlink" title="as-if-serial又是什么？单线程的程序一定是顺序的吗"></a>as-if-serial又是什么？单线程的程序一定是顺序的吗</h2><p>as-if-serial语义的意思是：<strong>不管怎么重排序（编译器和处理器为了提高并行度）</strong>， <strong>单线程程序的执行结果不能被改变</strong> 。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。为了具体说明，请看下面计算圆面积的代码示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>; <span class="hljs-comment">// A</span><br><span class="hljs-type">double</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>; <span class="hljs-comment">// B</span><br><span class="hljs-type">double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> pi * r * r; <span class="hljs-comment">// C</span><br></code></pre></td></tr></table></figure><p>上面 3 个操作的数据依赖关系：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134841710.png" alt="image-20220903134841710"></p><p>A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系。因此在最终执行的指令序列中，C不能被重排序到A和B的前面（C排到A和B的前面，程序的结果将会被改变）。但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。所以最终，程序可能会有两种执行顺序：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903134956909.png" alt="image-20220903134956909"></p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器、runtime和处理器共同编织了这么一个“楚门的世界”：单线程程序是按程序的“顺序”来执行的。as- if-serial语义使单线程情况下，我们不需要担心重排序的问题，可见性的问题。</p><h2 id="volatile实现原理了解吗？"><a href="#volatile实现原理了解吗？" class="headerlink" title="volatile实现原理了解吗？"></a>volatile实现原理了解吗？</h2><p>volatile有两个作用，保证 <strong>可见性</strong> 和 <strong>有序性</strong> 。</p><h3 id="volatile怎么保证可见性的呢？"><a href="#volatile怎么保证可见性的呢？" class="headerlink" title="volatile怎么保证可见性的呢？"></a>volatile怎么保证可见性的呢？</h3><p>相比synchronized的加锁方式来解决共享变量的内存可见性问题，volatile就是更轻量的选择，它没有上下文切换的额外开销成本。</p><p>volatile可以确保对某个变量的更新对其他线程马上可见，一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存 当其它线程读取该共享变量 ，会从主内存重新获取最新值，而不是使用当前线程的本地内存中的值。</p><p>例如，我们声明一个 volatile 变量 volatile int x = 0，线程A修改x=1，修改完之后就会把新的值刷新回主内存，线程B读取x的时候，就会清空本地内存变量，然后再从主内存获取最新值。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903135524735.png" alt="image-20220903135524735"></p><h3 id="volatile怎么保证有序性的呢？"><a href="#volatile怎么保证有序性的呢？" class="headerlink" title="volatile怎么保证有序性的呢？"></a>volatile怎么保证有序性的呢？</h3><p>重排序可以分为编译器重排序和处理器重排序，valatile保证有序性，就是通过分别限制这两种类型的重排序。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140353177.png" alt="image-20220903140353177"></p><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p><strong>1.</strong> 在每个volatile写操作的前面插入一个StoreStore 屏障<br><strong>2.</strong> 在每个volatile写操作的后面插入一个StoreLoad 屏障<br><strong>3.</strong> 在每个volatile读操作的后面插入一个LoadLoad 屏障<br><strong>4.</strong> 在每个volatile读操作的后面插入一个LoadStore 屏障</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140503354.png" alt="image-20220903140503354"></p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903140518029.png" alt="image-20220903140518029"></p><h3 id="双重校验锁实现对象单例（线程安全）"><a href="#双重校验锁实现对象单例（线程安全）" class="headerlink" title="双重校验锁实现对象单例（线程安全）"></a>双重校验锁实现对象单例（线程安全）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton uniqueInstance;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getUniqueInstance</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span><br>        <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//类对象加锁</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-literal">null</span>) &#123;<br>                    uniqueInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> uniqueInstance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="synchronized用过吗？怎么使用？"><a href="#synchronized用过吗？怎么使用？" class="headerlink" title="synchronized用过吗？怎么使用？"></a>synchronized用过吗？怎么使用？</h2><p>synchronized经常用的，用来保证代码的原子性。</p><p>synchronized主要有三种用法：</p><ul><li><strong>修饰实例方法</strong>: 作用于当前<strong>对象实例</strong>加锁，进入同步代码前要获得 当前对象实例的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>修饰静态方法</strong> ：也就是给<strong>当前类加锁</strong>，会作用于类的所有对象实例 ，进入同步代码前要获得当前 class 的锁。因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。如果一个线程 A 调用一个实例对象的非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> staic <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>修饰代码块</strong> ：<strong>指定加锁对象，对给定对象/类加锁</strong>。 <strong>synchronized(this|object)</strong> 表示进入同步代码库前要获得给定对象的锁。 <strong>synchronized(类.class)</strong> 表示进入同步代码前要获得 当前<strong>class</strong> 的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="synchronized的实现原理？"><a href="#synchronized的实现原理？" class="headerlink" title="synchronized的实现原理？"></a>synchronized的实现原理？</h2><h3 id="synchronized是怎么加锁的呢？"><a href="#synchronized是怎么加锁的呢？" class="headerlink" title="synchronized是怎么加锁的呢？"></a>synchronized是怎么加锁的呢？</h3><p>我们使用synchronized的时候，发现不用自己去lock和unlock，是因为JVM帮我们把这个事情做了。</p><p><strong>1.</strong> <strong>synchronized修饰代码块时</strong>，JVM采用<strong>monitorenter、monitorexit</strong>两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。反编译一段synchronized修饰代码块代码，<strong>javap -c -s -v -l</strong><br><strong>SynchronizedDemo.class</strong>，可以看到相应的字节码指令。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903180902786.png" alt="image-20220903180902786"></p><p><strong>2.</strong> <strong>synchronized修饰同步方法时</strong>，JVM采用ACC_SYNCHRONIZED标记符来实现同步，这个标识指明了该方法是一个同步方法。<br>同样可以写段代码反编译看一下。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903181654514.png" alt="image-20220903181654514"></p><h3 id="synchronized锁住的是什么呢？"><a href="#synchronized锁住的是什么呢？" class="headerlink" title="synchronized锁住的是什么呢？"></a>synchronized锁住的是什么呢？</h3><p>monitorenter、monitorexit或者ACC_SYNCHRONIZED都是 <strong>基于Monitor实现</strong> 的。</p><p>实例对象结构里有对象头，对象头里面有一块结构叫Mark Word，Mark Word指针指向了<strong>monitor</strong> 。</p><p>所谓的Monitor其实是一种 <strong>同步工具</strong> ，也可以说是一种 <strong>同步机制</strong> 。在Java虚拟机（HotSpot）中，Monitor是由 <strong>ObjectMonitor实现</strong> 的，可以叫做内部锁，或者Monitor锁。</p><p>ObjectMonitor的工作原理：</p><ul><li>ObjectMonitor有两个队列：WaitSet、EntryList，用来保存ObjectWaiter 对象列表。</li><li>_owner，获取 Monitor 对象的线程进入 _owner 区时， _count + 1。如果线程调用了 wait()方法，此时会释放 Monitor 对象， _owner 恢复为空， _count - 1。同时该等待线程进入WaitSet 中，等待被唤醒。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">ObjectMonitor() &#123;<br>_header = NULL;<br>_count = <span class="hljs-number">0</span> ; <span class="hljs-comment">// 记录线程获取锁的次数</span><br>_waiters = <span class="hljs-number">0</span> ,<br>_recursions = <span class="hljs-number">0</span> ; <span class="hljs-comment">//锁的重入次数</span><br>_object = NULL;<br>_owner = NULL; <span class="hljs-comment">// 指向持有ObjectMonitor对象的线程</span><br>_WaitSet = NULL; <span class="hljs-comment">// 处于wait状态的线程，会被加入到_WaitSet</span><br>_WaitSetLock = <span class="hljs-number">0</span> ;<br>_Responsible = NULL ;<br>_succ = NULL ;<br>_cxq = NULL ;<br>FreeNext = NULL ;<br>_EntryList = NULL ; <span class="hljs-comment">// 处于等待锁block状态的线程，会被加入到该列表</span><br>_SpinFreq = <span class="hljs-number">0</span> ;<br>_SpinClock = <span class="hljs-number">0</span> ;<br>OwnerIsThread = <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><p>可以类比一个去医院就诊的例子[18]：</p><ul><li><p>首先，患者在 门诊大厅 前台或自助挂号机 进行挂号 ；</p></li><li><p>随后，挂号结束后患者找到对应的 诊室就诊 ：</p><ul><li>诊室每次只能有一个患者就诊；</li><li>如果此时诊室空闲，直接进入就诊；</li><li>如果此时诊室内有其它患者就诊，那么当前患者进入候诊室，等待叫号；</li></ul></li><li><p>就诊结束后， 走出就诊室 ，候诊室的 下一位候诊患者 进入就诊室。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190305715.png" alt="image-20220903190305715"></p></li></ul><p>这个过程就和<strong>Monitor机制</strong>比较相似：</p><ul><li>门诊大厅：所有待进入的线程都必须先在入口Entry Set挂号才有资格；</li><li>就诊室：就诊室_Owner里里只能有一个线程就诊，就诊完线程就自行离开</li><li>候诊室：就诊室繁忙时，进入等待区（Wait Set），就诊室空闲的时候就从等待区（Wait Set）叫新的线程</li></ul><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903190457240.png" alt="image-20220903190457240"></p><p>所以我们就知道了，同步是锁住的什么东西：</p><ul><li><strong>monitorenter</strong>，在判断拥有同步标识 <strong>ACC_SYNCHRONIZED</strong> 抢先进入此方法的线程会优先拥有 <strong>Monitor</strong> 的 <strong>owner</strong> ，此时计数器 +1。</li><li><strong>monitorexit</strong>，当执行完退出后，计数器 -1，归 0 后被其他进入的线程获得。</li></ul><h2 id="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"><a href="#除了原子性，synchronized可见性，有序性，可重入性怎么实现？" class="headerlink" title="除了原子性，synchronized可见性，有序性，可重入性怎么实现？"></a>除了原子性，synchronized可见性，有序性，可重入性怎么实现？</h2><h4 id="synchronized怎么保证可见性？"><a href="#synchronized怎么保证可见性？" class="headerlink" title="synchronized怎么保证可见性？"></a>synchronized怎么保证可见性？</h4><ul><li>线程加锁前，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值。</li><li>线程加锁后，其它线程无法获取主内存中的共享变量。</li><li>线程解锁前，必须把共享变量的最新值刷新到主内存中。</li></ul><h4 id="synchronized怎么保证有序性？"><a href="#synchronized怎么保证有序性？" class="headerlink" title="synchronized怎么保证有序性？"></a>synchronized怎么保证有序性？</h4><ul><li>synchronized同步的代码块，具有排他性，一次只能被一个线程拥有，所以synchronized保证同一时刻，代码是单线程执行的。</li><li>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不会指令重排。</li><li>所以synchronized保证的有序是执行结果的有序性，而不是防止指令重排的有序性。</li></ul><h4 id="synchronized怎么实现可重入的呢？"><a href="#synchronized怎么实现可重入的呢？" class="headerlink" title="synchronized怎么实现可重入的呢？"></a>synchronized怎么实现可重入的呢？</h4><ul><li>synchronized 是可重入锁，也就是说，允许一个线程二次请求自己持有对象锁的临界资源，这种情况称为可重入锁。</li><li>synchronized 锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码、块之后，计数器就会-1，直到计数器清零，就释放锁了。</li><li>之所以，是可重入的。是因为 synchronized 锁对象有个计数器，会随着线程获取锁后 +1 计数，当线程执行完毕后 -1，直到清零释放锁。</li></ul><h2 id="锁升级？synchronized优化了解吗？"><a href="#锁升级？synchronized优化了解吗？" class="headerlink" title="锁升级？synchronized优化了解吗？"></a>锁升级？synchronized优化了解吗？</h2><p>了解锁升级，得先知道，不同锁的状态是什么样的。这个状态指的是什么呢？</p><p>Java对象头里，有一块结构，叫<strong>Mark Word</strong>标记字段，这块结构会随着锁的状态变化而变化。64 位虚拟机 Mark Word 是 64bit，我们来看看它的状态变化：</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903215849935.png" alt="image-20220903215849935"></p><p>Mark Word存储对象自身的运行数据，如<strong>哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）</strong> 等。</p><h4 id="synchronized做了哪些优化？"><a href="#synchronized做了哪些优化？" class="headerlink" title="synchronized做了哪些优化？"></a>synchronized做了哪些优化？</h4><p>在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为<strong>重量级锁</strong> 。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略，提升了synchronized的性能。</p><ul><li><strong>偏向锁</strong>：在无竞争的情况下，只是在Mark Word里存储当前线程指针，CAS操作都不做。</li><li><strong>轻量级锁</strong>：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。</li><li><strong>自旋锁</strong>：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式</li><li><strong>锁粗化</strong>：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。</li><li><strong>锁消除</strong>：虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</li></ul><h4 id="锁升级的过程是什么样的？"><a href="#锁升级的过程是什么样的？" class="headerlink" title="锁升级的过程是什么样的？"></a>锁升级的过程是什么样的？</h4><p>锁升级方向：无锁–&gt;偏向锁—&gt; 轻量级锁—-&gt;重量级锁，这个方向基本上是不可逆的。</p><p><img src="D:/Project/weiblog/source/_posts/%E9%9D%A2%E8%AF%95-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20220903221140669.png" alt="image-20220903221140669"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试-Mybatis</title>
    <link href="/weiblog/2022/08/31/%E9%9D%A2%E8%AF%95-Mybatis/"/>
    <url>/weiblog/2022/08/31/%E9%9D%A2%E8%AF%95-Mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="说说什么是MyBatis"><a href="#说说什么是MyBatis" class="headerlink" title="说说什么是MyBatis?"></a>说说什么是MyBatis?</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831124353772.png" alt="image-20220831124353772"></p><p>优点：<br>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高。MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO 映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p><p>缺点：<br>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><h3 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么?"></a>ORM是什么?</h3><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831124733088.png" alt="image-20220831124733088"></p><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单来说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><h3 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写SQL来完成，所以，被称之为半自动ORM映射工具。</p><h3 id="JDBC编程有哪些不足之处，MyBatis是如何解决的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决的？</h3><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831125002543.png" alt="image-20220831125002543"></p><p>1 、数据连接创建、释放频繁造成系统资源浪费从而影响系统性能<br><strong>解决：在mybatis-config.xml中配置数据链接池，使用连接池统一管理数据库连接。</strong><br>2 、sql语句写在代码中造成代码不易维护<br><strong>解决：将sql语句配置在XXXXmapper.xml文件中与java代码分离。</strong><br>3 、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。<br><strong>解决： Mybatis自动将java对象映射至sql语句。</strong><br>4 、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<br><strong>解决：Mybatis自动将sql执行结果映射至java对象。</strong></p><h2 id="Hibernate-和-MyBatis-有什么区别？"><a href="#Hibernate-和-MyBatis-有什么区别？" class="headerlink" title="Hibernate 和 MyBatis 有什么区别？"></a>Hibernate 和 MyBatis 有什么区别？</h2><p><strong>相同点</strong></p><p>都是对jdbc的封装，都是应用于持久层的框架。</p><p><strong>不同点</strong></p><p><strong>映射关系</strong><br>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单<br>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</p><p><strong>SQL优化和移植性</strong><br>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。<br>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</p><h3 id="MyBatis和Hibernate的适用场景"><a href="#MyBatis和Hibernate的适用场景" class="headerlink" title="MyBatis和Hibernate的适用场景?"></a>MyBatis和Hibernate的适用场景?</h3><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831130749515.png" alt="image-20220831130749515"></p><ul><li>Hibernate 是标准的ORM框架，SQL编写量较少，但不够灵活，适合于需求相对稳定，中小型的软件项目，比如：办公自动化系统</li><li>MyBatis 是半ORM框架，需要编写较多SQL，但是比较灵活，适合于需求变化频繁，快速迭代的项目，比如：电商网站</li></ul><h2 id="MyBatis使用过程？生命周期？"><a href="#MyBatis使用过程？生命周期？" class="headerlink" title="MyBatis使用过程？生命周期？"></a>MyBatis使用过程？生命周期？</h2><p>MyBatis基本使用的过程大概可以分为这么几步：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831150538063.png" alt="image-20220831150538063"></p><p><strong>1 、 创建SqlSessionFactory</strong></p><ul><li>可以从配置或者直接编码来创建SqlSessionFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;org/mybatis/example/mybatis-config.xml&quot;</span>;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span><br><span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br></code></pre></td></tr></table></figure><p><strong>2 、 通过SqlSessionFactory创建SqlSession</strong></p><ul><li>SqlSession（会话）可以理解为程序和数据库之间的桥梁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession();<br></code></pre></td></tr></table></figure><p><strong>3 、 通过sqlsession执行数据库操作</strong></p><ul><li>​    可以通过 SqlSession 实例来直接执行已映射的 SQL 语句：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span>(Blog)session.selectOne(<span class="hljs-string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>,<span class="hljs-number">101</span> );<br></code></pre></td></tr></table></figure><ul><li>​    更常用的方式是先获取Mapper(映射)，然后再执行SQL语句：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br><span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> mapper.selectBlog( <span class="hljs-number">101</span> );<br></code></pre></td></tr></table></figure><p><strong>4 、 调用session.commit()提交事务</strong></p><ul><li>如果是更新、删除语句，我们还需要提交一下事务。</li></ul><p><strong>5 、 调用session.close()关闭会话</strong></p><ul><li>最后一定要记得关闭会话。</li></ul><h3 id="MyBatis生命周期？"><a href="#MyBatis生命周期？" class="headerlink" title="MyBatis生命周期？"></a>MyBatis生命周期？</h3><p>上面提到了几个MyBatis的组件，一般说的MyBatis生命周期就是这些组件的生命周期。</p><ul><li><p><strong>SqlSessionFactoryBuilder</strong></p><ul><li>一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的生命周期只存在于方法的内部。</li></ul></li><li><p><strong>SqlSessionFactory</strong></p><ul><li>SqlSessionFactory 是用来创建SqlSession的，相当于一个数据库连接池，每次创建SqlSessionFactory都会使用数据库资源，多次创建和销毁是对资源的浪费。所以SqlSessionFactory是应用级的生命周期，而且应该是单例的。</li></ul></li><li><p><strong>SqlSession</strong></p><ul><li>SqlSession相当于JDBC中的Connection，SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的生命周期是一次请求或一个方法。</li></ul></li><li><p><strong>Mapper</strong></p><ul><li>映射器是一些绑定映射语句的接又。映射器接又的实例是从 SqlSession 中获得的，它的生命周期在sqlsession事务方法之内，一般会控制在方法级。</li></ul></li></ul><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831155449848.png" alt="image-20220831155449848"></p><p>当然，万物皆可集成Spring，MyBatis通常也是和Spring集成使用，Spring可以帮助我们创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到我们的 bean 中，我们不需要关心它们的创建过程和生命周期，那就是另外的故事了。</p><h2 id="在mapper中如何传递多个参数？"><a href="#在mapper中如何传递多个参数？" class="headerlink" title="在mapper中如何传递多个参数？"></a>在mapper中如何传递多个参数？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831155632178.png" alt="image-20220831155632178"></p><h3 id="方法-1-：顺序传参法"><a href="#方法-1-：顺序传参法" class="headerlink" title="方法 1 ：顺序传参法"></a>方法 1 ：顺序传参法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> deptId)</span>;<br><br>&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>select * from user<br><span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123; <span class="hljs-number">0</span> &#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123; <span class="hljs-number">1</span> &#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><ul><li>#{}里面的数字代表传入参数的顺序。</li><li>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</li></ul><h3 id="方法-2-：-Param注解传参法"><a href="#方法-2-：-Param注解传参法" class="headerlink" title="方法 2 ：@Param注解传参法"></a>方法 2 ：@Param注解传参法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userName&quot;)</span> String name, <span class="hljs-type">int</span> <span class="hljs-meta">@Param(&quot;deptId&quot;)</span> deptId)</span><br>    <br>&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>select * from user<br><span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;userName&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;deptId&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><ul><li>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</li><li>这种方法在参数不多的情况还是比较直观的，（推荐使用）。</li></ul><h3 id="方法-3-：Map传参法"><a href="#方法-3-：Map传参法" class="headerlink" title="方法 3 ：Map传参法"></a><strong>方法 3 ：Map传参法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(Map&lt;String, Object&gt; params)</span>;<br><br>&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> parameterType=<span class="hljs-string">&quot;java.util.Map&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>select * from user<br><span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;userName&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;deptId&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><ul><li>#{}里面的名称对应的是Map里面的key名称。</li><li>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</li></ul><h3 id="方法-4-：Java-Bean传参法"><a href="#方法-4-：Java-Bean传参法" class="headerlink" title="方法 4 ：Java Bean传参法"></a><strong>方法 4 ：Java Bean传参法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> User <span class="hljs-title function_">selectUser</span><span class="hljs-params">(User user)</span>;<br>&lt;select id=<span class="hljs-string">&quot;selectUser&quot;</span> parameterType=<span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span> resultMap=<span class="hljs-string">&quot;UserResultMap&quot;</span>&gt;<br>select * from user<br><span class="hljs-type">where</span> <span class="hljs-variable">user_name</span> <span class="hljs-operator">=</span> #&#123;userName&#125; <span class="hljs-type">and</span> <span class="hljs-variable">dept_id</span> <span class="hljs-operator">=</span> #&#123;deptId&#125;<br>&lt;/select&gt;<br></code></pre></td></tr></table></figure><ul><li>#{}里面的名称对应的是User类里面的成员属性。</li><li>这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。（推荐使用）。</li></ul><h2 id="实体类属性名和表中字段名不一样-，怎么办"><a href="#实体类属性名和表中字段名不一样-，怎么办" class="headerlink" title="实体类属性名和表中字段名不一样 ，怎么办?"></a>实体类属性名和表中字段名不一样 ，怎么办?</h2><ul><li>第 1 种： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.Order&quot;</span>&gt;</span><br>    select order_id id, order_no orderno ,order_price price form<br>    orders where order_id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>第 2 种： 通过resultMap 中的<result>来映射字段名和实体类属性名的一一对应的关系。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;orderResultMap&quot;</span>&gt;</span><br>select * from orders where order_id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.jourwon.pojo.Order&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;orderResultMap&quot;</span>&gt;</span><br>&lt;!–用id属性来映射主键字段–&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span>&gt;</span><br>&lt;!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span> =<span class="hljs-string">&quot;orderno&quot;</span> <span class="hljs-attr">column</span> =<span class="hljs-string">&quot;order_no&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_price&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">reslutMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis是否可以映射Enum枚举类？"><a href="#Mybatis是否可以映射Enum枚举类？" class="headerlink" title="Mybatis是否可以映射Enum枚举类？"></a>Mybatis是否可以映射Enum枚举类？</h2><ul><li>Mybatis当然可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</li><li>TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</li></ul><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别?"></a>#{}和${}的区别?</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831165343833.png" alt="image-20220831165343833"></p><ul><li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li><li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li><li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li><li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li></ul><p>例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> #&#123;userName&#125;；<br></code></pre></td></tr></table></figure><p>设userName=yuze</p><p>看日志我们可以看到解析时将#{userName}替换成了 <strong>？</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> ?;<br></code></pre></td></tr></table></figure><p>然后再把yuze放进去，外面加上单引号</p><p>Mybatis在处理的 时 候 就 是 把 {}的时候就是把的时候就是把{}替换成变量的值，调用Statement来赋值<br>如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> #&#123;userName&#125;；<br></code></pre></td></tr></table></figure><p>设userName=yuze</p><p>看日志可以发现就是直接把值拼接上去了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> yuze;<br></code></pre></td></tr></table></figure><p>这极有可能发生<a href="https://so.csdn.net/so/search?q=sql%E6%B3%A8%E5%85%A5&spm=1001.2101.3001.7020">sql注入</a>，下面举了一个简单的sql注入案例 </p><p>当用户登录，我们验证账号密码是否正确时用这个sql：</p><p>username=yyy;password=123</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span>$&#123;username&#125; <span class="hljs-keyword">and</span> password<span class="hljs-operator">=</span>$&#123;password&#125;<br></code></pre></td></tr></table></figure><p>显然这条sql没问题可以查出来，但是如果有人不知道密码但是想登录账号怎么办</p><p>我们不需要填写正确的密码：</p><p>密码输入1 or 1=1，sql执行的其实是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;yyy&#x27;</span> <span class="hljs-keyword">and</span> password<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>#{}的变量替换是在DBMS中、变量替换后，#{}对应的变量自动加上单引号</p><p>${}的变量替换是在DBMS外,变量替换后 ，{}的变量替换是在DBMS外、变量替换后，的变量替换是在DBMS外、变量替换后，{}对应的变量不会加上单引号</p><p>使用#{}可以有效的防止sql注入，提高系统的安全性</p><h2 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写?"></a>模糊查询like语句该怎么写?</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831172605851.png" alt="image-20220831172605851"></p><p>1 ’**%${question}%**’ 可能引起SQL注入，不推荐<br>2 “%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’’，所以这里 % 需要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。<br>3 CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，（推荐✨）<br>4 使用bind标签（不推荐）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listUserLikeUsername&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.jourwon.pojo.User&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27; + username + &#x27;%&#x27;&quot;</span> /&gt;</span><br>select id,sex,age,username,password from person where username LIKE #<br>&#123;pattern&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis能执行一对一、一对多的关联查询吗？"><a href="#Mybatis能执行一对一、一对多的关联查询吗？" class="headerlink" title="Mybatis能执行一对一、一对多的关联查询吗？"></a>Mybatis能执行一对一、一对多的关联查询吗？</h2><p>当然可以，不止支持一对一、一对多的关联查询，还支持多对多、多对一的关联查询。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831172905299.png" alt="image-20220831172905299"></p><ul><li><p><strong>一对一<association></strong></p><p>比如订单和支付是一对一的关系，这种关联的实现：</p><p>实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br><span class="hljs-keyword">private</span> Integer orderId;<br><span class="hljs-keyword">private</span> String orderDesc;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 支付对象</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">private</span> Pay pay;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 订单resultMap --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;peopleResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;cn.fighter3.entity.Order&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderDesc&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;order_desc&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--一对一结果映射--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pay&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;cn.fighter3.entity.Pay&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;payId&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;pay_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;account&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;account&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>查询就是普通的关联查</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getTeacher&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;getTeacherMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    select * from order o<br>    left join pay p on o.order_id=p.order_id<br>    where o.order_id=#&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>一对多<collection></strong><br>比如商品分类和商品，是一对多的关系。<br>实体类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Category</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> categoryId;<br>    <span class="hljs-keyword">private</span> String categoryName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 商品列表</span><br><span class="hljs-comment">    **/</span><br>    List&lt;Product&gt; products;<br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;Category&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;categoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;categoryId&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;category_id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;categoryName&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;category_name&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 一对多的关系 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- property: 指的是集合属性的值, ofType：指的是集合中元素的类</span><br><span class="hljs-comment">    型 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;products&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;Product&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;product_id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;productId&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;productName&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;productName&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;price&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><p>查询</p><p>查询就是一个普通的关联查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 关联查询分类和产品表 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listCategory&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;categoryBean&quot;</span>&gt;</span><br>select c.*, p.* from category_ c left join product_ p<br>on c.id = p.cid<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="Mybatis是否支持延迟加载？原理？"><a href="#Mybatis是否支持延迟加载？原理？" class="headerlink" title="Mybatis是否支持延迟加载？原理？"></a>Mybatis是否支持延迟加载？原理？</h2><ul><li><p>Mybatis支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载<strong>lazyLoadingEnabled</strong>=true|false。</p></li><li><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p></li><li><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p></li></ul><h2 id="如何获取生成的主键"><a href="#如何获取生成的主键" class="headerlink" title="如何获取生成的主键?"></a>如何获取生成的主键?</h2><p>新增标签中添加：keyProperty=” ID “ 即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;userId&quot;</span> &gt;</span><br>    insert into user(<br>    user_name, user_password, create_time)<br>    values(#&#123;userName&#125;, #&#123;userPassword&#125; , #&#123;createTime, jdbcType=<br>    TIMESTAMP&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这时候就可以完成回填主键</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mapper.insert(user);<br>user.getId;<br></code></pre></td></tr></table></figure><h2 id="MyBatis支持动态SQL吗？"><a href="#MyBatis支持动态SQL吗？" class="headerlink" title="MyBatis支持动态SQL吗？"></a>MyBatis支持动态SQL吗？</h2><p>MyBatis中有一些支持动态SQL的标签，它们的原理是使用OGNL从SQL参数对象中计算表达式的值，根据表达式的值动态拼接SQL，以此来完成动态SQL的功能。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831185515276.png" alt="image-20220831185515276"></p><ul><li><p>if</p><p>根据条件来组成where子句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogWithTitleLike&quot;</span><span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>    SELECT * FROM BLOG<br>    WHERE state = ‘ACTIVE’<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>    AND title like #&#123;title&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>choose (when, otherwise)</p><p>这个和Java 中的 switch 语句有点像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>SELECT * FROM BLOG WHERE state = ‘ACTIVE’<br>    <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>            AND title like #&#123;title&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>                AND author_name like #&#123;author.name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>            AND featured = 1<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>trim (where, set)</p><ul><li><p><where>可以用在所有的查询条件都是动态的情况</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findActiveBlogLike&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Blog&quot;</span>&gt;</span><br>    SELECT * FROM BLOG<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;state != null&quot;</span>&gt;</span><br>        state = #&#123;state&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;title != null&quot;</span>&gt;</span><br>        AND title like #&#123;title&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;author != null and author.name != null&quot;</span>&gt;</span><br>        AND author_name like #&#123;author.name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><set> 可以用在动态更新的时候</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span><br>    update Author<br>        <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>foreach<br>看到名字就知道了，这个是用来循环的，可以对集合进行遍历</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectPostIn&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;domain.blog.Post&quot;</span>&gt;</span><br>    SELECT *<br>    FROM POST P<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">open</span>=<span class="hljs-string">&quot;ID in (&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">nullable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>                #&#123;item&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="MyBatis如何执行批量操作？"><a href="#MyBatis如何执行批量操作？" class="headerlink" title="MyBatis如何执行批量操作？"></a>MyBatis如何执行批量操作？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220831212914015.png" alt="image-20220831212914015"></p><p><strong>第一种方法：使用foreach标签</strong></p><p>foreach的主要用在构建in条件中，它可以在SQL语句中进行迭代一个集合。foreach标签的属性主要有item，index，collection，open，separator，close。</p><ul><li>item 表示集合中每一个元素进行迭代时的别名，随便起的变量名；</li><li>index 指定一个名字，用于表示在迭代过程中，每次迭代到的位置，不常用；</li><li>open 表示该语句以什么开始，常用“(”；</li><li>separator 表示在每次进行迭代之间以什么符号作为分隔符，常用“,”；</li><li>close 表示以什么结束，常用“)”。</li></ul><p>在使用<strong>foreach</strong>的时候最关键的也是最容易出错的就是<strong>collection</strong>属性，该属性是必须指定的，但是在不同情况下，该属性的值是不一样的，主要有以下 3 种情况：</p><p><strong>1.</strong> 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list<br><strong>2.</strong> 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array<br><strong>3.</strong> 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可以封装成map，实际上如果你在传入参数的时候，在MyBatis里面也是会把它封装成一个Map的，map的key就是参数名，所以这个时候collection属性值就是传入的List或array对象在自己封装的map里面的key</p><p>看看批量保存的两种用法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- MySQL下批量保存，可以foreach遍历 mysql支持values(),(),()语法 --&gt;</span> //推荐使用<br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmpsBatch&quot;</span>&gt;</span><br>    INSERT INTO emp(ename,gender,email,did)<br>    VALUES<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        (#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 这种方式需要数据库连接属性allowMutiQueries=true的支持</span><br><span class="hljs-comment">如jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmpsBatch&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;emps&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;;&quot;</span>&gt;</span><br>        INSERT INTO emp(ename,gender,email,did)<br>        VALUES(#&#123;emp.eName&#125;,#&#123;emp.gender&#125;,#&#123;emp.email&#125;,#&#123;emp.dept.id&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>第二种方法：使用ExecutorType.BATCH</strong></p><p>Mybatis内置的ExecutorType有 3 种，默认为simple，该模式下它为每个语句的执行创建一个新的预处理语句，单条提交sql；而batch模式重复使用已经预处理的语句，并且批量执行所有更新语句，显然batch性能将更优； 但batch模式也有自己的问题，比如在Insert操作<br>时，在事务没有提交之前，是没有办法获取到自增的id，在某些情况下不符合业务的需求。<br>具体用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//批量保存方法测试</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException&#123;<br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> getSqlSessionFactory();<br><span class="hljs-comment">//可以执行批量操作的sqlSession</span><br><span class="hljs-type">SqlSession</span> <span class="hljs-variable">openSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);<br>    <span class="hljs-comment">//批量保存执行前时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">EmployeeMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> openSession.getMapper(EmployeeMapper.class);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">1000</span> ; i++) &#123;<br>            mapper.addEmp(<span class="hljs-keyword">new</span><br>            <span class="hljs-title class_">Employee</span>(UUID.randomUUID().toString().substring( <span class="hljs-number">0</span> , <span class="hljs-number">5</span> ), <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>));<br>   &#125;<br>openSession.commit();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-comment">//批量保存执行后的时间</span><br>    System.out.println(<span class="hljs-string">&quot;执行时⻓&quot;</span> + (end - start));<br>    <span class="hljs-comment">//批量 预编译sql一次==》设置参数==》 10000 次==》执行 1 次 677</span><br>    <span class="hljs-comment">//非批量 （预编译=设置参数=执行 ）==》 10000 次 1121</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>openSession.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>mapper和mapper.xml如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EmployeeMapper</span> &#123;<br><span class="hljs-comment">//批量保存员工</span><br>Long <span class="hljs-title function_">addEmp</span><span class="hljs-params">(Employee employee)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.jourwon.mapper.EmployeeMapper&quot;</span></span><br><span class="hljs-tag">    &lt;!<span class="hljs-attr">--批量保存员工</span> <span class="hljs-attr">--</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addEmp&quot;</span>&gt;</span><br>        insert into employee(lastName,email,gender)<br>        values(#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="MyBatis中一级缓存和二级缓存详解"><a href="#MyBatis中一级缓存和二级缓存详解" class="headerlink" title="MyBatis中一级缓存和二级缓存详解"></a>MyBatis中一级缓存和二级缓存详解</h2><h3 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h3><p>首先缓存的合理使用是优化中最常见的，将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据的压力，同时提高系统性能。</p><h3 id="为什么需要缓存"><a href="#为什么需要缓存" class="headerlink" title="为什么需要缓存"></a>为什么需要缓存</h3><p>BS架构里面，用户的所有操作都是对数据库的增删改查，其中查询的操作是最多的，但如果用户想要某个数据时每次都去数据库查询，这无疑会增加数据库的压力，而且获取时间效率也会降低，所以为了解决这些问题，缓存应用而生，使用了缓存之后，服务器只需要查询一次数据库，然后将数据保存到服务器主机的内存中，以后读取时就直接取内存中的数据，而不需要每次都查数据库，这种方案除了降低数据库压力之外，还提高了响应速度，简直一箭双雕哇~</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存是<strong>SqlSession</strong>级别的缓存，在操作数据库时需要构造SqlSession对象，在对象中有一个数据结构用于存储缓存数据。不同的sqlSession之间的缓存数据区域是<strong>互相不影响</strong>的。也就是他只能作用在同一个<strong>sqlSession</strong>中，不同的<strong>sqlSession</strong>中的缓存是互相不能读取的。<br><strong>一级缓存的工作原理：</strong><br>一级缓存默认是开启的，它在一个sqlSession会话里面的所有查询操作都会保存到缓存中，一般来说一个请求中的所有增删改查操作都是在同一个sqlSession里面的，所以我们可以认为每个请求都有自己的一级缓存，如果同一个sqlSession会话中2 个查询中间有一个 insert 、update或delete 语句，那么之前查询的所有缓存都会清空；<br><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/c6d2a5c38b2e4e6fae3da740b37596f7.png" alt="在这里插入图片描述"></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/06ed9e43f8644ff7a40eca96c27f15c1.png" alt="在这里插入图片描述"></p><p>1、用户发起查询请求，查询某条数据，sqlSession先去缓存中查找，是否有该条数据，如果有，则读取并返回；如果没有，则需要从数据库中查询，并将查询到的数据放入到一级缓存区域，供下次查找使用。</p><p>2、sqlSession执行增删改操作并执行commit操作，则会清空缓存，这样做的<strong>目的是避免脏读</strong>。</p><p>3、如果commit不清空缓存，会有以下场景：A查询了某商品库存为10件，并将10件库存的数据存入缓存中，之后被客户买走了10件，数据被delete了，但是下次查询这件商品时，并不从数据库中查询，而是从缓存中查询，就会出现错误。</p><p>4、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br> <br>        <span class="hljs-comment">// 加载mybatis配置文件</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Resources.getResourceAsReader(<span class="hljs-string">&quot;config/configuration.xml&quot;</span>);<br>        <span class="hljs-comment">//创建数据工厂</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> builder.build(reader);<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br> <br> <br>        <span class="hljs-comment">// 获取mapper接口对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br> <br>        <span class="hljs-comment">// 查询第一次</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        <span class="hljs-comment">// 第二次查询</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;两个user对象是否相等：&quot;</span>+(user == user1));<br>        <span class="hljs-comment">//释放会话</span><br>        sqlSession.clearCache();<br>        sqlSession.close();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/f954119fbd3944ebbeccba11d8ee1ad9.png" alt="在这里插入图片描述"></p><p><strong>根据结果可以看到，代码中执行了2次查询， 但实际运行时只查询了一次数据库，第二次获取数据时直接从缓存中读取，并且2次读取的数据都是一样的，到这里，一级缓存就已经生效了；</strong><br>接下来我们来测试第二种情况 ：<strong>查询 -&gt; 修改 -&gt; 查询</strong><br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br> <br>        <span class="hljs-comment">// 加载mybatis配置文件</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Resources.getResourceAsReader(<span class="hljs-string">&quot;config/configuration.xml&quot;</span>);<br>        <span class="hljs-comment">//创建数据工厂</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> builder.build(reader);<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br> <br> <br>        <span class="hljs-comment">// 获取mapper接口对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-comment">// 查询第一次</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        <span class="hljs-comment">// 修改</span><br>        mapper.updateByPrimaryKey(user);<br>        <span class="hljs-comment">// 第二次查询</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;两个user对象是否相等：&quot;</span>+(user == user1));<br>        <span class="hljs-comment">//释放会话</span><br>        sqlSession.clearCache();<br>        sqlSession.close();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/cc432713b29a465babe833106535ffe9.png" alt="在这里插入图片描述"></p><p>控制台打印了三次sql,其中第一个查询和第三个查询是一样的，但是并没有使用缓存<strong>，是因为每次增删改操作都有可能会改变原来的数据，所以必须刷新缓存</strong>。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p><strong>二级缓存是mapper级别的缓存</strong>，多个SqlSession去操作同一个Mapper的sql语句，<strong>多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。二级缓存的作用范围更大</strong>。</p><p>二级缓存流程图：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/57ebea0ab2e34e3fb6a15c8916b65100.png" alt="在这里插入图片描述"></p><p>第一种配置方式</p><p>单个mapper配置，主需要在需要开启二级缓存的mapper.xml文件中加入以下配置即可开启。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启单个mapper的二级缓存，也叫全局缓存--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>注意一定要加到xxMapper.xml的文件内，千万不要加到[mybatis] 的主配置文件里面了，会报错的。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/dae47bea7d764a45809d612ac0a62b71.png" alt="在这里插入图片描述"></p><p>第二种配置方式</p><p>所有的mapper都开启二级缓存，在mybatis.xml主配置文件中加入以下配置即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>     <span class="hljs-comment">&lt;!--  开启所有mapper的二级缓存 --&gt;</span><br>     <span class="hljs-comment">&lt;!--&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/3c6f0b1fb377457c867002bbf8546a40.png" alt="在这里插入图片描述"></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">    <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 加载mybatis配置文件</span><br>        <span class="hljs-type">Reader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Resources.getResourceAsReader(<span class="hljs-string">&quot;config/configuration.xml&quot;</span>);<br>        <span class="hljs-comment">//创建数据工厂</span><br>        <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br><br>        <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> builder.build(reader);<br>        <span class="hljs-comment">// 第一个会话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 获取会话一的mapper接口对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>        <span class="hljs-comment">// 第一次查询</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        <span class="hljs-comment">//释放第一个会话</span><br>        sqlSession.clearCache();<br>        sqlSession.close();<br>        <span class="hljs-comment">// 第二个会话</span><br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession2</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 获取会话二的mapper接口对象</span><br>        <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper2</span> <span class="hljs-operator">=</span> sqlSession2.getMapper(UserMapper.class);<br>        <span class="hljs-comment">// 第二次查询</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user1</span> <span class="hljs-operator">=</span> mapper2.selectByPrimaryKey(<span class="hljs-string">&quot;3rfrf34r34&quot;</span>);<br>        <span class="hljs-comment">// 释放第二个会话</span><br>        sqlSession2.clearCache();<br>        sqlSession2.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>打印结果：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/d52366f288e940b2afbf51d5035db571.png" alt="在这里插入图片描述"></p><p><strong>打印结果很明显，2次查询，但是日志显示只查询了一次数据库， 第二次是从缓存中获取的数据，至此，二级缓存已开启！</strong></p><p>总结：</p><p><strong>1.</strong> 一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为SqlSession，各个SqlSession之间的缓存相互隔离，当Session flush 或 close 之后，该 SqlSession 中的所有Cache 就将清空，MyBatis默认打开一级缓存。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901114614900.png" alt="image-20220901114614900"></p><p><strong>2.</strong> 二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同之处在于其存储作用域为 Mapper(Namespace)，可以在多个SqlSession之间共享，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接又(可用来保存对象的状态),可在它的映射文件中配置。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901114627565.png" alt="image-20220901114627565"></p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="能说说MyBatis的工作原理吗？"><a href="#能说说MyBatis的工作原理吗？" class="headerlink" title="能说说MyBatis的工作原理吗？"></a>能说说MyBatis的工作原理吗？</h2><p>我们已经大概知道了MyBatis的工作流程，按工作原理，可以分为两大步：<strong>生成会话工厂、会话运行</strong>。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901123812730.png" alt="image-20220901123812730"></p><p>MyBatis是一个成熟的框架，篇幅限制，这里抓大放小，来看看它的主要工作流程。</p><h3 id="构建会话工厂"><a href="#构建会话工厂" class="headerlink" title="构建会话工厂"></a>构建会话工厂</h3><p>构造会话工厂也可以分为两步：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901130322195.png" alt="image-20220901130322195"></p><ul><li>获取配置</li></ul><p>获取配置这一步经过了几步转化，最终由生成了一个配置类<strong>Configuration</strong>实例，这个配置类实例非常重要，主要作用包括：</p><ul><li>​    读取配置文件，包括<strong>基础配置文件和映射文件</strong></li><li>​    初始化基础配置，比如MyBatis的别名，还有其它的一些重要的<strong>类对象，像插件、映射器、ObjectFactory</strong>等等</li><li>​    提供一个单例，作为会话工厂构建的重要参数</li><li>​    它的构建过程也会初始化一些环境变量，比如数据源</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">build</span><span class="hljs-params">(Reader reader, String environment,Properties properties)</span> &#123;<br>    SqlSessionFactory var5;<br>    <span class="hljs-comment">//省略异常处理</span><br>    <span class="hljs-comment">//xml配置构建器</span><br>    <span class="hljs-type">XMLConfigBuilder</span> <span class="hljs-variable">parser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLConfigBuilder</span>(reader,environment, properties);<br>    <span class="hljs-comment">//通过转化的Configuration构建SqlSessionFactory</span><br>    var5 = <span class="hljs-built_in">this</span>.build(parser.parse());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>构建SqlSessionFactory</p><p>SqlSessionFactory只是一个接又，构建出来的实际上是它的实现类的实例，一般我们用的都是它的实现类DefaultSqlSessionFactory，</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title function_">build</span><span class="hljs-params">(Configuration config)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSessionFactory</span>(config);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="会话运行"><a href="#会话运行" class="headerlink" title="会话运行"></a>会话运行</h3><p>会话运行是MyBatis最复杂的部分，它的运行离不开四大组件的配合：<img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901145328294.png" alt="image-20220901145328294"></p><ul><li><strong>Executor（执行器）</strong><br>Executor起到了至关重要的作用，SqlSession只是一个门面，相当于客服，真正干活的是是Executor，就像是默默无闻的工程师。它提供了相应的查询和更新方法，以及事务方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Environment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.configuration.getEnvironment();<br><span class="hljs-type">TransactionFactory</span> <span class="hljs-variable">transactionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getTransactionFactoryFromEnvironment(environment);<br>tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);<br><span class="hljs-comment">//通过Configuration创建executor</span><br><span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.configuration.newExecutor(tx,execType);<br>var8 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSqlSession</span>(<span class="hljs-built_in">this</span>.configuration, executor,autoCommit);<br></code></pre></td></tr></table></figure><ul><li>StatementHandler（数据库会话器）<br>StatementHandler，顾名思义，处理数据库会话的。我们以SimpleExecutor为例，看一下它的查询方法，先生成了一个StatementHandler实例，再拿这个handler去执行query。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">doQuery</span><span class="hljs-params">(MappedStatement ms, Object parameter,</span><br><span class="hljs-params">RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span><span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>List var9;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> ms.getConfiguration();<br>        <span class="hljs-type">StatementHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> configuration.newStatementHandler(<span class="hljs-built_in">this</span>.wrapper, ms, parameter,rowBounds,<br>        resultHandler, boundSql);<br>        stmt = <span class="hljs-built_in">this</span>.prepareStatement(handler,ms.getStatementLog());<br>        var9 = handler.query(stmt, resultHandler);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">this</span>.closeStatement(stmt);<br>    &#125;<br><span class="hljs-keyword">return</span> var9;<br>&#125;<br></code></pre></td></tr></table></figure><p>再以最常用的PreparedStatementHandler看一下它的query方法，其实在上面的prepareStatement已经对参数进行了预编译处理，到了这里，就直接执行sql，使用ResultHandler处理返回结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">query</span><span class="hljs-params">(Statement statement, ResultHandler resultHandler)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> (PreparedStatement)statement;<br>    ps.execute();<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.resultSetHandler.handleResultSets(ps);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ParameterHandler （参数处理器）<br>PreparedStatementHandler里对sql进行了预编译处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parameterize</span><span class="hljs-params">(Statement statement)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br><span class="hljs-built_in">this</span>.parameterHandler.setParameters((PreparedStatement)statement);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里用的就是ParameterHandler，setParameters的作用就是设置预编译SQL语句的参数。里面还会用到typeHandler类型处理器，对类型进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ParameterHandler</span> &#123;<br>    Object <span class="hljs-title function_">getParameterObject</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParameters</span><span class="hljs-params">(PreparedStatement var1)</span> <span class="hljs-keyword">throws</span> SQLException;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>ResultSetHandler（结果处理器）</p><p>我们前面也看到了，最后的结果要通过ResultSetHandler来进行处理，handleResultSets这个方法就是用来包装结果集的。Mybatis为我们提供了一个DefaultResultSetHandler，通常都是用这个实现类去进行结果的处理的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ResultSetHandler</span> &#123;<br>    &lt;E&gt; List&lt;E&gt; <span class="hljs-title function_">handleResultSets</span><span class="hljs-params">(Statement var1)</span> <span class="hljs-keyword">throws</span> SQLException;<br>    <br>    &lt;E&gt; Cursor&lt;E&gt; <span class="hljs-title function_">handleCursorResultSets</span><span class="hljs-params">(Statement var1)</span> <span class="hljs-keyword">throws</span> SQLException;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOutputParameters</span><span class="hljs-params">(CallableStatement var1)</span> <span class="hljs-keyword">throws</span> SQLException;<br>&#125;<br></code></pre></td></tr></table></figure><p>它会使用typeHandle处理类型，然后用ObjectFactory提供的规则组装对象，返回给调用者。</p><p>整体上总结一下会话运行：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901153231196.png" alt="image-20220901153231196"></p><p>把整个的⼯作流程串联起来，简单总结⼀下：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901153540814.png" alt="image-20220901153540814"></p><p><strong>1.</strong> 读取 MyBatis 配置文件——<strong>mybatis-config.xml 、加载映射文件</strong>——映射文件即 SQL 映射文件，文件中配置了操作数据库的 SQL 语句。最后生成一个<strong>配置对象</strong>。<br><strong>2.</strong> 构造会话工厂：通过 MyBatis 的环境等配置信息构建<strong>会话工厂 SqlSessionFactory</strong>。<br><strong>3.</strong> 创建会话对象：由会话工厂<strong>创建 SqlSession 对象</strong>，该对象中包含了执行 SQL 语句的所有方法。<br><strong>4.</strong> Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。<br><strong>5.</strong> <strong>StatementHandler</strong>：数据库会话器，串联起参数映射的处理和运行结果映射的处理。<br>**6.**参数处理：对输入参数的类型进行处理，并预编译<br>**7.**结果处理：对返回结果的类型进行处理，根据对象映射规则，返回相应的对象。</p><h2 id="MyBatis的功能架构是什么样的？"><a href="#MyBatis的功能架构是什么样的？" class="headerlink" title="MyBatis的功能架构是什么样的？"></a>MyBatis的功能架构是什么样的？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901154447146.png" alt="image-20220901154447146"></p><p>我们一般把Mybatis的功能架构分为三层：</p><ul><li><strong>API接口层</strong>：提供给外部使用的接又API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li><strong>数据处理层</strong>：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li><strong>基础支撑层</strong>：负责最基础的功能支撑，包括<strong>连接管理、事务管理、配置加载和缓存处理</strong>，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ul><h2 id="为什么Mapper接又不需要实现类？"><a href="#为什么Mapper接又不需要实现类？" class="headerlink" title="为什么Mapper接又不需要实现类？"></a>为什么Mapper接又不需要实现类？</h2><p>四个字回答： <strong>动态代理</strong> ，我们来看一下获取Mapper的过程：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901155803040.png" alt="image-20220901155803040"></p><ul><li><p>获取Mapper<br>我们都知道定义的Mapper接口是没有实现类的，Mapper映射其实是通过 动态代理 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BlogMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(BlogMapper.class);<br></code></pre></td></tr></table></figure><p>七拐八绕地进去看一下，发现获取Mapper的过程，需要先获取<strong>MapperProxyFactory</strong>——Mapper代理工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> &#123;<br>    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory)<span class="hljs-built_in">this</span>.knownMappers.get(type);<br>    <span class="hljs-keyword">if</span> (mapperProxyFactory == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is not known</span><br><span class="hljs-string">        to the MapperRegistry.&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var5) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BindingException</span>(<span class="hljs-string">&quot;Error getting mapper</span><br><span class="hljs-string">        instance. Cause: &quot;</span> + var5, var5);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>MapperProxyFactory<br>MapperProxyFactory的作用是生成MapperProxy（Mapper代理对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperProxyFactory</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;T&gt; mapperInterface;<br>    ......<br>    <span class="hljs-keyword">protected</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(MapperProxy&lt;T&gt; mapperProxy)</span> &#123;<br>    <span class="hljs-keyword">return</span><br>    Proxy.newProxyInstance(<span class="hljs-built_in">this</span>.mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;<span class="hljs-built_in">this</span>.mapperInterface&#125;, mapperProxy);<br>&#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> &#123;<br>        MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapperProxy</span>(sqlSession,<br>        <span class="hljs-built_in">this</span>.mapperInterface, <span class="hljs-built_in">this</span>.methodCache);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.newInstance(mapperProxy);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可以看到动态代理对接又的绑定，它的作用就是生成动态代理对象（占位），而代理的方法被放到了MapperProxy中。</p><ul><li>MapperProxy</li></ul></li></ul><p>​        MapperProxy里，通常会生成一个<strong>MapperMethod</strong>对象，它是通过cachedMapperMethod方法对其进行初始化的，然后执行excute方        法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> Object.class.equals(method.getDeclaringClass())?<br>        method.invoke(<span class="hljs-built_in">this</span>, args) : <span class="hljs-built_in">this</span>.cachedInvoker(method).invoke(proxy,<br>        method, args, <span class="hljs-built_in">this</span>.sqlSession);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var5) &#123;<br>        <span class="hljs-keyword">throw</span> ExceptionUtil.unwrapThrowable(var5);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>MapperMethod<br>MapperMethod里的excute方法，会真正去执行sql。这里用到了命令模式，其实绕一圈，最终它还是通过<strong>SqlSession</strong>的实例去运行对象的sql。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(SqlSession sqlSession, Object[] args)</span> &#123;<br>    Object result;<br>    Object param;<br>    ......<br>    <span class="hljs-keyword">case</span> SELECT:<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsVoid() &amp;&amp;<br>    <span class="hljs-built_in">this</span>.method.hasResultHandler()) &#123;<br>    <span class="hljs-built_in">this</span>.executeWithResultHandler(sqlSession, args);<br>    result = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsMany()) &#123;<br>    result = <span class="hljs-built_in">this</span>.executeForMany(sqlSession, args);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsMap()) &#123;<br>    result = <span class="hljs-built_in">this</span>.executeForMap(sqlSession, args);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsCursor()) &#123;<br>    result = <span class="hljs-built_in">this</span>.executeForCursor(sqlSession, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>    param =<br>    <span class="hljs-built_in">this</span>.method.convertArgsToSqlCommandParam(args);<br>    result =<br>    sqlSession.selectOne(<span class="hljs-built_in">this</span>.command.getName(), param);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.method.returnsOptional() &amp;&amp; (result == <span class="hljs-literal">null</span><br>    || !<span class="hljs-built_in">this</span>.method.getReturnType().equals(result.getClass()))) &#123;<br>    result = Optional.ofNullable(result);<br>    &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Mybatis都有哪些Executor执行器？"><a href="#Mybatis都有哪些Executor执行器？" class="headerlink" title="Mybatis都有哪些Executor执行器？"></a>Mybatis都有哪些Executor执行器？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901162602848.png" alt="image-20220901162602848"></p><p>Mybatis有三种基本的Executor执行器，<strong>SimpleExecutor、ReuseExecutor、BatchExecutor</strong>。</p><ul><li><strong>SimpleExecutor</strong>：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</li><li><strong>ReuseExecutor</strong>：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</li><li><strong>BatchExecutor</strong>：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</li></ul><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><h3 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h3><ul><li>在Mybatis配置文件中，在设置（settings）可以指定默认的<strong>ExecutorType</strong>执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递<strong>ExecutorType类型参数</strong>，如SqlSession openSession(ExecutorType execType)。</li><li>配置默认的执行器。<strong>SIMPLE</strong> 就是普通的执行器；<strong>REUSE</strong> 执行器会重用预处理语句（prepared statements）； <strong>BATCH</strong> 执行器将重用语句并执行批量更新。</li></ul><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="说说Mybatis的插件运行原理，如何编写一个插件？"><a href="#说说Mybatis的插件运行原理，如何编写一个插件？" class="headerlink" title="说说Mybatis的插件运行原理，如何编写一个插件？"></a>说说Mybatis的插件运行原理，如何编写一个插件？</h2><h3 id="插件的运行原理？"><a href="#插件的运行原理？" class="headerlink" title="插件的运行原理？"></a>插件的运行原理？</h3><p>Mybatis会话的运行需要ParameterHandler、ResultSetHandler、StatementHandler、Executor这四大对象的配合，插件的原理就是在这四大对象调度的时候，插入一些我我们自己的代码。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901163556036.png" alt="image-20220901163556036"></p><p>Mybatis使用JDK的动态代理，为目标对象生成代理对象。它提供了一个工具类<strong>Plugin</strong>，实现了<strong>InvocationHandler</strong>接口。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/image-20220901163645793.png" alt="image-20220901163645793"></p><p>使用Plugin生成代理对象，代理对象在调用方法的时候，就会进入invoke方法，在invoke方法中，如果存在签名的拦截方法，插件的intercept方法就会在这里被我们调用，然后就返回结果。如果不存在签名方法，那么将直接反射调用我们要执行的方法。</p><h3 id="如何编写一个插件？"><a href="#如何编写一个插件？" class="headerlink" title="如何编写一个插件？"></a>如何编写一个插件？</h3><p>我们自己编写MyBatis 插件，只需要实现拦截器接又 Interceptor (org.apache.ibatis. pluginInterceptor ），在实现类中对拦截对象和方法进行处理。</p><ul><li>实现Mybatis的Interceptor接又并重写intercept()方法这里我们只是在目标对象执行目标方法的前后进行了打印；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    Properties props=<span class="hljs-literal">null</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;before......&quot;</span>);<br>        <span class="hljs-comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span><br>        <span class="hljs-comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span><br>        Object obj=invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;after......&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>然后再给插件编写注解，确定要拦截的对象，要拦截的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(</span><br><span class="hljs-meta">type = Executor.class, //确定要拦截的对象</span><br><span class="hljs-meta">method = &quot;update&quot;, //确定要拦截的方法</span><br><span class="hljs-meta">args = &#123;MappedStatement.class,Object.class&#125; //拦截方法的参数</span><br><span class="hljs-meta">)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    Properties props=<span class="hljs-literal">null</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;before......&quot;</span>);<br>        <span class="hljs-comment">//如果当前代理的是一个非代理对象，那么就会调用真实拦截对象的方法</span><br>        <span class="hljs-comment">// 如果不是它就会调用下个插件代理对象的invoke方法</span><br>        Object obj=invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;after......&quot;</span>);<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，在MyBatis配置文件里面配置插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;xxx.MyPlugin&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dbType&quot;</span>,<span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Mybatis-分页插件"><a href="#Mybatis-分页插件" class="headerlink" title="Mybatis-分页插件"></a>Mybatis-分页插件</h2><p><strong>分页插件：</strong></p><p><strong>1.添加依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.在mybatis主配置文件中配置分页插件：</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/2600280-20220303161626997-395362475.png" alt="img"></p><p><strong>分页插件使用：</strong></p><p>　　使用mybatis的分页插件实现分页功能：</p><p>　　　　1.需要在查询功能之前开启分页</p><p>　　　　 PageHelper.startPage(2【从第几页开始】,4【每页显示的数据】);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * limit,index,pageSize</span><br><span class="hljs-comment">     * index:当前页的起始索引</span><br><span class="hljs-comment">     * pageSize：每页显示的信息条数</span><br><span class="hljs-comment">     * pageNum：当前的页码</span><br><span class="hljs-comment">     * index=（pageNum-1）*pageSixe</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHelpPage</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(<span class="hljs-string">&quot;Mybatis.xml&quot;</span>);<br>            <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(in);<br>            <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> sqlSessionFactory.openSession(<span class="hljs-literal">true</span>);<br>            <span class="hljs-type">EmpMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> session.getMapper(EmpMapper.class);<br>            PageHelper.startPage(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>            List&lt;Emp&gt; emps = mapper.selectByExample(<span class="hljs-literal">null</span>);<br>            PageInfo&lt;Emp&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>&lt;&gt;(emps,<span class="hljs-number">5</span>);<br>            System.out.println(page);<br>            emps.forEach(emp -&gt; System.out.println(emp));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>2.在查询功能结束后获取分页相关信息</p><p>​        PageInfo<Emp> page = new PageInfo&lt;&gt;(emps,5);进行导航分页</p><p>　　emps：表示分页数据</p><p>　　5：表示当前导航分页的数量</p><p>​        运行结果：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-Mybatis/2600280-20220303163713816-2112457012.png" alt="img"></p><p>显示第二页，一页4条数据</p><p>结果具体分析：</p><p>PageInfo{pageNum=2, pageSize=4, size=4, startRow=5, endRow=8, total=11, pages=3, list=Page{count=true, pageNum=2, pageSize=4, startRow=4, endRow=8, total=11, pages=3, reasonable=false, pageSizeZero=false}prePage=1, nextPage=3, isFirstPage=false, isLastPage=false, hasPreviousPage=true, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=3, navigatepageNums=[1, 2, 3]}</p><table><thead><tr><th align="left"><strong>pageNum=2表示当前页码数</strong></th></tr></thead><tbody><tr><td align="left"><strong>pageSize=4：表示一页的数据</strong></td></tr><tr><td align="left"><strong>size=4：这第二页的真实数据个数</strong></td></tr><tr><td align="left"><strong>startRow=5：第二页四个数据从数据库表单中第5个数据开始</strong></td></tr><tr><td align="left"><strong>endRow=8：第二页四个数据从数据库表单中第8个数据结束</strong></td></tr><tr><td align="left"><strong>total=11：数据库表单总数据条数</strong></td></tr><tr><td align="left"><strong>pages=3：总页数</strong></td></tr><tr><td align="left"><strong>prePage=1：这页的上一页</strong></td></tr><tr><td align="left"><strong>nextPage=3：这页的下一页</strong></td></tr><tr><td align="left"><strong>isFirstPage=false：判断是否是第一页</strong></td></tr><tr><td align="left"><strong>isLastPage=false：判断是否是最后一页</strong></td></tr><tr><td align="left"><strong>hasPreviousPage=true：是否有上一页</strong></td></tr><tr><td align="left"><strong>hasNextPage=true：是否有下一页</strong></td></tr><tr><td align="left"><strong>navigatePages=5：这个就是我们在方法中输入的参数（PageInfo<Emp> page = new PageInfo&lt;&gt;(emps,5);）</strong></td></tr><tr><td align="left"><strong><em>navigateFirstPage=1：导航分页从第1页开始</em></strong></td></tr><tr><td align="left"><strong><em>navigateLastPage=3：导航分页从第3页结束</em></strong></td></tr><tr><td align="left"><strong><em>navigatepageNums=[1, 2, 3]：进行底层运算，计算出导航分页页码</em></strong></td></tr></tbody></table><p><strong>总结:</strong></p><p>　　<strong>a&gt;在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能</strong></p><p>　　　　pageNum：当前页的页码        pageSize：每页显示的条数</p><p>　　<strong>b&gt;在查询获取list集合之后，使用PageInfo pageInfo = new PageInfo&lt;&gt;(List list, int navigatePages)获取分页相关数据</strong></p><p>　　　　 list：分页之后的数据         navigatePages：导航分页的页码数</p><p>　　<strong>c&gt;分页相关数据</strong></p><p>　　　　PageInfo{ pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8, list=Page{count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30, pages=8, reasonable=false, pageSizeZero=false}, prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true, hasNextPage=false, navigatePages=5, navigateFirstPage4, navigateLastPage8, navigatepageNums=[4, 5, 6, 7, 8] }*</p><h3 id="MyBatis是如何分页的？"><a href="#MyBatis是如何分页的？" class="headerlink" title="MyBatis是如何分页的？"></a>MyBatis是如何分页的？</h3><p>MyBatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><h3 id="分页插件的原理是什么？"><a href="#分页插件的原理是什么？" class="headerlink" title="分页插件的原理是什么？"></a>分页插件的原理是什么？</h3><ul><li>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，拦截Executor的query方法</li><li>在执行查询的时候，拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</li><li>举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面试-Spring</title>
    <link href="/weiblog/2022/08/29/%E9%9D%A2%E8%AF%95-Spring/"/>
    <url>/weiblog/2022/08/29/%E9%9D%A2%E8%AF%95-Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="Spring 基础"></a><strong>Spring 基础</strong></h1><h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h2><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！</p><p>题外话 ： 语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。</p><p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。</p><p>比如说 Spring 自带 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829094121471.png" alt="image-20220829094121471"></p><p>Spring 最核心的思想就是不重新造轮子，开箱即用！</p><p>Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！</p><ul><li><p>Spring 官网：<a href="https://spring.io/">https://spring.io/open in new window</a></p></li><li><p>Github 地址： <a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p></li></ul><hr><h2 id="Spring的特性"><a href="#Spring的特性" class="headerlink" title="Spring的特性"></a>Spring的特性</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829094232799.png" alt="image-20220829094232799"></p><p>Spring有很多优点：</p><p><strong>1.IOC 和 DI 的支持</strong></p><p>Spring 的核心就是一个大的工厂容器，可以维护所有对象的创建和依赖关系，Spring 工厂用<br>于生成 Bean，并且管理 Bean 的生命周期，实现 <strong>高内聚低耦合</strong> 的设计理念。</p><p><strong>2.AOP 编程的支持</strong></p><p>Spring 提供了 <strong>面向切面编程</strong> ，可以方便的实现对程序进行权限拦截、运行监控等切面功能。</p><p><strong>3. 声明式事务的支持</strong></p><p>支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式，以前重复的一些事务提<br>交、回滚的JDBC代码，都可以不用自己写了。</p><p><strong>4. 快捷测试的支持</strong></p><p>Spring 对 Junit 提供支持，可以通过 <strong>注解</strong> 快捷地测试 Spring 程序。</p><p><strong>5. 快速集成功能</strong></p><p>方便集成各种优秀框架，Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架<br>（如：Struts、Hibernate、MyBatis、Quartz 等）的直接支持。</p><p><strong>6. 复杂API模板封装</strong></p><p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了模板<br>化的封装，这些封装 API 的提供使得应用难度大大降低。</p><hr><h2 id="列举一些重要的-Spring-模块？"><a href="#列举一些重要的-Spring-模块？" class="headerlink" title="列举一些重要的 Spring 模块？"></a>列举一些重要的 Spring 模块？</h2><p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829095453700.png" alt="image-20220829095453700"></p><p><strong>Spring Core</strong></p><p>核心模块， Spring 其他所有的功能基本都需要依赖于该模块，主要提供 IoC 依赖注入功能的支持。</p><p><strong>Spring Aspects</strong></p><p>该模块为与 AspectJ 的集成提供支持。</p><p><strong>Spring AOP</strong></p><p>提供了面向切面的编程实现。</p><p><strong>Spring Data Access/Integration ：</strong></p><p>Spring Data Access/Integration 由 5 个模块组成：</p><ul><li><p>spring-jdbc : 提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</p></li><li><p>spring-tx : 提供对事务的支持。</p></li><li><p>spring-orm : 提供对 Hibernate 等 ORM 框架的支持。</p></li><li><p>spring-oxm ： 提供对 Castor 等 OXM 框架的支持。</p></li><li><p>spring-jms : Java 消息服务。</p></li></ul><p><strong>Spring Web</strong></p><p>Spring Web 由 4 个模块组成：</p><ul><li><p>spring-web ：对 Web 功能的实现提供一些最基础的支持。</p></li><li><p>spring-webmvc ： 提供对 Spring MVC 的实现。</p></li><li><p>spring-websocket ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</p></li><li><p>spring-webflux ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步.</p></li></ul><p><strong>Spring Test</strong></p><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><hr><h2 id="Spring有哪些常用注解呢？"><a href="#Spring有哪些常用注解呢？" class="headerlink" title="Spring有哪些常用注解呢？"></a>Spring有哪些常用注解呢？</h2><p>Spring有很多模块，甚至广义的SpringBoot、SpringCloud也算是Spring的一部分，我们来分模块，按功能来看一下一些常用的注解：</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829095848193.png" alt="image-20220829095848193" style="zoom:67%;" /><p><strong>Web</strong> :</p><p><strong>@Controller</strong>：组合注解（组合了@Component注解），应用在MVC层（控制层）。<br><strong>@RestController</strong>：该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。<br><strong>@RequestMapping</strong>：用于映射Web请求，包括访问路径和参数。如果是Restful风格接又，还可以根据请求类型使用不同的注解：<br><strong>@GetMapping</strong><br><strong>@PostMapping</strong><br><strong>@PutMapping</strong><br><strong>@DeleteMapping</strong><br><strong>@ResponseBody</strong>：支持将返回值放在response内，而不是一个页面，通常用户返回json数据。<br><strong>@RequestBody</strong>：允许request的参数在request体中，而不是在直接连接在地址后面。<br><strong>@PathVariable</strong>：用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接又实现方法。</p><p><strong>容器</strong> :</p><p><strong>@Component</strong>：表示一个带注释的类是一个“组件”，成为Spring管理的Bean。当使用基于注解的配置和类路径扫描时，这些类被视为自动检测的候选对象。同时@Component还是一个元注解。<br><strong>@Service</strong>：组合注解（组合了@Component注解），应用在service层（业务逻辑层）。<br><strong>@Repository</strong>：组合注解（组合了@Component注解），应用在dao层（数据访问层）。<br><strong>@Autowired</strong>：Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。<br><strong>@Qualifier</strong>：该注解通常跟 @Autowired 一起使用，当想对注入的过程做更多的控制，@Qualifier 可帮助配置，比如两个以上相同类型的 Bean 时 Spring 无法抉择，用到此注解<br><strong>@Configuration</strong>：声明当前类是一个配置类（相当于一个Spring配置的xml文件）<br><strong>@Value</strong>：可用在字段，构造器参数跟方法参数，指定一个默认值，支持 #{} 跟 ${} 两个方式。一般将 SpringbBoot 中的 application.properties 配置的属性值赋值给变量。<br><strong>@Bean</strong>：注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行init，在销毁之前执行destroy。<br><strong>@Scope</strong>:定义我们采用什么模式去创建Bean（方法上，得有@Bean） 其设置类型包括：Singleton 、Prototype、Request 、 Session、GlobalSession。</p><p><strong>AOP :</strong></p><p><strong>@Aspect</strong>:声明一个切面（类上） 使用@After、@Before、@Around定义建言（advice），<br>可直接将拦截规则（切点）作为参数。<br><strong>@After</strong> ：在方法执行之后执行（方法上）。<br><strong>@Before</strong> ： 在方法执行之前执行（方法上）。<br><strong>@Around</strong> ： 在方法执行之前与之后执行（方法上）。<br><strong>@PointCut</strong> ： 声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）。</p><p><strong>事务</strong>：<br><strong>@Transactional</strong>：在要开启事务的方法上使用@Transactional注解，即可声明式开启事务。</p><hr><h2 id="Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间什么关系?"></a>Spring,Spring MVC,Spring Boot 之间什么关系?</h2><p>很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。</p><p>Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p><p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829100915670.png" alt="image-20220829100915670" style="zoom:80%;" /><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 <strong>Spring 快速构建 MVC 架构的 Web 程序的能力</strong>。**MVC 是模型(Model)、视图(View)、控制器(Controller)**的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829101135375.png" alt="image-20220829101135375"></p><p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p><p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p><p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p><hr><h1 id="Spring-IOC-amp-AOP"><a href="#Spring-IOC-amp-AOP" class="headerlink" title="Spring IOC &amp; AOP"></a><strong>Spring IOC &amp; AOP</strong></h1><h2 id="谈谈自己对于-Spring-IoC-的了解"><a href="#谈谈自己对于-Spring-IoC-的了解" class="headerlink" title="谈谈自己对于 Spring IoC 的了解"></a>谈谈自己对于 Spring IoC 的了解</h2><p><strong>IoC（Inverse of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><p><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</p></li><li><p><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</p></li></ul><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829101428860.png" alt="image-20220829101428860" style="zoom:80%;" /><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829101503950.png" alt="image-20220829101503950" style="zoom:67%;" /><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><p><strong>为什么要使⽤IOC呢？</strong></p><p>最主要的是两个字 解耦 ，硬编码会造成对象间的过度耦合，使用IOC之后，我们可以不用关心对象间的依赖，专心开发应用就行。</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829101858257.png" alt="image-20220829101858257" style="zoom:67%;" /><p>DI（依赖注入） ：指的是容器在实例化对象的时候把它依赖的类注入给它。有的说法IOC和DI是一回事，有的说法是IOC是思想，DI是IOC的实现。</p><hr><h2 id="能简单说⼀下Spring-IOC的实现机制吗？"><a href="#能简单说⼀下Spring-IOC的实现机制吗？" class="headerlink" title="能简单说⼀下Spring IOC的实现机制吗？"></a>能简单说⼀下Spring IOC的实现机制吗？</h2><p>Spring的IOC本质就是一个大工厂，我们想想一个工厂是怎么运行的呢？</p><p><strong>生产产品 ：</strong></p><p>一个工厂最核心的功能就是生产产品。在Spring里，不用Bean自己来实例化，而是交给Spring，应该怎么实现呢？——答案毫无疑问， 反射 。那么这个厂子的生产管理是怎么做的？你应该也知道—— 工厂模式 。</p><p><strong>库存产品 ：</strong></p><p>工厂一般都是有库房的，用来库存产品，毕竟生产的产品不能立马就拉走。Spring我们都知道是一个容器，这个容器里存的就是对象，不能每次来取对象，都得现场来反射创建对象，得把创建出的对象存起来。</p><p><strong>订单处理</strong> ：</p><p>还有最重要的一点，工厂根据什么来提供产品呢？订单。这些订单可能五花八门，有线上签签的、有到工厂签的、还有工厂销售上门签的……最后经过处理，指导工厂的出货。在Spring里，也有这样的订单，它就是我们bean的定义和依赖关系，可以是xml形式，也可以是我们最熟悉的注解形式。</p><p>我们简单地实现一个mini版的Spring IOC：</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829102611661.png" alt="image-20220829102611661" style="zoom:80%;" /><p>Bean定义：</p><p>Bean通过一个配置文件定义，把它解析成一个类型。</p><p>beans.properties<br>这里直接用了最方便解析的properties，这里直接用一个&lt;key,value&gt;类型的配置来代表Bean的定义，其中key是beanName，value是class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">userDao:cn.fighter3.bean.UserDao<br></code></pre></td></tr></table></figure><p>BeanDefinition.java<br>bean定义类，配置文件中bean定义对应的实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanDefinition</span> &#123;<br> <span class="hljs-keyword">private</span> String beanName;<br> <span class="hljs-keyword">private</span> Class beanClass;<br> <span class="hljs-comment">//省略getter、setter </span><br> &#125; <br><br></code></pre></td></tr></table></figure><p>ResourceLoader.java<br>资源加载器，用来完成配置文件中配置的加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceLoader</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, BeanDefinition&gt; <span class="hljs-title function_">getResource</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br> <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br> <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span><br>ResourceLoader.class.getResourceAsStream(<span class="hljs-string">&quot;/beans.properties&quot;</span>);<br>      properties.load(inputStream);<br>     Iterator&lt;String&gt; it =<br>properties.stringPropertyNames().iterator();<br>     <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>         <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> it.next();<br>         <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> properties.getProperty(key);<br>         <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinition</span>();<br>         beanDefinition.setBeanName(key);<br>         <span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(className);<br>         beanDefinition.setBeanClass(clazz);<br>         beanDefinitionMap.put(key, beanDefinition);<br>         &#125;<br>         inputStream.close();<br>     &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>         e.printStackTrace();<br>     &#125;<br>     <span class="hljs-keyword">return</span> beanDefinitionMap;<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>BeanRegister.java<br>对象注册器，这里用于单例bean的缓存，我们大幅简化，默认所有bean都是单例的。可以看到所谓单例注册，也很简单，不过是往HashMap里存对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanRegister</span> &#123;<br> <span class="hljs-comment">//单例Bean缓存</span><br> <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; singletonMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">32</span>);<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">* 获取单例Bean</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanName bean名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSingletonBean</span><span class="hljs-params">(String beanName)</span> &#123;<br> <span class="hljs-keyword">return</span> singletonMap.get(beanName);<br> &#125;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注册单例bean</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanName</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> bean</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerSingletonBean</span><span class="hljs-params">(String beanName, Object bean)</span> &#123;<br> <span class="hljs-keyword">if</span> (singletonMap.containsKey(beanName)) &#123;<br> <span class="hljs-keyword">return</span>;<br> &#125;<br> singletonMap.put(beanName, bean);<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>BeanFactory.java</li></ul><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829103144117.png" alt="image-20220829103144117" style="zoom:80%;" /><p>对象工厂，我们最 核心 的一个类，在它初始化的时候，创建了bean注册器，完成了资源的加载。<br>获取bean的时候，先从单例缓存中取，如果没有取到，就创建并注册一个bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br>     <span class="hljs-keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>     <span class="hljs-keyword">private</span> BeanRegister beanRegister;<br>     <span class="hljs-keyword">public</span> <span class="hljs-title function_">BeanFactory</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">//创建bean注册器</span><br>         beanRegister = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanRegister</span>();<br>         <span class="hljs-comment">//加载资源</span><br>         <span class="hljs-built_in">this</span>.beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceLoader</span>().getResource();<br> &#125;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取bean</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanName bean名称</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> &#123;<br>         <span class="hljs-comment">//从bean缓存中取</span><br>         <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanRegister.getSingletonBean(beanName);<br>         <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> bean;<br>        &#125;<br>         <span class="hljs-comment">//根据bean定义，创建bean</span><br>         <span class="hljs-keyword">return</span> createBean(beanDefinitionMap.get(beanName));<br> &#125;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建Bean</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanDefinition bean定义</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br>     <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(BeanDefinition beanDefinition)</span> &#123;<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> beanDefinition.getBeanClass().newInstance();<br> <span class="hljs-comment">//缓存bean</span><br><br>        beanRegister.registerSingletonBean(beanDefinition.getBeanName(),<br>        bean);<br>         <span class="hljs-keyword">return</span> bean;<br> &#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException e)<br>&#123;<br>     e.printStackTrace();<br> &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试 <ul><li>UserDao.java<br>我们的Bean类，很简单</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDao</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">queryUserInfo</span><span class="hljs-params">()</span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;A good man.&quot;</span>);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>单元测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiTest</span> &#123;<br> <span class="hljs-meta">@Test</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test_BeanFactory</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">//1.创建bean⼯⼚(同时完成了加载资源、创建注册单例bean注册器的操作)</span><br>    <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactory</span>();<br>    <span class="hljs-comment">//2.第⼀次获取bean（通过反射创建bean，缓存bean）</span><br>     <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao1</span> <span class="hljs-operator">=</span> (UserDao) beanFactory.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);<br>     userDao1.queryUserInfo();<br>     <span class="hljs-comment">//3.第⼆次获取bean（从缓存中获取bean）</span><br>     <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao2</span> <span class="hljs-operator">=</span> (UserDao) beanFactory.getBean(<span class="hljs-string">&quot;userDao&quot;</span>);<br>     userDao2.queryUserInfo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>运行结果</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">A good man.<br>A good man.<br></code></pre></td></tr></table></figure><hr><h2 id="谈谈自己对于-AOP-的了解"><a href="#谈谈自己对于-AOP-的了解" class="headerlink" title="谈谈自己对于 AOP 的了解"></a>谈谈自己对于 AOP 的了解</h2><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829104652577.png" alt="image-20220829104652577" style="zoom:80%;" /><p>具体来说，假如我现在要crud写一堆业务，可是如何业务代码前后前后进行打印日志和参数的校验呢？</p><p>我们可以把日志记录和数据校验可重用的功能模块分离出来，然后在程序的执行的合适的地方动态地植入这些代码并执行。这样就简化了代码的书写。</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829104940660.png" alt="image-20220829104940660" style="zoom:80%;" /><p>业务逻辑代码中没有参和通用逻辑的代码，业务模块更简洁，只包含核心业务代码。实现了业务逻辑和通用逻辑的代码分离，便于维护和升级，降低了业务逻辑和通用逻辑的耦合性。</p><p>AOP 可以将遍布应用各处的功能分离出来形成可重用的组件。在编译期间、装载期间或运行期间实现在不修改源代码的情况下给程序动态添加功能。从而实现对业务逻辑的隔离，提高代码的模块化能力。</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829105759783.png" alt="image-20220829105759783" style="zoom:80%;" /><p>AOP 的核心其实就是 动态代理 ，如果是实现了接又的话就会使用 JDK 动态代理，否则使用CGLIB 代理，主要应用于处理一些具有横切性质的系统级服务，如日志收集、事务管理、安全检查、缓存、对象池管理等。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829105922451.png" alt="image-20220829105922451"></p><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><hr><h2 id="AOP有哪些核心概念？"><a href="#AOP有哪些核心概念？" class="headerlink" title="AOP有哪些核心概念？"></a>AOP有哪些核心概念？</h2><ul><li><p><strong>切面 （Aspect）</strong>：类是对物体特征的抽象，切面就是对横切关注点的抽象</p></li><li><p><strong>连接点 （Joinpoint）</strong>：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p></li><li><p><strong>切点 （Pointcut）</strong>：对连接点进行拦截的定位</p></li><li><p><strong>通知 （Advice）</strong>：所谓通知指的就是指拦截到连接点之后要执行的代码，也可以称作增强</p></li><li><p><strong>目标对象 （Target）</strong>：代理的目标对象</p></li><li><p><strong>织入 （Weabing）</strong>：织入是将增强添加到目标类的具体连接点上的过程。</p><ul><li><p><strong>编译期织入</strong>：切面在目标类编译时被织入</p></li><li><p><strong>类加载期织入</strong>：切面在目标类加载到JVM时被织入。需要特殊的类加载器，它可以在目标类被引入应用之前增强该目标类的字节码。</p></li><li><p><strong>运行期织入</strong>：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态地创建一个代理对象。SpringAOP就是以这种方式织入切面。Spring采用运行期织入，而AspectJ采用编译期织入和类加载器织入。</p></li><li><p><strong>引介 （introduction）</strong>：引介是一种特殊的增强，可以动态地为类添加一些属性和方法</p></li></ul></li></ul><hr><h2 id="AOP有哪些环绕方式？"><a href="#AOP有哪些环绕方式？" class="headerlink" title="AOP有哪些环绕方式？"></a>AOP有哪些环绕方式？</h2><p>AOP 一般有 <strong>5 种</strong> 环绕方式：</p><ul><li>前置通知 (@Before)</li><li>返回通知 (@AfterReturning)</li><li>异常通知 (@AfterThrowing)</li><li>后置通知 (@After)</li><li>环绕通知 (@Around)</li></ul><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829110716136.png" alt="image-20220829110716136" style="zoom:80%;" /><p>多个切面的情况下，可以通过 @Order 指定先后顺序，数字越小，优先级越高。</p><hr><h2 id="说说你平时有用到AOP吗？"><a href="#说说你平时有用到AOP吗？" class="headerlink" title="说说你平时有用到AOP吗？"></a>说说你平时有用到AOP吗？</h2><p>SpringBoot项目中，利用AOP打印接又的入参和出参日志，以及执行时间，还是比较快捷的。</p><p>引入依赖：引入AOP依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>自定义注解：自定义一个注解作为切点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> WebLog &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置AOP切面：</p><p><strong>@Aspect</strong>：标识切面<br><strong>@Pointcut</strong>：设置切点，这里以自定义注解为切点，定义切点有很多其它种方式，自定<br>义注解是比较常用的一种。<br><strong>@Before</strong>：在切点之前织入，打印了一些入参信息<br><strong>@Around</strong>：环绕切点，打印返回参数和接又执行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebLogAspect</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span>LoggerFactory.getLogger(WebLogAspect.class);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 以自定义 <span class="hljs-doctag">@WebLog</span> 注解为切点</span><br><span class="hljs-comment">    **/</span><br>    <span class="hljs-meta">@Pointcut(&quot;@annotation(cn.fighter3.spring.aop_demo.WebLog)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">webLog</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 在切点之前织入</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Before(&quot;webLog()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 开始打印请求日志</span><br>    <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span><br>    (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> attributes.getRequest();<br>    <span class="hljs-comment">// 打印请求相关参数</span><br>    logger.info(<span class="hljs-string">&quot;========================================== Start</span><br><span class="hljs-string">    ==========================================&quot;</span>);<br>    <span class="hljs-comment">// 打印请求 url</span><br>    logger.info(<span class="hljs-string">&quot;URL : &#123;&#125;&quot;</span>,<br>    request.getRequestURL().toString());<br>    <span class="hljs-comment">// 打印 Http method</span><br>    logger.info(<span class="hljs-string">&quot;HTTP Method : &#123;&#125;&quot;</span>, request.getMethod());<br>    <span class="hljs-comment">// 打印调用 controller 的全路径以及执行方法</span><br>    logger.info(<span class="hljs-string">&quot;Class Method : &#123;&#125;.&#123;&#125;&quot;</span>,<br>    joinPoint.getSignature().getDeclaringTypeName(),<br>    joinPoint.getSignature().getName());<br>    <span class="hljs-comment">// 打印请求的 IP</span><br>    logger.info(<span class="hljs-string">&quot;IP : &#123;&#125;&quot;</span>, request.getRemoteAddr());<br>    <span class="hljs-comment">// 打印请求入参</span><br>    logger.info(<span class="hljs-string">&quot;Request Args : &#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span><br>    <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(joinPoint.getArgs()));<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 在切点之后织入</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@After(&quot;webLog()&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// 结束后打个分隔线，方便查看</span><br>    logger.info(<span class="hljs-string">&quot;===========================================End===========================================&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 环绕</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Around(&quot;webLog()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span><br>    <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">//开始时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proceedingJoinPoint.proceed();<br>    <span class="hljs-comment">// 打印出参</span><br>logger.info(<span class="hljs-string">&quot;Response Args : &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span><br>    <span class="hljs-title class_">ObjectMapper</span>().writeValueAsString(result));<br>    <span class="hljs-comment">// 执行耗时</span><br>    logger.info(<span class="hljs-string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>,<br>    System.currentTimeMillis() - startTime);<br>    <span class="hljs-keyword">return</span> result;<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>使用：只需要在接又上加上自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br><span class="hljs-meta">@WebLog(desc = &quot;这是一个欢迎接口&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">hello</span><span class="hljs-params">(String name)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span>+name;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：可以看到日志打印了入参、出参和执行时间</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829135120441.png" alt="image-20220829135120441"></p><h2 id="说说JDK-动态代理和-CGLIB-代理-？"><a href="#说说JDK-动态代理和-CGLIB-代理-？" class="headerlink" title="说说JDK 动态代理和 CGLIB 代理 ？"></a>说说JDK 动态代理和 CGLIB 代理 ？</h2><p>Spring的AOP是通过<strong>动态代理</strong>来实现的，动态代理主要有两种方式<strong>JDK动态代理</strong>和<strong>Cglib动态代理</strong>，这两种动态代理的使用和原理有些不同。</p><p><strong>JDK 动态代理</strong></p><p><strong>1.</strong> <strong>Interface</strong>：对于 JDK 动态代理，目标类需要实现一个Interface。<br><strong>2.</strong> <strong>InvocationHandler</strong>：InvocationHandler是一个接口，可以通过实现这个接口，定义横切逻辑，再通过反射机制（invoke）调用目标类的代码，在次过程，可能包装逻辑，对目标方法进行前置后置处理。<br><strong>3.</strong> <strong>Proxy</strong>：Proxy利用InvocationHandler动态创建一个符合目标类实现的接口的实例，生成目标类的代理对象。</p><p><strong>CgLib 动态代理</strong></p><p><strong>1.</strong> 使用JDK创建代理有一大限制，它只能为接又创建代理实例，而CgLib 动态代理就没有这个限制。<br><strong>2.</strong> CgLib 动态代理是使用字节码处理框架 ASM，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。<br><strong>3.</strong> CgLib 创建的动态代理对象性能比 JDK 创建的动态代理对象的性能高不少，但是 CGLib在创建代理对象时所花费的时间却比 JDK 多得多，所以对于单例的对象，因为无需频繁创建对象，用 CGLib 合适，反之，使用 JDK 方式要更为合适一些。同时，由于 CGLib 由于是采用动态创建子类的方法，对于 final 方法，无法进行代理。</p><p>我们来看一个常见的小场景，客服中转，解决用户问题：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829135838484.png" alt="image-20220829135838484"></p><p><strong>JDK动态代理实现：</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829135923848.png" alt="image-20220829135923848"></p><ul><li>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ISolver</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>目标类:需要实现对应接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ISolver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;疯狂掉头发解决问题......&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理工厂:ProxyFactory，直接用反射方式生成一个目标对象的代理对象，这里用了一个匿名内部类方式重写InvocationHandler方法，实现接口重写也差不多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> &#123;<br><span class="hljs-comment">// 维护一个目标对象</span><br>    <span class="hljs-keyword">private</span> Object target;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>    <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <span class="hljs-comment">// 为目标对象生成代理对象</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method,Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;请问有什么可以帮到您？&quot;</span>);<br>         <span class="hljs-comment">// 调用目标对象方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> method.invoke(target,args);<br>        System.out.println(<span class="hljs-string">&quot;问题已经解决啦！&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：Client，生成一个代理对象实例，通过代理对象调用目标对象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//目标对象:程序员</span><br><span class="hljs-type">ISolver</span> <span class="hljs-variable">developer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solver</span>();<br><span class="hljs-comment">//代理：客服小姐姐</span><br><span class="hljs-type">ISolver</span> <span class="hljs-variable">csProxy</span> <span class="hljs-operator">=</span> (ISolver) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(developer).getProxyInstance();<br><span class="hljs-comment">//目标方法：解决问题</span><br>csProxy.solve();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Cglib动态代理实现：</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829141015357.png" alt="image-20220829141015357"></p><p>目标类：Solver，这里目标类不用再实现接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;疯狂掉头发解决问题......&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>动态代理工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>    <span class="hljs-comment">//维护一个目标对象</span><br>    <span class="hljs-keyword">private</span> Object target;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyFactory</span><span class="hljs-params">(Object target)</span> &#123;<br>    <span class="hljs-built_in">this</span>.target = target;<br>&#125;<br><br><span class="hljs-comment">//为目标对象生成代理对象</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//工具类</span><br>    <span class="hljs-type">Enhancer</span> <span class="hljs-variable">en</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Enhancer</span>();<br>    <span class="hljs-comment">//设置父类</span><br>    en.setSuperclass(target.getClass());<br>    <span class="hljs-comment">//设置回调函数</span><br>    en.setCallback(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//创建子类对象代理</span><br>    <span class="hljs-keyword">return</span> en.create();<br>&#125;<br>    <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] args,MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    System.out.println(<span class="hljs-string">&quot;请问有什么可以帮到您？&quot;</span>);<br>    <span class="hljs-comment">// 执行目标对象的方法</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">returnValue</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>    System.out.println(<span class="hljs-string">&quot;问题已经解决啦！&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端：Client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//目标对象:程序员</span><br>        <span class="hljs-type">Solver</span> <span class="hljs-variable">developer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Solver</span>();<br>        <span class="hljs-comment">//代理：客服小姐姐</span><br>        <span class="hljs-type">Solver</span> <span class="hljs-variable">csProxy</span> <span class="hljs-operator">=</span> (Solver) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>(developer).getProxyInstance();<br>        <span class="hljs-comment">//目标方法：解决问题</span><br>        csProxy.solve();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><p><strong>Spring AOP 属于运行时增强</strong>，主要具有如下特点：</p><p><strong>1.</strong> 基于动态代理来实现，默认如果使用接又的，用 JDK 提供的动态代理实现，如果是方法则使用 CGLIB 实现<br><strong>2.</strong> Spring AOP 需要依赖 IOC 容器来管理，并且只能作用于 Spring 容器，使用纯 Java 代码实现<br><strong>3.</strong> 在性能上，由于 Spring AOP 是基于动态代理来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 的那么好。<br><strong>4.</strong> Spring AOP 致力于解决企业级开发中最普遍的 AOP(方法织入)。</p><p><strong>AspectJ</strong></p><p><strong>AspectJ 是一个易用的功能强大的 AOP 框架，属于编译时增强</strong>， 可以单独使用，也可以整合到其它框架中，是 AOP 编程的完全解决方案。AspectJ 需要用到单独的编译器 ajc。</p><p>AspectJ 属于 <strong>静态织入</strong> ，通过修改代码来实现，在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的，一般有如下几个织入的时机：</p><p><strong>1.</strong> <strong>编译期织入</strong>（Compile-time weaving）：如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。<br><strong>2.</strong> <strong>编译后织入</strong>（Post-compile weaving）：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。<br><strong>3.</strong> <strong>类加载后织入</strong>（Load-time weaving）：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法</p><p><strong>整体对比如下：</strong></p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829170537767.png" alt="image-20220829170537767"></p><hr><h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a><strong>Spring Bean</strong></h1><h2 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h2><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- Constructor-arg with <span class="hljs-string">&#x27;value&#x27;</span> attribute --&gt;<br>&lt;bean id=<span class="hljs-string">&quot;...&quot;</span> class=<span class="hljs-string">&quot;...&quot;</span>&gt;<br>   &lt;constructor-arg value=<span class="hljs-string">&quot;...&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829170830985.png" alt="image-20220829170830985"></p><p><strong>org.springframework.beans</strong>和 <strong>org.springframework.context</strong> 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看</p><hr><h2 id="Bean定义和依赖定义有哪些方式？"><a href="#Bean定义和依赖定义有哪些方式？" class="headerlink" title="Bean定义和依赖定义有哪些方式？"></a>Bean定义和依赖定义有哪些方式？</h2><p>有三种方式： 直接编码方式 、 配置文件方式 、 注解方式 。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829171034149.png" alt="image-20220829171034149"></p><ul><li><strong>直接编码方式</strong>：我们一般接触不到直接编码的方式，但其实其它的方式最终都要通过直接编码来实现。</li><li><strong>配置文件方式</strong>：通过xml、propreties类型的配置文件，配置相应的依赖关系，Spring读取配置文件，完成依赖关系的注入。</li><li><strong>注解方式</strong>：注解方式应该是我们用的最多的一种方式了，在相应的地方使用注解修饰，Spring会扫描注解，完成依赖关系的注入。</li></ul><h2 id="有哪些依赖注入的方法？"><a href="#有哪些依赖注入的方法？" class="headerlink" title="有哪些依赖注入的方法？"></a>有哪些依赖注入的方法？</h2><p>Spring支持 <strong>构造方法注入</strong> 、 <strong>属性注入</strong> 、 <strong>工厂方法注入</strong> ,其中工厂方法注入，又可以分为 <strong>静态工厂方法注入</strong> 和 <strong>非静态工厂方法注入</strong> 。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829172455414.png" alt="image-20220829172455414"></p><ul><li><h6 id="构造方法注入"><a href="#构造方法注入" class="headerlink" title="构造方法注入"></a><strong>构造方法注入</strong></h6><p>通过调用类的构造方法，将接又实现类通过构造方法变量传入</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CatDaoImpl</span><span class="hljs-params">(String message)</span>&#123;<br><span class="hljs-built_in">this</span>. message = message;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;CatDaoImpl&quot;</span> class=<span class="hljs-string">&quot;com.CatDaoImpl&quot;</span>&gt;<br>&lt;constructor-arg value=<span class="hljs-string">&quot; message &quot;</span>&gt;&lt;/constructor-arg&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><ul><li><p><strong>属性注入</strong></p><p>通过Setter方法完成调用类所需依赖的注入</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Id</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> id; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123; <span class="hljs-built_in">this</span>.id = id; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;id&quot;</span> class=<span class="hljs-string">&quot;com.id &quot;</span>&gt;<br>&lt;property name=<span class="hljs-string">&quot;id&quot;</span> value=<span class="hljs-string">&quot;123&quot;</span>&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><ul><li><strong>工厂方法注入</strong><ul><li><strong>静态工厂注入</strong></li></ul></li></ul><p>​            静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让Spring 管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过 Spring 注入的形式获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaoFactory</span> &#123; <span class="hljs-comment">//静态工厂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FactoryDao <span class="hljs-title function_">getStaticFactoryDaoImpl</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticFacotryDaoImpl</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAction</span> &#123;<br>    <span class="hljs-comment">//注入对象</span><br>    <span class="hljs-keyword">private</span> FactoryDao staticFactoryDao;<br>    <span class="hljs-comment">//注入对象的 set 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStaticFactoryDao</span><span class="hljs-params">(FactoryDao staticFactoryDao)</span> &#123;<br>    <span class="hljs-built_in">this</span>.staticFactoryDao = staticFactoryDao;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法</span><br>&lt;bean name=<span class="hljs-string">&quot;springAction&quot;</span> class=<span class="hljs-string">&quot; SpringAction&quot;</span> &gt;<br>&lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt;<br>&lt;property name=<span class="hljs-string">&quot;staticFactoryDao&quot;</span> ref=<span class="hljs-string">&quot;staticFactoryDao&quot;</span>&gt;<br>&lt;/property&gt;<br>&lt;/bean&gt;<br><br>&lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt;<br>&lt;bean name=<span class="hljs-string">&quot;staticFactoryDao&quot;</span> class=<span class="hljs-string">&quot;DaoFactory&quot;</span> factory-method=<span class="hljs-string">&quot;getStaticFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><ul><li>非静态工厂注入<br>非静态工厂，也叫实例工厂，意思是工厂方法不是静态的，所以我们需要首先 new 一个工厂实例，再调用普通的实例方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DaoFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FactoryDao <span class="hljs-title function_">getFactoryDaoImpl</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FacotryDaoImpl</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringAction</span> &#123;<br>    <span class="hljs-comment">//注入对象</span><br>    <span class="hljs-keyword">private</span> FactoryDao staticFactoryDao;<br>    <span class="hljs-comment">//注入对象的 set 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFactoryDao</span><span class="hljs-params">(FactoryDao FactoryDao)</span> &#123;<br>    <span class="hljs-built_in">this</span>.FactoryDao = FactoryDao;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean name=<span class="hljs-string">&quot;springAction&quot;</span> class=<span class="hljs-string">&quot;SpringAction&quot;</span>&gt;<br>    &lt;!--使用非静态工厂的方法注入对象,对应下面的配置文件--&gt;<br>    &lt;property name=<span class="hljs-string">&quot;factoryDao&quot;</span> ref=<span class="hljs-string">&quot;factoryDao&quot;</span>&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br>    <br>&lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;<br>&lt;bean name=<span class="hljs-string">&quot;daoFactory&quot;</span> class=<span class="hljs-string">&quot;com.DaoFactory&quot;</span>&gt;&lt;/bean&gt;<br>    <br>&lt;bean name=<span class="hljs-string">&quot;factoryDao&quot;</span> factory-bean=<span class="hljs-string">&quot;daoFactory&quot;</span> factory-method=<span class="hljs-string">&quot;getFactoryDaoImpl&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><hr><h2 id="什么是自动装配？"><a href="#什么是自动装配？" class="headerlink" title="什么是自动装配？"></a>什么是自动装配？</h2><p>Spring IOC容器知道所有Bean的配置信息，此外，通过Java反射机制还可以获知实现类的结构信息，如构造方法的结构、属性等信息。掌握所有Bean的这些信息后，Spring IOC容器就可以按照某种规则对容器中的Bean进行自动装配，而无须通过显式的方式进行依赖配置。</p><p>Spring提供的这种方式，可以按照某些规则进行Bean的自动装配，元素提供了一个指定自动装配类型的属性：<br>autowire=”&lt;自动装配类型&gt;”</p><p>Spring提供了 4 种自动装配类型：</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220829212327996.png" alt="image-20220829212327996" style="zoom:80%;" /><ul><li><strong>byName</strong>：根据名称进行自动匹配，假设Boss又一个名为car的属性，如果容器中刚好有一个名为car的bean，Spring就会自动将其装配给Boss的car属性</li><li><strong>byType</strong>：根据类型进行自动匹配，假设Boss有一个Car类型的属性，如果容器中刚好有一个Car类型的Bean，Spring就会自动将其装配给Boss这个属性</li><li><strong>constructor</strong>：与 byType类似， 只不过它是针对构造函数注入而言的。如果Boss有一个构造函数，构造函数包含一个Car类型的入参，如果容器中有一个Car类型的Bean，则Spring将自动把这个Bean作为Boss构造函数的入参；如果容器中没有找到和构造函数入参匹配类型的Bean，则Spring将抛出异常。</li><li><strong>autodetect</strong>：根据Bean的自省机制决定采用byType还是constructor进行自动装配，如果Bean提供了默认的构造函数，则采用byType，否则采用constructor。</li></ul><hr><h2 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="将一个类声明为 Bean 的注解有哪些?"></a>将一个类声明为 Bean 的注解有哪些?</h2><ul><li><p><strong>@Component</strong> ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</p></li><li><p><strong>@Repository</strong> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p></li><li><p><strong>@Service</strong> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p></li><li><p><strong>@Controller</strong> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p></li></ul><hr><h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ul><li><p>@Component 注解作用于类，而@Bean注解作用于方法。</p></li><li><p>@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p></li><li><p>@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</p></li></ul><p>@Bean注解使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AppConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TransferService <span class="hljs-title function_">transferService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferServiceImpl</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码相当于下面的 xml 配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;beans&gt;<br>    &lt;bean id=<span class="hljs-string">&quot;transferService&quot;</span> class=<span class="hljs-string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure><p>下面这个例子是通过 @Component 无法实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> OneService <span class="hljs-title function_">getService</span><span class="hljs-params">(status)</span> &#123;<br>    <span class="hljs-keyword">case</span> (status)  &#123;<br>        when <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl1</span>();<br>        when <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl2</span>();<br>        when <span class="hljs-number">3</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">serviceImpl3</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="Autowired-和-Resource-的区别是什么？"><a href="#Autowired-和-Resource-的区别是什么？" class="headerlink" title="@Autowired 和 @Resource 的区别是什么？"></a>@Autowired 和 @Resource 的区别是什么？</h2><p><strong>Autowired</strong> 属于 <strong>Spring 内置</strong>的注解，默认的注入方式为<strong>byType</strong>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 <strong>byName</strong>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 smsService 就是我这里所说的名称，这样应该比较好理解了吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// smsService 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br></code></pre></td></tr></table></figure><p>举个例子，SmsService 接口有两个实现类: SmsServiceImpl1和 SmsServiceImpl2，且它们都已经被 Spring 容器所管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 报错，byName 和 byType 都无法匹配到 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><span class="hljs-comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> SmsService smsServiceImpl1;<br><span class="hljs-comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><br><span class="hljs-comment">// smsServiceImpl1 就是我们上面所说的名称</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(value = &quot;smsServiceImpl1&quot;)</span><br><span class="hljs-keyword">private</span> SmsService smsService;<br><br></code></pre></td></tr></table></figure><hr><h2 id="Autowired的实现原理？"><a href="#Autowired的实现原理？" class="headerlink" title="@Autowired的实现原理？"></a>@Autowired的实现原理？</h2><p>实现@Autowired的关键是： <strong>AutowiredAnnotationBeanPostProcessor</strong></p><p>在Bean的初始化阶段，会通过Bean后置处理器来进行一些前置和后置的处理。</p><p>实现@Autowired的功能，也是通过后置处理器来完成的。这个后置处理器就是<strong>AutowiredAnnotationBeanPostProcessor</strong>。</p><p>Spring在创建bean的过程中，最终会调用到<strong>doCreateBean()**方法，在doCreateBean()方法中会调用</strong>populateBean()<strong>方法，来为bean进行属性填充，完成自动装配等工作。<br>在populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行</strong>第二次后置处理器<strong>的调用，这个时候，就会调用到<br>**AutowiredAnnotationBeanPostProcessor</strong>的<strong>postProcessPropertyValues()**方法，在该方法中就会进行</strong>@Autowired注解**的解析，然后实现自动装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 属性赋值</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd,<span class="hljs-meta">@Nullable</span> BeanWrapper bw)</span> &#123;<br><span class="hljs-comment">//............</span><br><span class="hljs-keyword">if</span> (hasInstAwareBpps) &#123;<br>        <span class="hljs-keyword">if</span> (pvs == <span class="hljs-literal">null</span>) &#123;<br>            pvs = mbd.getPropertyValues();<br>        &#125;<br>PropertyValues pvsToUse;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">Iterator</span> <span class="hljs-variable">var9</span> <span class="hljs-operator">=</span><span class="hljs-built_in">this</span>.getBeanPostProcessorCache().instantiationAware.iterator();var9.hasNext(); pvs = pvsToUse) &#123;<br><span class="hljs-type">InstantiationAwareBeanPostProcessor</span> <span class="hljs-variable">bp</span> <span class="hljs-operator">=</span>(InstantiationAwareBeanPostProcessor)var9.next();<br>pvsToUse =bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(),beanName);<br><span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (filteredPds == <span class="hljs-literal">null</span>) &#123;<br>        filteredPds =<span class="hljs-built_in">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);<br>        &#125;<br>        <span class="hljs-comment">//执行后处理器，填充属性，完成自动装配</span><br>        <span class="hljs-comment">//调用InstantiationAwareBeanPostProcessor的</span><br>postProcessPropertyValues()方法<br>pvsToUse =bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds,bw.getWrappedInstance(), beanName);<br>            <span class="hljs-keyword">if</span> (pvsToUse == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//............</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>postProcessorPropertyValues()**方法的源码如下，在该方法中，会先调用</strong>findAutowiringMetadata()<strong>方法解析出bean中带有</strong>@Autowired注解、@Inject和@Value**注解的属性和方法。然后调用metadata.inject()方法，进行属性填充。</li></ul><hr><h2 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="Bean 的作用域有哪些?"></a>Bean 的作用域有哪些?</h2><p>Spring 中 Bean 的作用域通常有下面几种：</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830105345669.png" alt="image-20220830105345669" style="zoom:80%;" /><ul><li><p><strong>singleton</strong> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的，对单例设计模式的应用。</p></li><li><p><strong>prototype</strong> : 每次请求都会创建一个新的 bean 实例。</p></li><li><p><strong>request</strong> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</p></li><li><p><strong>session</strong> : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</p></li><li><p><strong>global-session</strong> ： 全局 session 作用域，仅仅在基于 portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码(例如：HTML)片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</p></li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p><strong>xml 方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;...&quot;</span> class=<span class="hljs-string">&quot;...&quot;</span> scope=<span class="hljs-string">&quot;singleton&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p><strong>注解方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="hljs-keyword">public</span> Person <span class="hljs-title function_">personPrototype</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="单例-Bean-的线程安全问题了解吗？"><a href="#单例-Bean-的线程安全问题了解吗？" class="headerlink" title="单例 Bean 的线程安全问题了解吗？"></a>单例 Bean 的线程安全问题了解吗？</h2><p>首先结论在这：Spring中的单例Bean <strong>不是线程安全的</strong> 。</p><p>因为单例Bean，是全局只有一个Bean，所有<strong>线程共享</strong>。如果说单例Bean，是一个无状态的，也就是线程中的操作不会对Bean中的成员变量执行 <strong>查询</strong> 以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p><p>假如这个Bean是有状态的，也就是会对Bean中的成员变量进行<strong>写操作</strong>，那么可能就存在线程安全的问题。</p><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830110402167.png" alt="image-20220830110402167"></p><hr><h2 id="单例Bean线程安全问题怎么解决呢？"><a href="#单例Bean线程安全问题怎么解决呢？" class="headerlink" title="单例Bean线程安全问题怎么解决呢？"></a>单例Bean线程安全问题怎么解决呢？</h2><p>常见的有这么些解决办法：</p><p><strong>1.</strong> 将Bean定义为多例这样每一个线程请求过来都会创建一个新的Bean，但是这样容器就不好管理Bean，不能这么办。<br><strong>2.</strong> 在Bean对象中尽量避免定义可变的成员变量削足适履了属于是，也不能这么干。<br><strong>3.</strong> 将Bean中的成员变量保存在ThreadLocal中⭐我们知道ThredLoca能保证多线程下变量的隔离，可以在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在ThreadLocal里，这是推荐的一种方式。</p><hr><h2 id="Bean-的生命周期了解么"><a href="#Bean-的生命周期了解么" class="headerlink" title="Bean 的生命周期了解么?"></a>Bean 的生命周期了解么?</h2><p>在Spring中，基本容器BeanFactory和扩展容器ApplicationContext的实例化时机不太一样，BeanFactory采用的是延迟初始化的方式，也就是只有在第一次getBean()的时候，才会实例化Bean；ApplicationContext启动之后会实例化所有的Bean定义。</p><p>Spring IOC 中Bean的生命周期大致分为四个阶段： <strong>实例化</strong> （Instantiation）、 <strong>属性赋值</strong>（Populate）、 <strong>初始化</strong> （Initialization）、 <strong>销毁</strong> （Destruction）。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830113023936.png" alt="image-20220830113023936"></p><p><strong>实例化</strong>：第 1 步，实例化一个 Bean 对象<br><strong>属性赋值</strong>：第 2 步，为 Bean 设置相关属性和依赖<br><strong>初始化</strong>：初始化的阶段的步骤比较多， 5 、 6 步是真正的初始化，第 3 、 4 步为在初始化前执行，第 7 步在初始化后执行，初始化完成之后，Bean就可以被使用了<br><strong>销毁</strong>：第 8~10步，第 8 步其实也可以算到销毁阶段，但不是真正意义上的销毁，而是先在使用前注册了销毁的相关调用接又，为了后面第 9 、 10 步真正销毁 Bean 时再执行相应的方法</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830113036173.png" alt="image-20220830113036173"></p><p>简单总结⼀下，Bean⽣命周期⾥初始化的过程相对步骤会多⼀些，⽐如前置、后置的处理。 最后通过⼀个实例来看⼀下具体的细节</p><p>定义一个PersonBean 类，实现DisposableBean ,InitializingBean ,BeanFactoryAware , BeanNameAware 这 4 个接又，同时还有自定义的init-method和destroy-method 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>, BeanFactoryAware,BeanNameAware, DisposableBean &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">身份证号</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> Integer no;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">姓名</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">PersonBean</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;1.调用构造方法：我出生了！&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getNo</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> no;<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNo</span><span class="hljs-params">(Integer no)</span> &#123;<br><span class="hljs-built_in">this</span>.no = no;<br>&#125;<br><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>System.out.println(<span class="hljs-string">&quot;2.设置属性：我的名字叫&quot;</span>+name);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String s)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;3.调用BeanNameAware#setBeanName方法:我要上学了，起</span><br><span class="hljs-string">了个学名&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span><br>BeansException &#123;<br>System.out.println(<span class="hljs-string">&quot;4.调用BeanFactoryAware#setBeanFactory方法：选好学</span><br><span class="hljs-string">校了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;6.InitializingBean#afterPropertiesSet方法：入学</span><br><span class="hljs-string">登记&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;7.自定义init方法：努力上学ing&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>System.out.println(<span class="hljs-string">&quot;9.DisposableBean#destroy方法：平淡的一生落幕了&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroyMethod</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;10.自定义destroy方法:睡了，别想叫醒我&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Bean使用中：工作，只有对社会没有用的人才放假。。&quot;</span>);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String</span><br><span class="hljs-params">beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>System.out.println(<span class="hljs-string">&quot;5.BeanPostProcessor.postProcessBeforeInitialization方</span><br><span class="hljs-string">法：到学校报名啦&quot;</span>);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String</span><br><span class="hljs-params">beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br><br>System.out.println(<span class="hljs-string">&quot;8.BeanPostProcessor#postProcessAfterInitialization方</span><br><span class="hljs-string">法：终于毕业，拿到毕业证啦！&quot;</span>);<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置文件，指定init-method 和destroy-method 属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myBeanPostProcessor&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cn.fighter3.spring.life.MyBeanPostProcessor&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;personBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cn.fighter3.spring.life.PersonBean&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyMethod&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;idNo&quot;</span> <span class="hljs-attr">value</span>= <span class="hljs-string">&quot;80669865&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;张铁钢&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;spring-config.xml&quot;</span>);<br>        <span class="hljs-type">PersonBean</span> <span class="hljs-variable">personBean</span> <span class="hljs-operator">=</span> (PersonBean)<br>        context.getBean(<span class="hljs-string">&quot;personBean&quot;</span>);<br>        personBean.work();<br>        ((ClassPathXmlApplicationContext) context).destroy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>调用构造方法：我出生了！<br><span class="hljs-number">2.</span>设置属性：我的名字叫张铁钢<br><span class="hljs-number">3.</span>调用BeanNameAware#setBeanName方法:我要上学了，起了个学名<br><span class="hljs-number">4.</span>调用BeanFactoryAware#setBeanFactory方法：选好学校了<br><span class="hljs-number">5.</span>BeanPostProcessor#postProcessBeforeInitialization方法：到学校报名啦<br><span class="hljs-number">6.</span>InitializingBean#afterPropertiesSet方法：入学登记<br><span class="hljs-number">7.</span>自定义init方法：努力上学ing<br><span class="hljs-number">8.</span>BeanPostProcessor#postProcessAfterInitialization方法：终于毕业，拿到毕业证<br>啦！<br>Bean使用中：工作，只有对社会没有用的人才放假。。<br><span class="hljs-number">9.</span>DisposableBean#destroy方法：平淡的一生落幕了<br><span class="hljs-number">10.</span>自定义destroy方法:睡了，别想叫醒我<br></code></pre></td></tr></table></figure><hr><h2 id="说说循环依赖"><a href="#说说循环依赖" class="headerlink" title="说说循环依赖"></a>说说循环依赖</h2><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830123010500.png" alt="image-20220830123010500" style="zoom:80%;" /><p>Spring 循环依赖：简单说就是自己依赖自己，或者和别的Bean相互依赖。</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830123040716.png" alt="image-20220830123040716" style="zoom:80%;" /><p>只有单例的Bean才存在循环依赖的情况， <strong>原型</strong> (Prototype)情况下，Spring会直接抛出异常。原因很简单，AB循环依赖，A实例化的时候，发现依赖B，创建B实例，创建B的时候发现需要A，创建A1实例……无限套娃，直接把系统干垮。</p><h2 id="Spring可以解决哪些情况的循环依赖？"><a href="#Spring可以解决哪些情况的循环依赖？" class="headerlink" title="Spring可以解决哪些情况的循环依赖？"></a>Spring可以解决哪些情况的循环依赖？</h2><p>Spring不支持基于构造器注入的循环依赖，但是假如AB循环依赖，如果一个是构造器注入，一个是setter注入呢？</p><p>看看几种情形：</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830124807448.png" alt="image-20220830124807448" style="zoom:80%;" /><p>第四种可以而第五种不可以的原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建，所以 A 会先于 B 进行创建。</p><p>所以简单总结，当循环依赖的实例都采用setter方法注入的时候，Spring可以支持，都采用构造器注入的时候，不支持，构造器注入和setter注入同时存在的时候，看天。</p><hr><h2 id="那Spring怎么解决循环依赖的呢？"><a href="#那Spring怎么解决循环依赖的呢？" class="headerlink" title="那Spring怎么解决循环依赖的呢？"></a>那Spring怎么解决循环依赖的呢？</h2><p>我们都知道，单例Bean初始化完成，要经历三步：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830145252769.png" alt="image-20220830145252769"></p><p>注入就发生在第二步， <strong>属性赋值</strong> ，结合这个过程，Spring 通过 <strong>三级缓存</strong> 解决了循环依赖：</p><p><strong>1.</strong> 一级缓存 : Map&lt;String,Object&gt; singletonObjects，单例池，用于保存实例化、属性赋值（注入）、初始化完成的 bean 实例<br><strong>2.</strong> 二级缓存 : Map&lt;String,Object&gt; earlySingletonObjects，早期曝光对象，用于保存实例化完成的 bean 实例<br><strong>3.</strong> 三级缓存 : Map&lt;String,ObjectFactory&lt;?&gt;&gt; singletonFactories，早期曝光对象工厂，用于保存 bean 创建工厂，以便于后面扩展有机会创建代理对象。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830145321038.png" alt="image-20220830145321038"></p><p>我们来看一下三级缓存解决循环依赖的过程：</p><p>当 A、B 两个类发生循环依赖时：</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830145354533.png" alt="image-20220830145354533" style="zoom:80%;" /><p>A实例的初始化过程：</p><ol><li>创建A实例，实例化的时候把A对象工厂放入三级缓存，表示A开始实例化了，虽然我这个对象还不完整，但是先曝光出来让大家知道</li></ol><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830145430449.png" alt="image-20220830145430449" style="zoom:80%;" /><ol start="2"><li><p>A注入属性时，发现依赖B，此时B还没有被创建出来，所以去实例化B</p></li><li><p>同样，B注入属性时发现依赖A，它就会从缓存里找A对象。依次从一级到三级缓存查询A，从三级缓存通过对象工厂拿到A，发现A虽然不太完善，但是存在，把A放入二级缓存，同时删除三级缓存中的A，此时，B已经实例化并且初始化完成，把B放入一级缓存。</p></li></ol><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830145515442.png" alt="image-20220830145515442" style="zoom:80%;" /><ol start="4"><li><p>接着A继续属性赋值，顺利从一级缓存拿到实例化且初始化完成的B对象，A对象创建也完成，删除二级缓存中的A，同时把A放入一级缓存</p></li><li><p>最后，一级缓存中保存着实例化、初始化都完成的A、B对象</p></li></ol><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830145605736.png" alt="image-20220830145605736" style="zoom:80%;" /><p>所以，我们就知道为什么Spring能解决setter注入的循环依赖了，因为实例化和属性赋值是分开的，所以里面有操作的空间。如果都是构造器注入的化，那么都得在实例化这一步完成注入，所以自然是无法支持了。</p><hr><h2 id="为什么要三级缓存？二级不行吗？"><a href="#为什么要三级缓存？二级不行吗？" class="headerlink" title="为什么要三级缓存？二级不行吗？"></a>为什么要三级缓存？二级不行吗？</h2><p>不行，主要是为了生成代理对象 。如果是没有代理的情况下，使用二级缓存解决循环依赖也是OK的。但是如果存在代理，三级没有问题，二级就不行了。</p><p>因为三级缓存中放的是生成具体对象的匿名内部类，获取Object的时候，它可以生成代理对象，也可以返回普通对象。使用三级缓存主要是为了保证不管什么时候使用的都是一个对象。</p><p>假设只有二级缓存的情况，往二级缓存中放的显示一个普通的Bean对象，Bean初始化过程中，通过 BeanPostProcessor 去生成代理对象之后，覆盖掉二级缓存中的普通Bean对象，那么可能就导致取到的Bean对象不一致了。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830145941780.png" alt="image-20220830145941780"></p><hr><h1 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a><strong>Spring 事务</strong></h1><p>Spring 事务的本质其实就是<strong>数据库</strong>对事务的支持，没有数据库的事务支持，Spring 是无法提供事务功能的。Spring 只提供统一事务管理接口，具体实现都是由各数据库自己实现，数据库事务的提交和回滚是通过数据库自己的事务机制实现。</p><h2 id="Spring-事务的种类？"><a href="#Spring-事务的种类？" class="headerlink" title="Spring 事务的种类？"></a>Spring 事务的种类？</h2><p>Spring 支持<strong>编程式事务管理</strong>和<strong>声明式事务</strong>管理两种方式：</p><p><strong>1.**编程式事务<br>编程式事务管理使用 **TransactionTemplate</strong>，需要显式执行事务。</p><p><strong>2.</strong> 声明式事务<br><strong>3.</strong> 声明式事务管理建立在 <strong>AOP</strong> 之上的。其本质是通过 AOP 功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前启动一个事务，在执行完目标方法之后根据执行情况<strong>提交或者回滚事务</strong><br><strong>4.</strong> 优点是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过 <strong>@Transactional</strong> 注解的方式，便可以将事务规则应用到业务逻辑中，减少业务代码的污染。唯一不足地方是，最细粒度只能作用到方法级别，无法做到像编程式事务<br>那样可以作用到代码块级别。</p><hr><h2 id="Spring-的事务传播机制？"><a href="#Spring-的事务传播机制？" class="headerlink" title="Spring 的事务传播机制？"></a>Spring 的事务传播机制？</h2><p>Spring 事务的传播机制说的是，当多个事务同时存在的时候——一般指的是多个事务方法相互调用时，Spring 如何处理这些事务的行为。</p><p>事务传播机制是使用简单的 ThreadLocal 实现的，所以，如果调用的方法是在新线程调用的，事务传播实际上是会失效的。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830174152992.png" alt="image-20220830174152992"></p><p>Spring默认的事务传播行为是PROPAFATION_REQUIRED，它适合绝大多数情况，如果多个ServiceX#methodX()都工作在事务环境下（均被Spring事务增强），且程序中存在调用链Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的三个方法通过Spring的事务传播机制都工作在同一个事务中。</p><h3 id="七种事务传播行为详解与示例"><a href="#七种事务传播行为详解与示例" class="headerlink" title="七种事务传播行为详解与示例"></a>七种事务传播行为详解与示例</h3><p>在介绍七种事务传播行为前，我们先设计一个场景，帮助大家理解，场景描述如下</p><p>现有两个方法A和B，方法A执行会在数据库ATable插入一条数据，方法B执行会在数据库BTable插入一条数据，伪代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//将传入参数a存入ATable</span><br>pubilc <span class="hljs-keyword">void</span> <span class="hljs-title function_">A</span><span class="hljs-params">(a)</span>&#123;<br>    insertIntoATable(a);    <br>&#125;<br><span class="hljs-comment">//将传入参数b存入BTable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">B</span><span class="hljs-params">(b)</span>&#123;<br>    insertIntoBTable(b);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们看看在如下场景下，没有事务，情况会怎样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    testB();    <span class="hljs-comment">//调用testB</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    <span class="hljs-keyword">throw</span> Exception;     <span class="hljs-comment">//发生异常抛出</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里要做一个重要提示：<strong>Spring中事务的默认实现使用的是AOP，也就是代理的方式，如果大家在使用代码测试时，同一个Service类中的方法相互调用需要使用注入的对象来调用，不要直接使用this.方法名来调用，this.方法名调用是对象内部方法调用，不会通过Spring代理，也就是事务不会起作用</strong></p><p>以上伪代码描述的一个场景，方法testMain和testB都没有事务，执行testMain方法，那么结果会怎么样呢？</p><p>相信大家都知道了，就是a1数据成功存入ATable表，b1数据成功存入BTable表，而在抛出异常后b2数据存储就不会执行，也就是b2数据不会存入数据库，这就是没有事务的场景。</p><p>可想而知，在上一篇文章（认识事务）中举例的转账操作，如果在某一步发生异常，且没有事务，那么钱是不是就凭空消失了，所以事务在数据库操作中的重要性可想而知。接下我们就开始理解七种不同事务传播类型的含义</p><h4 id="REQUIRED-Spring默认的事务传播类型"><a href="#REQUIRED-Spring默认的事务传播类型" class="headerlink" title="REQUIRED(Spring默认的事务传播类型)"></a><strong>REQUIRED(Spring默认的事务传播类型)</strong></h4><p><strong>如果当前没有事务，则自己新建一个事务，如果当前存在事务，则加入这个事务</strong></p><p>*(示例1)*根据场景举栗子,我们在testMain和testB上声明事务，设置传播行为REQUIRED，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    testB();    <span class="hljs-comment">//调用testB</span><br>&#125;<br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    <span class="hljs-keyword">throw</span> Exception;     <span class="hljs-comment">//发生异常抛出</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该场景下执行testMain方法结果如何呢？</p><p>数据库没有插入新的数据，数据库还是保持着执行testMain方法之前的状态，没有发生改变。testMain上声明了事务，在执行testB方法时就加入了testMain的事务（<strong>当前存在事务，则加入这个事务</strong>），在执行testB方法抛出异常后事务会发生回滚，又testMain和testB使用的同一个事务，所以事务回滚后testMain和testB中的操作都会回滚，也就使得数据库仍然保持初始状态。</p><p>*(示例2)*根据场景再举一个栗子,我们只在testB上声明事务，设置传播行为REQUIRED，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    testB();    <span class="hljs-comment">//调用testB</span><br>&#125;<br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    <span class="hljs-keyword">throw</span> Exception;     <span class="hljs-comment">//发生异常抛出</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这时的执行结果又如何呢？</p><p>数据a1存储成功，数据b1和b2没有存储。由于testMain没有声明事务，testB有声明事务且传播行为是REQUIRED，所以在执行testB时会自己新建一个事务（<strong>如果当前没有事务，则自己新建一个事务</strong>），testB抛出异常则只有testB中的操作发生了回滚，也就是b1的存储会发生回滚，但a1数据不会回滚，所以最终a1数据存储成功，b1和b2数据没有存储。</p><h4 id="SUPPORTS"><a href="#SUPPORTS" class="headerlink" title="SUPPORTS"></a><strong>SUPPORTS</strong></h4><p><strong>当前存在事务，则加入当前事务，如果当前没有事务，就以非事务方法执行</strong></p><p>*(示例3)*根据场景举栗子，我们只在testB上声明事务，设置传播行为SUPPORTS，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    testB();    <span class="hljs-comment">//调用testB</span><br>&#125;<br><span class="hljs-meta">@Transactional(propagation = Propagation.SUPPORTS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    <span class="hljs-keyword">throw</span> Exception;     <span class="hljs-comment">//发生异常抛出</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下，执行testMain的最终结果就是，a1，b1存入数据库，b2没有存入数据库。由于testMain没有声明事务，且testB的事务传播行为是SUPPORTS，所以执行testB时就是没有事务的（<strong>如果当前没有事务，就以非事务方法执行</strong>），则在testB抛出异常时也不会发生回滚，所以最终结果就是a1和b1存储成功，b2没有存储。</p><p>那么当我们在testMain上声明事务且使用REQUIRED传播方式的时候，这个时候执行testB就满足<strong>当前存在事务，则加入当前事务</strong>，在testB抛出异常时事务就会回滚，最终结果就是a1，b1和b2都不会存储到数据库。</p><h4 id="MANDATORY"><a href="#MANDATORY" class="headerlink" title="MANDATORY"></a><strong>MANDATORY</strong></h4><p><strong>当前存在事务，则加入当前事务，如果当前事务不存在，则抛出异常。</strong></p><p>*(示例4)*场景举栗子，我们只在testB上声明事务，设置传播行为MANDATORY，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    testB();    <span class="hljs-comment">//调用testB</span><br>&#125;<br><span class="hljs-meta">@Transactional(propagation = Propagation.MANDATORY)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    <span class="hljs-keyword">throw</span> Exception;     <span class="hljs-comment">//发生异常抛出</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种情形的执行结果就是a1存储成功，而b1和b2没有存储。b1和b2没有存储，并不是事务回滚的原因，而是因为testMain方法没有声明事务，在去执行testB方法时就直接抛出事务要求的异常（<strong>如果当前事务不存在，则抛出异常</strong>），所以testB方法里的内容就没有执行。</p><p>那么如果在testMain方法进行事务声明，并且设置为REQUIRED，则执行testB时就会使用testMain已经开启的事务，遇到异常就正常的回滚了。</p><h4 id="REQUIRES-NEW"><a href="#REQUIRES-NEW" class="headerlink" title="REQUIRES_NEW"></a><strong>REQUIRES_NEW</strong></h4><p><strong>创建一个新事务，如果存在当前事务，则挂起该事务。</strong></p><p>可以理解为设置事务传播类型为REQUIRES_NEW的方法，在执行时，不论当前是否存在事务，总是会新建一个事务。</p><p>*(示例5)*场景举栗子，为了说明设置REQUIRES_NEW的方法会开启新事务，我们把异常发生的位置换到了testMain，然后给testMain声明事务，传播类型设置为REQUIRED，testB也声明事务，设置传播类型为REQUIRES_NEW，伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    testB();    <span class="hljs-comment">//调用testB</span><br>    <span class="hljs-keyword">throw</span> Exception;     <span class="hljs-comment">//发生异常抛出</span><br>&#125;<br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种情形的执行结果就是a1没有存储，而b1和b2存储成功，因为testB的事务传播设置为REQUIRES_NEW,所以在执行testB时会开启一个新的事务，testMain中发生的异常时在testMain所开启的事务中，所以这个异常不会影响testB的事务提交，testMain中的事务会发生回滚，所以最终a1就没有存储，而b1和b2就存储成功了。</p><p>与这个场景对比的一个场景就是testMain和testB都设置为REQUIRED，那么上面的代码执行结果就是所有数据都不会存储，因为testMain和testMain是在同一个事务下的，所以事务发生回滚时，所有的数据都会回滚。</p><h4 id="NOT-SUPPORTED"><a href="#NOT-SUPPORTED" class="headerlink" title="NOT_SUPPORTED"></a><strong>NOT_SUPPORTED</strong></h4><p><strong>始终以非事务方式执行,如果当前存在事务，则挂起当前事务</strong></p><p>可以理解为设置事务传播类型为NOT_SUPPORTED的方法，在执行时，不论当前是否存在事务，都会以非事务的方式运行。</p><p>*(示例6)*场景举栗子，testMain传播类型设置为REQUIRED，testB传播类型设置为NOT_SUPPORTED，且异常抛出位置在testB中，伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    testB();    <span class="hljs-comment">//调用testB</span><br>&#125;<br><span class="hljs-meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    <span class="hljs-keyword">throw</span> Exception;     <span class="hljs-comment">//发生异常抛出</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该场景的执行结果就是a1和b2没有存储，而b1存储成功。testMain有事务，而testB不使用事务，所以执行中testB的存储b1成功，然后抛出异常，此时testMain检测到异常事务发生回滚，但是由于testB不在事务中，所以只有testMain的存储a1发生了回滚，最终只有b1存储成功，而a1和b1都没有存储。</p><h4 id="NEVER"><a href="#NEVER" class="headerlink" title="NEVER"></a><strong>NEVER</strong></h4><p><strong>不使用事务，如果当前事务存在，则抛出异常</strong></p><p>很容易理解，就是我这个方法不使用事务，并且调用我的方法也不允许有事务，如果调用我的方法有事务则我直接抛出异常。</p><p>*示例7)*场景举栗子，testMain设置传播类型为REQUIRED，testB传播类型设置为NEVER，并且把testB中的抛出异常代码去掉，则伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    testB();    <span class="hljs-comment">//调用testB</span><br>&#125;<br><span class="hljs-meta">@Transactional(propagation = Propagation.NEVER)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该场景执行，直接抛出事务异常，且不会有数据存储到数据库。由于testMain事务传播类型为REQUIRED，所以testMain是运行在事务中，而testB事务传播类型为NEVER，所以testB不会执行而是<strong>直接抛出事务异常</strong>，此时testMain检测到异常就发生了回滚，所以最终数据库不会有数据存入。</p><h4 id="NESTED"><a href="#NESTED" class="headerlink" title="NESTED"></a><strong>NESTED</strong></h4><p><strong>如果当前事务存在，则在嵌套事务中执行，否则REQUIRED的操作一样（开启一个事务）</strong></p><p>这里需要注意两点：</p><ul><li>和REQUIRES_NEW的区别</li></ul><blockquote><p>REQUIRES_NEW是新建一个事务并且新开启的这个事务与原有事务无关，而NESTED则是当前存在事务时（我们把当前事务称之为父事务）会开启一个嵌套事务（称之为一个子事务）。<br>在NESTED情况下父事务回滚时，子事务也会回滚，而在REQUIRES_NEW情况下，原有事务回滚，不会影响新开启的事务。</p></blockquote><ul><li>和REQUIRED的区别</li></ul><blockquote><p>REQUIRED情况下，调用方存在事务时，则被调用方和调用方使用同一事务，那么被调用方出现异常时，由于共用一个事务，所以无论调用方是否catch其异常，事务都会回滚<br>而在NESTED情况下，被调用方发生异常时，调用方可以catch其异常，这样只有子事务回滚，父事务不受影响</p></blockquote><p>*(示例8)*场景举栗子，testMain设置为REQUIRED，testB设置为NESTED，且异常发生在testMain中，伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    testB();    <span class="hljs-comment">//调用testB</span><br>    <span class="hljs-keyword">throw</span> Exception;     <span class="hljs-comment">//发生异常抛出</span><br>&#125;<br><span class="hljs-meta">@Transactional(propagation = Propagation.NESTED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该场景下，所有数据都不会存入数据库，因为在testMain发生异常时，父事务回滚则子事务也跟着回滚了，可以与*(示例5)*比较看一下，就找出了与REQUIRES_NEW的不同</p><p>*(示例9)*场景举栗子，testMain设置为REQUIRED，testB设置为NESTED，且异常发生在testB中，伪代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMain</span><span class="hljs-params">()</span>&#123;<br>    A(a1);  <span class="hljs-comment">//调用A入参a1</span><br>    <span class="hljs-keyword">try</span>&#123;<br>        testB();    <span class="hljs-comment">//调用testB</span><br>    &#125;<span class="hljs-keyword">catch</span>（Exception e)&#123;<br><br>    &#125;<br>    A(a2);<br>&#125;<br><span class="hljs-meta">@Transactional(propagation = Propagation.NESTED)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testB</span><span class="hljs-params">()</span>&#123;<br>    B(b1);  <span class="hljs-comment">//调用B入参b1</span><br>    <span class="hljs-keyword">throw</span> Exception;     <span class="hljs-comment">//发生异常抛出</span><br>    B(b2);  <span class="hljs-comment">//调用B入参b2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种场景下，结果是a1,a2存储成功，b1和b2存储失败，因为调用方catch了被调方的异常，所以只有子事务回滚了。</p><p>同样的代码，如果我们把testB的传播类型改为REQUIRED，结果也就变成了：没有数据存储成功。就算在调用方catch了异常，整个事务还是会回滚，因为，调用方和被调方共用的同一个事务。</p><hr><h2 id="Spring-的事务隔离级别"><a href="#Spring-的事务隔离级别" class="headerlink" title="Spring 的事务隔离级别"></a>Spring 的事务隔离级别</h2><p>Spring的接又TransactionDefinition中定义了表示隔离级别的常量，当然其实主要还是对应数据<br>库的事务隔离级别：</p><p><strong>1.</strong> <strong>ISOLATION_DEFAULT</strong>：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。<br><strong>2.</strong> <strong>ISOLATION_READ_UNCOMMITTED</strong>：读未提交<br><strong>3.</strong> <strong>ISOLATION_READ_COMMITTED</strong>：读已提交<br><strong>4.</strong> <strong>ISOLATION_REPEATABLE_READ</strong>：可重复读<br><strong>5.</strong> <strong>ISOLATION_SERIALIZABLE</strong>：串行化</p><hr><h2 id="Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="@Transactional(rollbackFor = Exception.class)注解了解吗？"></a>@Transactional(rollbackFor = Exception.class)注解了解吗？</h2><p>Exception 分为运行时异常 RuntimeException 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p><p>当 @Transactional 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p><p>在 @Transactional 注解中如果不配置rollbackFor属性,那么事务只会在遇到RuntimeException的时候才会回滚，加上 <strong>rollbackFor=Exception.class</strong>,可以让事务在遇到<strong>非运行时异常</strong>时也回滚。</p><hr><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a><strong>Spring MVC</strong></h1><h2 id="说说自己对于-Spring-MVC-了解"><a href="#说说自己对于-Spring-MVC-了解" class="headerlink" title="说说自己对于 Spring MVC 了解?"></a>说说自己对于 Spring MVC 了解?</h2><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830150347255.png" alt="image-20220830150347255"></p><p><strong>Model 1 时代</strong></p><p>很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。</p><p>这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830152500012.png" alt="image-20220830152500012" style="zoom:80%;" /><p><strong>Model 2 时代</strong></p><p>学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。</p><ul><li><p>Model:系统涉及的数据，也就是 dao 和 bean。</p></li><li><p>View：展示模型中的数据，只是用来展示。</p></li><li><p>Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</p></li></ul><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830152547208.png" alt="image-20220830152547208" style="zoom:80%;" /><p>Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。</p><p>于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。</p><p><strong>Spring MVC 时代</strong></p><p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p><hr><h2 id="Spring-MVC-的核心组件？"><a href="#Spring-MVC-的核心组件？" class="headerlink" title="Spring MVC 的核心组件？"></a>Spring MVC 的核心组件？</h2><p><strong>1.</strong> <strong>DispatcherServlet</strong>：<strong>前置控制器</strong>，是整个流程控制的核心，控制其他组件的执行，进行统一调度，降低组件之间的耦合性，相当于总指挥。<br><strong>2.</strong> <strong>Handler</strong>：<strong>处理器</strong>，完成具体的业务逻辑，相当于 Servlet 或 Action。<br><strong>3.</strong> <strong>HandlerMapping</strong>：DispatcherServlet 接收到请求之后，通过 HandlerMapping 将不同的请求映射到不同的 Handler。<br><strong>4.</strong> <strong>HandlerInterceptor</strong>：<strong>处理器拦截器</strong>，是一个接口，如果需要完成一些拦截处理，可以实现该接口。<br><strong>5.</strong> <strong>HandlerExecutionChain</strong>：<strong>处理器执行链</strong>，包括两部分内容：Handler 和 HandlerInterceptor(系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。<br><strong>6.</strong> <strong>HandlerAdapter</strong>：<strong>处理器适配器</strong>，Handler 执行业务方法之前，需要进行一系列的操作，包括表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等，这些操作都是由 HandlerApater 来完成，开发者只需将注意力集中业务逻辑的处理上，DispatcherServlet<br>通过 HandlerAdapter 执行不同的 Handler。<br><strong>7.</strong> <strong>ModelAndView</strong>：<strong>装载了模型数据和视图信息</strong>，作为 Handler 的处理结果，返回给DispatcherServlet。<br><strong>8.</strong> <strong>ViewResolver</strong>：<strong>视图解析器</strong>，DispatcheServlet 通过它将逻辑视图解析为物理视图，最终将渲染结果响应给客户端。</p><hr><h2 id="Spring-MVC-的工作流程？"><a href="#Spring-MVC-的工作流程？" class="headerlink" title="Spring MVC 的工作流程？"></a>Spring MVC 的工作流程？</h2><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830154256885.png" alt="image-20220830154256885"></p><p><strong>1.</strong> 客户端向服务端发送一次请求，这个请求会先到<strong>前端控制器DispatcherServlet</strong>(也叫中央控制器)。<br><strong>2.</strong> DispatcherServlet接收到请求后会调用<strong>HandlerMapping处理器映射器</strong>。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）<br><strong>3.</strong> DispatcherServlet调用<strong>HandlerAdapter处理器适配器</strong>，告诉处理器适配器应该要去执行哪个Controller<br><strong>4.</strong> HandlerAdapter处理器适配器去执行Controller并得到<strong>ModelAndView(数据和视图)**，并层层返回给DispatcherServlet<br>**5.</strong> DispatcherServlet将ModelAndView交给<strong>ViewReslover视图解析器</strong>解析，然后返回真正的视图<br><strong>6.</strong> DispatcherServlet将模型数据填充到视图中<br><strong>7.</strong> DispatcherServlet将结果响应给客户端</p><p><strong>Spring MVC</strong> 虽然整体流程复杂，但是实际开发中很简单，大部分的组件不需要开发人员创建和管理，只需要通过配置文件的方式完成配置即可，真正需要开发人员进行处理的只有<strong>Handler（Controller）</strong> 、 <strong>View</strong> 、 <strong>Model</strong> 。</p><p>当然我们现在大部分的开发都是前后端分离，Restful风格接口，后端只需要返回Json数据就行了。</p><h2 id="SpringMVC-Restful风格的接又的流程是什么样的呢？"><a href="#SpringMVC-Restful风格的接又的流程是什么样的呢？" class="headerlink" title="SpringMVC Restful风格的接又的流程是什么样的呢？"></a>SpringMVC Restful风格的接又的流程是什么样的呢？</h2><p>我们都知道Restful接又，响应格式是json，这就用到了一个常用注解： <strong>@ResponseBody</strong></p><p>加入了这个注解后，整体的流程上和使用ModelAndView大体上相同，但是细节上有一些不同：</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830162855421.png" alt="image-20220830162855421" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">user</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>( <span class="hljs-number">1</span> ,<span class="hljs-string">&quot;张三&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1.</strong> 客户端向服务端发送一次请求，这个请求会先到前端控制器<strong>DispatcherServlet</strong><br><strong>2.</strong> DispatcherServlet接收到请求后会调用<strong>HandlerMapping</strong>处理器映射器。由此得知，该请求该由哪个<strong>Controller</strong>来处理<br><strong>3.</strong> DispatcherServlet调用<strong>HandlerAdapter处理器适配器</strong>，告诉处理器适配器应该要去执行哪个Controller<br><strong>4.</strong> Controller被封装成了<strong>ServletInvocableHandlerMethod</strong>，HandlerAdapter处理器适配器去执行<strong>invokeAndHandle</strong>方法，完成对Controller的请求处理<br><strong>5.</strong> HandlerAdapter执行完对Controller的请求，会调用<strong>HandlerMethodReturnValueHandler</strong>去处理返回值，主要的过程：<br>    <strong>5.1.</strong> 调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例<br>    <strong>5.2.**使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中<br>    **5.3.**在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化<br>**6.</strong> 执行完请求后，返回的ModealAndView为null，ServletServerHttpResponse里也已经写入了响应，所以不用关心View的处理</p><hr><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a><strong>Spring Boot</strong></h1><h2 id="介绍一下SpringBoot，有哪些优点？"><a href="#介绍一下SpringBoot，有哪些优点？" class="headerlink" title="介绍一下SpringBoot，有哪些优点？"></a>介绍一下SpringBoot，有哪些优点？</h2><p>Spring Boot 基于 Spring 开发，Spirng Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。它并不是用来替代Spring 的解决方案，而是和 Spring 框架紧密结合用于提升 Spring 开发者体验的工具。</p><p>Spring Boot 以<strong>约定大于配置核心思想</strong>开展工作，相比Spring具有如下优势：</p><p><strong>1.</strong> Spring Boot 可以<strong>快速创建</strong>独立的Spring应用程序。<br><strong>2.</strong> Spring Boot <strong>内嵌了如Tomcat，Jetty和Undertow</strong>这样的容器，也就是说可以直接跑起来，用不着再做部署工作了。<br><strong>3.</strong> Spring Boot 无需再像Spring一样使用一堆<strong>繁琐的xml文件配置</strong>。<br><strong>4.</strong> Spring Boot 可以<strong>自动配置(核心)Spring</strong>。SpringBoot将原有的XML配置改为Java配置，将bean注入改为使用注解注入的方式(@Autowire)，并将多个xml、properties配置浓缩在一个<strong>appliaction.yml</strong>配置文件中。<br><strong>5.</strong> Spring Boot 提供了一些现有的功能，如量度工具，表单数据验证以及一些外部配置这样的一些第三方功能。<br><strong>6.</strong> Spring Boot 可以<strong>快速整合常用依赖</strong>（开发库，例如spring-webmvc、jackson-json、validation-api和tomcat等），提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自引入其他依赖。</p><hr><h2 id="SpringBoot自动配置原理了解吗？"><a href="#SpringBoot自动配置原理了解吗？" class="headerlink" title="SpringBoot自动配置原理了解吗？"></a>SpringBoot自动配置原理了解吗？</h2><p>SpringBoot开启自动配置的注解是**@EnableAutoConfiguration** ，启动类上的注解**@SpringBootApplication<strong>是一个</strong>复合注解<strong>，包含了</strong>@EnableAutoConfiguration**：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830164916522.png" alt="image-20220830164916522"></p><p><strong>EnableAutoConfiguration</strong> 只是一个简单的注解，自动装配核心功能的实现实际是通过 <strong>AutoConfigurationImportSelector</strong>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfigurationPackage</span> <span class="hljs-comment">//将main同级的包下的所有组件注册到容器中</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="hljs-comment">//加载自动装配类</span><br>xxxAutoconfiguration<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span><span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>AutoConfigurationImportSelector</strong>实现了<strong>ImportSelector</strong>接口，这个接口的作用就是<strong>收集需要导入的配置类</strong>，配合**@Import(）<strong>就可以将相应的类导入到</strong>Spring容器<strong>中获取注入类的方法是</strong>selectImports()<strong>，它实际调用的是</strong>getAutoConfigurationEntry**，这个方法是获取自动装配类的关键，主要流程可以分为这么几步：</p><p><strong>1.</strong> 获取注解的属性，用于后面的排除<br><strong>2.</strong> 获取所有需要自动装配的配置类的路径：这一步是最关键的，从<strong>META-INF/spring.factories</strong>获取自动配置类的路径<br><strong>3.</strong> 去掉重复的配置类和需要排除的重复类，把需要自动加载的配置类的路径存储起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">rotected AutoConfigurationImportSelector.AutoConfigurationEntry<br><span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//1.获取到注解的属性</span><br>        <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span><span class="hljs-built_in">this</span>.getAttributes(annotationMetadata);<br>        <span class="hljs-comment">//2.获取需要自动装配的所有配置类，读取META-INF/spring.factories，获取自动配置类路径</span><br>        List&lt;String&gt; configurations =<span class="hljs-built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>        <span class="hljs-comment">//3.1.移除重复的配置</span><br>        configurations = <span class="hljs-built_in">this</span>.removeDuplicates(configurations);<br>        <span class="hljs-comment">//3.2.处理需要排除的配置</span><br>        Set&lt;String&gt; exclusions =<span class="hljs-built_in">this</span>.getExclusions(annotationMetadata, attributes);<br>        <span class="hljs-built_in">this</span>.checkExcludedClasses(configurations, exclusions);<br>        configurations.removeAll(exclusions);<br>        configurations =<span class="hljs-built_in">this</span>.getConfigurationClassFilter().filter(configurations);<br>        <span class="hljs-built_in">this</span>.fireAutoConfigurationImportEvents(configurations,exclusions);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations,exclusions);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="如何自定义一个SpringBoot-Srarter"><a href="#如何自定义一个SpringBoot-Srarter" class="headerlink" title="如何自定义一个SpringBoot Srarter?"></a>如何自定义一个SpringBoot Srarter?</h2><p><strong>1.</strong> <strong>创建一个项目，命名为demo-spring-boot-starter，引入SpringBoot相关依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.</strong> <strong>编写配置文件</strong></p><p>这里定义了属性配置的前缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//省略getter、setter</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.自动装配</strong></p><p>创建自动配置类HelloPropertiesConfigure</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableConfigurationProperties(HelloProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloPropertiesConfigure</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4.配置自动类</strong></p><p>在/resources/META-INF/spring.factories文件中添加自动配置类路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>cn.fighter3.demo.starter.configure.HelloPropertiesConfigure<br></code></pre></td></tr></table></figure><p><strong>5.测试</strong></p><ul><li>创建一个工程，引入自定义starter依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.fighter3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>在配置文件里添加配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">hello.name=张三<br></code></pre></td></tr></table></figure><ul><li>测试类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloTest</span> &#123;<br><span class="hljs-meta">@Autowired</span><br>HelloProperties helloProperties;<br>    <br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;你好，&quot;</span>+helloProperties.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830171452171.png" alt="image-20220830171452171" style="zoom:50%;" /><hr><h2 id="Springboot-启动原理？"><a href="#Springboot-启动原理？" class="headerlink" title="Springboot 启动原理？"></a>Springboot 启动原理？</h2><p>SpringApplication 这个类主要做了以下四件事情：</p><p><strong>1.</strong> 推断应用的类型是普通的项目还是 Web 项目<br><strong>2.</strong> 查找并加载所有可用初始化器 ， 设置到 initializers 属性中<br><strong>3.</strong> 找出所有的应用程序监听器，设置到 listeners 属性中<br><strong>4.</strong> 推断并设置 main 方法的定义类，找到运行的主类</p><p>SpringBoot 启动大致流程如下 ：</p><p><img src="/weiblog/img/%E9%9D%A2%E8%AF%95-spring/image-20220830171724441.png" alt="image-20220830171724441"></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>黑马程序员-SpringBoot2-基础</title>
    <link href="/weiblog/2022/08/26/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/"/>
    <url>/weiblog/2022/08/26/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a><strong>开发环境</strong></h1><p>学习要求</p><p>熟悉Spring基础<br>熟悉Maven使用<br>环境要求</p><p>Java8及以上<br>Maven 3.5及以上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-system-requirements">https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-system-requirements</a><br>学习资料</p><p>Spring Boot官网：<a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></p><p>Spring Boot 官方文档：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/">https://docs.spring.io/spring-boot/docs/current/reference/html/</a></p><p>Spring Boot 中文文档：<a href="http://felord.cn/_doc/_springboot/2.1.5.RELEASE/_book/">http://felord.cn/_doc/_springboot/2.1.5.RELEASE/_book/</a></p><p>视频地址：<a href="https://www.bilibili.com/video/BV15b4y1a7yG?p=24&amp;share_source=copy_web">https://www.bilibili.com/video/BV15b4y1a7yG?p=24&amp;share_source=copy_web</a></p><p>源码地址：GitHub Gitee</p><h1 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a><strong>内容介绍</strong></h1><p>Java基础语法<br><strong>Spring与SpringMVC</strong><br>    知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能<br><strong>Mybatis与Mybatis-Plus</strong><br>    基于Mybatis和MybatisPlus能够开发出包含基础CRUD功能的标准Dao模块<br><strong>数据库MySQL</strong><br>    能够读懂基础CRUD功能的SQL语句<br><strong>服务器</strong><br>    知道服务器与web工程的关系，熟悉web服务器的基础配置<br><strong>maven</strong><br>    知道maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承<br><strong>web技术（含vue，ElementUI)</strong><br>    知道vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定</p><h1 id="SpringBoot框架搭建"><a href="#SpringBoot框架搭建" class="headerlink" title="SpringBoot框架搭建"></a><strong>SpringBoot框架搭建</strong></h1><h2 id="SpringBoot入门案例（Idea联网版）"><a href="#SpringBoot入门案例（Idea联网版）" class="headerlink" title="SpringBoot入门案例（Idea联网版）"></a>SpringBoot入门案例（Idea联网版）</h2><ul><li>SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程</li></ul><p>①：创建新模块，选择Spring Initializr，并配置模块相关基础信息</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><p>②：选择当前模块需要使用的技术集</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-16615262798512.png" alt="img"></p><p>③：开发控制器类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Rest 模式</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/books&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <span class="hljs-meta">@GetMapping</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getById</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;springboot is running...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;springboot is running...&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>④：运行自动生成的Application类</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-16615263437584.png" alt="img"></p><p>⑤：打开浏览器访问url地址为：<a href="http://localhost:8080/books">http://localhost:8080/books</a></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-16615263693396.png" alt="img"></p><p>最简SpringBoot程序所包含的基础文件 (pom.xml文件 和 Application类 )</p><ul><li>pom.xml文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-01-quickstart<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>Application类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot0101QuickstartApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Springboot0101QuickstartApplication.class, args);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Spring程序与SpringBoot程序对比</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-16615265960678.png" alt="img"></p><p><strong>注意: 基于idea开发SpringBoot程序需要确保联网且能够加载到程序框架结构</strong></p><p>小结:</p><ol><li>开发SpringBoot程序可以根据向导进行联网快速制作</li><li>SpringBoot程序需要基于JDK8进行制作</li><li>SpringBoot程序中需要使用何种功能通过勾选选择技术</li><li>运行SpringBoot程序通过运行Application程序入口进行</li></ol><h2 id="SpringBoot入门案例（官网创建版）"><a href="#SpringBoot入门案例（官网创建版）" class="headerlink" title="SpringBoot入门案例（官网创建版）"></a>SpringBoot入门案例（官网创建版）</h2><p>基于SpringBoot官网创建项目，地址：<a href="https://start.spring.io/">https://start.spring.io/</a></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152670467010.png" alt="img"></p><p>小结:</p><ol><li>打开SpringBoot官网，选择Quickstart Your Project</li><li>创建工程，并保存项目</li><li>解压项目，通过IDE导入项目</li></ol><h2 id="SpringBoot入门案例（阿里云版）"><a href="#SpringBoot入门案例（阿里云版）" class="headerlink" title="SpringBoot入门案例（阿里云版）"></a>SpringBoot入门案例（阿里云版）</h2><p>基于阿里云创建项目，地址：<a href="https://start.aliyun.com/">https://start.aliyun.com</a></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152678068812.png" alt="img"></p><p>注意事项:</p><ul><li>阿里云提供的坐标版本较低，如果需要使用高版本，进入工程后手工切换SpringBoot版本</li><li>阿里云提供的工程模板与Spring官网提供的工程模板略有不同</li></ul><p>小结:</p><ol><li>选择start来源为自定义URL</li><li>输入阿里云start地址</li><li>创建项目</li></ol><h2 id="SpringBoot入门案例（手工制作版）"><a href="#SpringBoot入门案例（手工制作版）" class="headerlink" title="SpringBoot入门案例（手工制作版）"></a>SpringBoot入门案例（手工制作版）</h2><p>手工创建项目（手工导入坐标）</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152684169214.png" alt="img"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_01_04_quickstart<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>手工创建项目（手工制作引导类）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>小结:</p><ol><li>创建普通Maven工程</li><li>继承spring-boot-starter-parent</li><li>添加依赖spring-boot-starter-web</li><li>制作引导类Application</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>创建SpringBoot工程的四种方式</strong><br><strong>基于Idea创建SpringBoot工程</strong><br><strong>基于官网创建SpringBoot工程</strong><br><strong>基于阿里云创建SpringBoot工程</strong><br><strong>手工创建Maven工程修改为SpringBoot工程</strong></p><h1 id="隐藏文件或文件夹"><a href="#隐藏文件或文件夹" class="headerlink" title="隐藏文件或文件夹"></a><strong>隐藏文件或文件夹</strong></h1><p>.mvn;.gitignore;HELP.md;mvnw;mvnw.cmd;*.iml;</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152716936616.png" alt="img"></p><p>2018版的做法:</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152718849418.png" alt="img"></p><p>较新版本的做法 :</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152720975220.png" alt="img"></p><p>小结:</p><p>Idea中隐藏指定文件或指定类型文件<br>Setting → File Types → Ignored Files and Folders<br>输入要隐藏的文件名，支持*<strong>号通配符</strong><br>回车确认添加</p><h1 id="入门案例解析"><a href="#入门案例解析" class="headerlink" title="入门案例解析"></a><strong>入门案例解析</strong></h1><h2 id="parent"><a href="#parent" class="headerlink" title="parent"></a><strong>parent</strong></h2><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152899995522.png" alt="img"></p><ul><li>parent</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-01-quickstart<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>按住Ctrl点击pom.xml中的spring-boot-starter-parent，跳转到了spring-boot-starter-parent的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>按住Ctrl点击pom.xml中的spring-boot-starter-dependencies，跳转到了spring-boot-starter-dependencies的pom.xml，xml配置如下（只摘抄了部分重点配置）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activemq.version</span>&gt;</span>5.15.3<span class="hljs-tag">&lt;/<span class="hljs-name">activemq.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">antlr2.version</span>&gt;</span>2.7.7<span class="hljs-tag">&lt;/<span class="hljs-name">antlr2.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appengine-sdk.version</span>&gt;</span>1.9.63<span class="hljs-tag">&lt;/<span class="hljs-name">appengine-sdk.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artemis.version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">artemis.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">aspectj.version</span>&gt;</span>1.8.13<span class="hljs-tag">&lt;/<span class="hljs-name">aspectj.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">assertj.version</span>&gt;</span>3.9.1<span class="hljs-tag">&lt;/<span class="hljs-name">assertj.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">atomikos.version</span>&gt;</span>4.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">atomikos.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bitronix.version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">bitronix.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build-helper-maven-plugin.version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">build-helper-maven-plugin.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">byte-buddy.version</span>&gt;</span>1.7.11<span class="hljs-tag">&lt;/<span class="hljs-name">byte-buddy.version</span>&gt;</span><br>  ... ... ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      ... ... ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kotlin-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;kotlin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jooq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jooq.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>          ... ... ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>从上面的spring-boot-starter-dependencies的pom.xml中我们可以发现，一部分坐标的版本、依赖管理、插件管理已经定义好，所以我们的SpringBoot工程继承spring-boot-starter-parent后已经具备版本锁定等配置了。所以起步依赖的作用就是进行依赖的传递。</p><p>小结:</p><ul><li>开发SpringBoot程序要继承spring-boot-starter-parent</li><li>spring-boot-starter-parent中定义了若干个依赖管理</li><li>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突</li><li>继承parent的形式也可以采用引入依赖的形式实现效果</li></ul><h2 id="starter"><a href="#starter" class="headerlink" title="starter"></a><strong>starter</strong></h2><ul><li>spring-boot-starter-web.pom<br>按住Ctrl点击pom.xml中的<strong>spring-boot-starter-web</strong>，跳转到了spring-boot-starter-web的pom.xml，xml配置如下（只摘抄了部分重点配置）：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starters<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Boot Web Starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.9.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>从上面的spring-boot-starter-web的pom.xml中我们可以发现，spring-boot-starter-web就是将web开发要使用的spring-web、spring-webmvc等坐标进行了“打包”，这样我们的工程只要引入spring-boot-starter-web起步依赖的坐标就可以进行web开发了，同样体现了依赖传递的作用。<br><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16-166152990382124.png" alt="img"></p><p><strong>starter</strong><br>SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标，以达到减少依赖配置的目的<br><strong>parent</strong><br>所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的<br>spring-boot-starter-parent各版本间存在着诸多坐标版本不同<br><strong>实际开发</strong><br>使用任意坐标时，仅书写GAV(groupId, artifactId, version)中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V<br>如发生坐标错误，再指定Version（要小心版本冲突）</p><p>小结:</p><ol><li>开发SpringBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到简化配置的目的</li></ol><h2 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h2><ul><li>启动方式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Springboot0101QuickstartApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> SpringApplication.run(Springboot0101QuickstartApplication.class, args);<br>        <span class="hljs-comment">//获取bean对象</span><br>        <span class="hljs-type">BookController</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> ctx.getBean(BookController.class);<br>        System.out.println(<span class="hljs-string">&quot;bean======&gt;&quot;</span> + bean);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目</li><li>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</li></ul><p>小结:</p><ol><li>SpringBoot工程提供引导类用来启动程序</li><li>SpringBoot工程启动后创建并初始化Spring容器</li></ol><h2 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h2><p>辅助功能 内嵌tomcat</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"></p><ul><li>使用maven依赖管理变更起步依赖项</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--web 起步依赖环境中，排除 Tomcat 起步依赖 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加 Jetty 起步依赖，版本由 SpringBoot 的 starter 控制 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>Jetty比Tomcat更轻量级，可扩展性更强（相较于Tomcat），谷歌应用引擎（GAE）已经全面切换为Jetty</li><li>内置服务器<ul><li>tomcat(默认) apache出品，粉丝多，应用面广，负载了若干较重的组件</li><li>jetty 更轻量级，负载性能远不及tomcat</li><li>undertow undertow，负载性能勉强跑赢tomcat</li></ul></li></ul><p>小结:</p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><p>总结:</p><ol><li>入门案例（4种方式）</li><li>SpringBoot概述<br>parent<br>starter<br>引导类<br>辅助功能（内嵌tomcat）</li></ol><h1 id="REST风格"><a href="#REST风格" class="headerlink" title="REST风格"></a><strong>REST风格</strong></h1><h2 id="REST风格简介"><a href="#REST风格简介" class="headerlink" title="REST风格简介"></a>REST风格简介</h2><p><strong>什么是 rest ：</strong></p><p>REST（Representational State Transfer）表现形式状态转换</p><p>传统风格资源描述形式<br><a href="http://localhost/user/getById?id=1">http://localhost/user/getById?id=1</a> (得到id为1的用户)<br><a href="http://localhost/user/saveUser">http://localhost/user/saveUser</a> (保存用户)</p><p>REST风格描述形式<br><a href="http://localhost/user/1">http://localhost/user/1</a> (得到id为1的用户)<br><a href="http://localhost/user">http://localhost/user</a> (保存用户)</p><p><strong>优点:</strong></p><ul><li>隐藏资源的访问行为， 无法通过地址得知对资源是何种操作</li><li>书写简化</li></ul><p>按照REST风格访问资源时使用<strong>行为动作</strong>区分对资源进行了何种操作</p><p><strong>GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">http://localhost/users 查询全部用户信息 GET (查询)<br>http://localhost/users/1 查询指定用户信息 GET (查询)<br>http://localhost/users 添加用户信息 POST (新增/保存)<br>http://localhost/users 修改用户信息 PUT (修改/更新)<br>http://localhost/users/1 删除用户信息 DELETE (删除)<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>上述行为是约定方式，约定不是规范，可以打破，所以称REST风格，而不是REST规范<br>描述模块的名称通常使用复数，也就是加s的格式描述，表示此类资源,而非单个资源，例如: users、 books、 accounts…</p><p>根据REST风格对资源进行访问称为<strong>RESTful</strong></p><p>小结：</p><ol><li>REST</li><li>动作4个</li><li>RESTful</li></ol><h2 id="RESTful入门案例"><a href="#RESTful入门案例" class="headerlink" title="RESTful入门案例"></a><strong>RESTful入门案例</strong></h2><p>步骤:</p><p>①:设定http请求动作(动词)</p><p>使用 @RequestMapping 注解的 method 属性声明请求的方式</p><p>使用 @RequestBody 注解 获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。get 请求方式不适用。</p><p>使用@ResponseBody 注解实现将 controller 方法返回对象转换为 json 响应给客户端。</p><p>@RequestMapping(value=”/users”,method=RequestMethod.POST)</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/8fc4afea23a513d605b885db910e2ac8.png" alt="image-20220111162324969"></p><p>②:设定请求参数(路径变量)</p><p>使用<code>@PathVariable</code> 用于绑定 url 中的占位符。例如：请求 url 中 /delete/<code>&#123;id&#125;</code>，这个<code>&#123;id&#125;</code>就是 url 占位符。</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/d35b1e484bae94e8f5b5c5804610afbe.png" alt="image-20220111163317065"></p><ul><li>@RequestMapping</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/1b6cff3e21c9f8f39d03609ca5549dc5.png" alt="image-20220111163720579"></p><ul><li>@PathVariable</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/70f82ea4f1c61a34eb68fda48cc9ada3.png" alt="image-20220111163858308"></p><ul><li>@RequestBody @RequestParam @PathVariable</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/9b9324456b495d978751d23ce868c101.png" alt="image-20220111164352046"></p><h2 id="RESTful快速开发"><a href="#RESTful快速开发" class="headerlink" title="RESTful快速开发"></a><strong>RESTful快速开发</strong></h2><ul><li>使用 <strong>@RestController</strong> 注解开发 RESTful 风格</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/image-20220828011434213.png" alt="image-20220828011434213"></p><ul><li>使用 <strong>@GetMapping @PostMapping @PutMapping @DeleteMapping</strong> 简化 <strong>@RequestMapping</strong> 注解开发</li></ul><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/image-20220828011609581.png" alt="image-20220828011609581"></p><h1 id="复制模块"><a href="#复制模块" class="headerlink" title="复制模块"></a><strong>复制模块</strong></h1><p>原则<br>保留工程基础结构<br>抹掉原始工程痕迹</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5pqX5oGL6Iqx6aaZ,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="在这里插入图片描述"></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/b0eba06b936d4243b47b6faaf3842e95.png" alt="在这里插入图片描述"></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/5f36f2235926f2a2a7aa521a850a7109.png" alt="img"></p><p>在IDEA 中点击模块管理添加模块</p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/image-20220828223123256.png" alt="image-20220828223123256"></p><p><img src="/weiblog/img/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-springboot2-%E5%9F%BA%E7%A1%80/image-20220828223205172.png" alt="image-20220828223205172"></p><p>小结:</p><ol><li>在工作空间中复制对应工程，并修改工程名称</li><li>删除与Idea相关配置文件，仅保留src目录与pom.xml文件</li><li>修改pom.xml文件中的artifactId与新工程/模块名相同</li><li>删除name标签（可选）</li><li>保留备份工程供后期使用</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
